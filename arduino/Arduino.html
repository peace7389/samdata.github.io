<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Android Basics and User Interfaces</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="Arduino.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Getting Started with Arduino</h1>
<h2>&nbsp;</h2>
</div>

<div id="content-main">

<!-- @@ end change in v1 -->

<h3>Introduction</h3>

<p>"Arduino is an open-source electronics prototyping platform based on 
flexible, easy-to-use hardware and software. It is intended for artists,
 designers, hobbyists, and anyone interested in creating interactive 
objects or environments."</p>

<p>The mother site for Arduino is <a href="http://arduino.cc/">http://arduino.cc</a>.</p>

<h3>Getting Started with Arduino UNO</h3>

<h5>Step 0: Buy an Arduino Board</h5>
<p>Arduino Board comes in many flavors. A minimal "Arduino UNO" board for starter costs less than US$5 and can be purchased thru many online stores. I suggest that you buy an &quot;Arduino Starter Kit&quot;, which comes with an Arduino UNO board and  various electronics components (LEDs, resistors, transistors, motors, breadboard, wires, etc.) for you to start some simple experiments, for US$20-40.</p>

<img class="image-center" src="images/ArduinoUno.png" alt="arduino" />

<p>An Arduino UNO board contains the following:</p>
<ul>
<li>An Atmel (bought over by Microchip in 2016) ATmega328P 8-bit Micro-controller (<a href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328-328P_Datasheet.pdf">Complete Data-sheet</a> - 442 pages, <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328-328P_Summary.pdf">Summary</a> - 24 pages), with 32KB of Flash memory for  programs, 2KB of SRAM for data, and 1KB of  EEPROM for non-volatile data. The clock speed is 16MHz.</li>

<li>Power IN: The power to Arduino board can be supplied via:

<ul>
<li>USB Connector (5V): also double as serial port to communicate with the computer (e.g., for loading program).</li>
  <li>DC Power Jack (7-12V via AC-to-DC adapter or battery pack).</li>
<li>Vin/GND pins (7-12V with 9V battery).</li>
<li>Power by 5V  supply: Although the 5V pin is meant for powering external components, you could  power the Arduino via the 5V/GND pins. This is not recommended because you could get the polarity and voltage wrong and damage your arduino. A better way is to connect your 5V power supply to the USB connector. Get an old USB cable, cut the plug off the other end, and connect Red wire to 5V supply and Black wire to GND. USB connector is better than the crappy header pins and you can't mess up the polarity.</li>
</ul></li>

<li>Power OUT (5V and 3.3V pins): The board  regulated 5V and 3.3V output for powering external components.
  <ul>
<li>If the board is powered via USB, the total current available for &quot;on-board&quot; and &quot;external use via the 5V power out pin&quot; is 500mA (and much less for the other power sources).</li>
<li>The  current available at 3.3V pin is 50mA.</li>
</ul></li>

<li>On-board Built-in LEDs: These LEDs are useful in debugging.
  <ul>
<li>Power-on LED: indicate that the Arduino board is receiving power.</li>
<li>Load cum Pin-13 LED: Flicker during sketch upload. Also connected to Digital Pin 13 for program testing and debugging.</li>
<li>TX and RX LEDs: indicate communication between the Arduino board and your computer. Flicker during sketch upload and serial communication.</li>
</ul></li>

<li>Reset Button: to reset/restart the program.</li>
<li>14x Digital INPUT/OUTPUT pins (numbered from 0 to 13):
  <ul>
<li>Use function <code>pinMode(0-13, INPUT|OUTPUT)</code> to configure the pin for input or output; and <code>digitalRead(0-13)</code> or <code>digitalWrite(0-13, HIGH|LOW)</code> to read or write.</li>
<li>Each pin operates at 5V at <code>HIGH</code> and 0V at <code>LOW</code>. It can provide or receive a maximum current of 40mA, but only 20mA continuous, which is merely sufficient to drive a single-color LED @ 20mA for full brightness continuously.</li>
<li>Total current for the chipset shall not exceed 200mA, i.e., driving 10 single-color LEDs @ 20mA.</li>
<li>Pin 13: There is a built-in LED connected to Pin 13, under Pin 13. It is useful for debugging.</li>
<li>PWM Output: 6 of the pins (pins 3, 5, 6, 9, 10 and 11, marked with ~) can produce PWM (Pulse Width Modulated) output (i.e., square wave) via function <code>analogWrite(3|5|6|9|10|11, <em>dutyCycle</em>)</code>
 with duty cycle between 0 (off) to 255 (on). The PWM square wave at 
various duty cycles (as illustrated below) can be used to simulate "analog" output (e.g., to 
control the brightness of LED or speed of motor). The frequency of PWM 
is 980Hz on pins 5 and 6; and 490Hz (half) for other pins.
<img class="image-center" src="images/pwm.png" />
</li>
</ul></li>
<li>6x Analog INPUT pins (A0 to A5): By default, each pin can measure 
between 0V to 5V with 10-bit of resolution via a analog-to-digital converter (ADC). The upper range can be 
changed using the AREF pin and <code>analogReference()</code> function. These analog pins are labeled A0 to A5 (whereas digital pins are labeled 0 to 13). We can use <code>pinMode(A0-A5, INPUT)</code> (optional but nice to have) and <code>analogRead(A0-A5)</code> to read the 10-bit analog input <code>[0,1023]</code>.<br />
The primary purpose of the analog input pins A0-A5 is to read analog input.  However, these pins can also function exactly like digital pins 0-13 for digital input/output. We can use <code>pinMode(A0-A5, INPUT/OUTPUT)</code> to set its I/O mode, and and <code>digitalRead(A0-A5)</code> or <code>digitalWrite(A0-A5, HIGH|LOW)</code> to read or write.</li>
<li>1x Programmable Serial Port (USART): Use Digital Pin 0 for RX and Digital Pin 1 for TX; or the USB connection (for communicating with the PC such as loading program).</li>
<li>Interrupts: Pins 2 and 3 can be used for &quot;external&quot; interrupt and mapped to <code>INT0</code> and <code>INT1</code>. All 20 pins (14x digital + 6x analog) can be used for &quot;pin-change&quot; interrupt.</li>
</ul>

<p>Brief summary of digital/analog pins and read/write functions:</p>
<ul>
<li><code>pinMode(0-13|A0-A5, INPUT|OUTPUT)</code>: Set the pin to <code>INPUT</code> or <code>OUTPUT</code>. Digital pins are numbered from 0 to 13. Analog pins are numbered A0 to A5.</li>
<li><code>digitalRead(0-13|A0-A5)</code>, <code>digitalWrite(0-13|A0-A5, HIGH|LOW)</code>: applicable to all digital and analog pins.</li>
<li><code>analogWrite(3|5|6|9|10|11, dutyCycle)</code>: applicable to PWM digital pins only, where <code>dutyCycle=[0,255]</code>, 0 for low and 255 for high.</li>
<li><code>analogRead(A0-A5)</code>: read 10-bit input in the range of [0, 1023] for 0-5V from analog input pins.</li>
</ul>

<p>Protecting the Arduino Board:</p>
<ol>
<li>Many of my students throw the Arduino board around like a soft toy, and short  the connections underneath. You can buy a plaster casting or simply use masking tape to cover the base of the Arduino board.</li>
<li>Discount the power/USB cable to the Arduino board, when you are connecting the circuitry. This also protect you precious PC!</li>
</ol>

<h5>Step 1: Download the Arduino IDE</h5>

<ol>
<li>Download the Arduino IDE from Arduino mother site @ <a href="http://arduino.cc/en/Main/Software">http://arduino.cc/en/Main/Software</a>, choose the version that matches your operating platform (e.g., Windows or Mac OS X) and download the zip file (e.g., <code>arduino-1.8.x-windows.zip</code>).</li>
<li>Unzip the downloaded file into a directory of your choice (e.g., "<code>D:\myProject</code>"). The Arduino Development Kit will be unzipped into "<code>D:\myProject\arduino-1.8.x</code>". I shall denote the installed directory as <code>$ARDUINO_HOME</code> in this article. Arduino SDK is "<code>arduino.exe</code>".</li>
</ol>

<h5>Step 2: Plug-in the Arduino Board to Install the Driver (Good Luck Needed!!!)</h5>
<ol>
<li>Plug in the Arduino board with the USB cable to the computer. You shall see the &quot;POWER ON&quot; LED lights up (in green or orange).</li>
<li>(For Windows) Install the driver. Run &quot;Control Panel&quot; ⇒ &quot;Device Manager&quot; (right-click and &quot;run as administrator&quot;) ⇒ Look 
for and right-click on the "Unknown device" (or under &quot;Ports (COM &amp; LPT)&quot;) ⇒ "Update Device Driver" ⇒ 
Set to <code>$ARDUINO_HOME\drivers</code> (i.e., the unzipped Arduino 
directory). Ignore the warning message. The device shall be installed as
 &quot;Arduino Uno (COMxx)&quot; under &quot;Ports (COM &amp; LPT)&quot;.<br />
If your board is not detected by your computer (i.e., there is no unknown device in the above step), try connecting to another USB port; try another Arduino Board; try your Arduino Board on another computer; and so on... But don't try to spend days fixing the Arduino driver!!!</li>
<li>(For Mac OS X) [TODO]</li>
<li>(For Ubuntu) [TODO]</li>
</ol>

<h5>Step 3: Launch the Arduino SDK to Write your First Program</h5>
<ol>
<li>Run "<code>arduino.exe</code>" (at <code>$ARDUINO_HOME</code>).</li>
<li>Copy the following program (called <em>sketch</em> in Arduino) into the editor panel:
  <pre class="color-example">#define BUILTIN_LED_PIN 13    <span class="color-comment">// A Built-in LED connected to digital Pin 13</span>
 
<span class="color-comment">/* 
 * Setup() runs only once for initialization 
 */</span>
void setup() {
   pinMode(BUILTIN_LED_PIN, OUTPUT);    <span class="color-comment">// Set Pin 13 (digital) to OUTPUT mode</span>
}
<span class="color-comment">
/* 
 * loop() repeats forever after setup() completed
 */</span>
void loop() {
   digitalWrite(BUILTIN_LED_PIN, HIGH);  <span class="color-comment">// Set Pin 13 to HIGH (5V) to turn ON its built-in LED</span>
   delay(1000);                  <span class="color-comment">// Delay in msec</span>
 
   digitalWrite(BUILTIN_LED_PIN, LOW);   <span class="color-comment">// Set Pin 13 to LOW (0V) to turn OFF its built-in LED</span>
   delay(1000);                  <span class="color-comment">// Delay in msec</span>
}</pre></li>

<li>Click "Verify" button (or "Sketch" menu ⇒ "Verify/Compile"; or Ctrl-R) to compile the code.</li>
<li>Click "Upload" button (or "File" menu ⇒ "Upload"; or Ctrl-U) to 
upload the code onto the Arduino board. You should see the LED 
under Pin 13 blinking (in orange) indicating program loading.<br />
If you see the error message "<code>avrdude: stk500_getsync(): not in sync: resp=0x30</code>". Goto   menu &quot;Tool&quot; menu ⇒ &quot;Serial Port&quot; ⇒ choose the correct &quot;COMx&quot;. You can verify your COM port via &quot;Control Panel&quot; &rArr; &quot;Device Manager&quot; &rArr; Take note of the COM port setting for &quot;Arduino UNO&quot;.</li>
<li>After the program is loaded, you shall see the Pin-13 LED (under the Pin 13, same LED as program load) turning on and off every 1 second, forever.</li>
</ol>

<h5>Dissecting the Program</h5>
<ul>
<li>An arduino program (called <em>sketch</em>) has at least two functions: <code>setup()</code> which runs once at startup (or reset) for initialization tasks; and <code>loop()</code> which repeats forever after <code>setup()</code> completed.</li>

<li>The <code>pinMode(pinNumber, INPUT|OUTPUT)</code> function sets the <code>pinNumber</code> to either <code>INPUT</code> or <code>OUTPUT</code>.</li>

<li>The <code>digitalWrite(pinNumber, HIGH|LOW)</code> function sets the digital output pin to either <code>HIGH</code> (5V) or <code>LOW</code> (0V). Take note that a digital output pin can provide a maximum current of 40mA or 20mA continuously.</li>
<li>The <code>#define</code> is resolved at compiled time, which may reduce the SRAM footprint (comparing of using a variable).</li>
</ul>

<h5>Examples</h5>
<p>Arduino IDE provides many examples, under &quot;File&quot; &rArr; &quot;Examples&quot;, or &quot;File&quot;  &rArr; &quot;Sketchbook&quot;.</p>
<p>For example, the above codes can be found under &quot;File&quot; &rArr; &quot;Examples&quot; &rArr; &quot;Built-in Examples&quot; &rArr; &quot;01.Basics&quot; &rArr; &quot;Blink&quot;.</p>

<h5>Processing Sketchbook Software</h5>

<p>Arduino IDE is based on processing (@ <a href="https://processing.org/">https://processing.org/</a>), which &quot;is a flexible software sketchbook and a language for learning how to code within the context of the visual arts&quot;.</p>



<h3>Get Set, but Before Go...</h3>

<h4>Electronic Tools and Equipment</h4>

<h5>MUST HAVE</h5>

<ul>
<li><span class="line-heading">Digital Multimeter</span> (You can buy a cheap multimeter for less than $20). Find a YouTube video to learn how to use the digital multimeter. 
  You need to know:
<ol>
<li>How to measure resistance.</li>
<li>How to do Continuity Check.</li>
<li>How to measure DC voltage.</li>
<li>How to measure DC current (in series).</li>
</ol>
Take note that the digital multimeter is mainly used to measure resistance, DC voltage and DC current. You need an oscilloscope to visualize waveforms.
</li>
<li><span class="line-heading">Toolbox</span>: Screw drivers (flat and cross), wire cutter, wire stripper, plier, Power main test pen/Screw driver, Insulation tapes, masking tapes (for marking, sealing), 22-Gauge solid wires (red, black and some colors), breadboard, etc.</li>
<li><span class="line-heading">Soldering Station</span> (with stand, third hand, wet sponge, solder sucker, solder wick): Read &quot;<a href="https://learn.sparkfun.com/tutorials/how-to-solder-through-hole-soldering">How to Solder: Through-Hole Soldering</a>&quot;, or find a YouTube video to learn on how to do soldering. For soldering iron with a temperature control, set it to about 350-370&deg;C to begin with.<br />
  Breadboard is meant for prototyping only. You need to solder on PCB for your final product!</li>
</ul>

<h5>NICE to HAVE</h5>

<ul>
<li><span class="line-heading">DC Power Supply</span> (e.g., 160W Digital Bench Power Supply, 0 to 32V DC, 0 to 5A) - You cannot survive with batteries.<br />
You need to know:

<ol>
<li>How to set the output DC voltage.</li>
<li>How to set the output DC current LIMIT (to avoid generating smoke!)</li>
<li>How to read the voltage and current output values.</li>
</ol>

<img src="images/DCPowerSupply.png" class="image-center" alt="DC Power Supply" />
A good DC power supply has 2 output channels, denoted as master and slave (some has an additional channel 3 for 5V). They can be configured as:
<ol>
<li>Isolated: each supply operates as completely separate and independent unit. This is the most frequently-used mode.</li>
<li>Parallel: output from slave unit is channeled into the master unit, to increase it current capability.</li>
<li>Series: Slave's positive output terminal is internally connected to master's negative output terminal.</li>
</ol>

You can read out the supply voltage and current from the panel. Watch the current reading carefully to avoid damaging your circuitry.<br />
The DC power supplies usually function in constant-voltage mode (which maintains constant voltage). You can set the current limit for the supplies (to protect your circuitry). Once the current limit is reached, the supply functions in constant-current mode and will not supply more current.<br />
For production, you can get a switching DC power supply at reasonably low cost. You need to know your voltage (5V, 12V, etc.) and the max current rating (3A, 5A, 10A, 50A, etc.)
<img src="images/DCSupply5V.png" class="image-center" alt="5V DC Power Supply" />
</li></ul>

<h5>Really NICE to Have</h5>

<ul>
<li><strong>Oscilloscope</strong></li>
<li><strong>Function Generator</strong></li>
</ul>

<h4>Etiquette</h4>
<p>Please observe good electronic work etiquette:</p>
<ul>
<li>Do not rest the Arduino Board on a metal surface, unless you want to generate smoke! Paste an insulating masking tape below or use a proper plastic (or wooden) cover.</li>
<li>Disconnect the power to the Arduino board when you are patching the circuit, to prevent short-circuiting and burning the Arduino board.</li>
<li>BE PATIENCE! BE SYSTEMATIC! DON'T CUT CORNER!</li>
<li>Tidy up your workbench. Place all your components and loose parts in boxes.</li>
<li>Wires come in COLOR for purpose. For DC circuit, use RED for power and BLACK for ground. Color-blind, unfortunately, will not pass the medical examination to practice electronics (because we use color codes in electronics).</li>
<li>Use the correct cables (gauge number) and connectors for your project.</li>
<li>Trim your connecting wires to the right (minimal) length for your final product - you are not using them to catch fish.</li>
<li>Draw proper design diagram, circuit diagram, connection diagram, etc.</li>
<li>Writing good programs. Comment your programming statements.</li>
<li>&quot;A craftsman is measured by his toolbox&quot;. Get and use the right tools.</li>
<li>......</li>
</ul>


<h3>LEDs</h3>

<p>I shall follow the exercises in:</p>
<ul>
<li>&quot;SparkFun Inventor's Kit (SIK) Experiment Guide - v4.0&quot; (the latest version at the time of this writing) @ <a href="https://learn.sparkfun.com/tutorials/sparkfun-inventors-kit-experiment-guide---v40/introduction">https://learn.sparkfun.com/tutorials/sparkfun-inventors-kit-experiment-guide---v40/introduction</a>.</li>

<li>The older version of &quot;SparkFun Inventor's Kit (SIK) Guide for Arduino&quot; @ <a href="https://www.sparkfun.com/products/retired/11227">https://www.sparkfun.com/products/retired/11227</a>, with PDF User's Guide @ <a href="http://cdn.sparkfun.com/datasheets/Kits/SFE03-0012-SIK.Guide-300dpi-01.pdf">http://cdn.sparkfun.com/datasheets/Kits/SFE03-0012-SIK.Guide-300dpi-01.pdf.</a></li>

<li>&quot;Oomlout's Arduino Experimentation Kit (ARDX)&quot; @<a href="http://www.oomlout.com/a/products/ardx/">http://www.oomlout.com/a/products/ardx/</a>.</li>
</ul>
<p>I shall  provide more technical explanation and computation for my 
engineering students. You need the hardware components to do these 
exercises. I suggest you purchase an "Arduino Starter Kit" which comes with common electronic components.</p>


<h4>LED Ex 1: Blinking LED (with a Current Limiting Resistor)</h4>

<p><span class="line-heading">Reference</span>: &quot;<a href="https://learn.sparkfun.com/tutorials/sparkfun-inventors-kit-experiment-guide---v40/circuit-1a-blink-an-led">SIK Circuit 1A: Blink an LED</a>&quot; or &quot;<a href="http://www.oomlout.com/oom.php/products/ardx/circ-01">Oomlout CIRC01 Getting Started</a>&quot;</p>

<p><span class="line-heading">Objective</span>: To turn ON and OFF an LED repeatedly (blink) every second.</p>

<h5>Components</h5>
<ul>
<li>1x LED (5mm Red or White). LED has polarity. The shorter leg with a flat spot is the cathode (-). The longer leg is the anode (+). You should also know how to use a digital multimeter to check the polarity of a diode.</li>
<li>1x 330Ω resistor.</li>
</ul>


<h5>Circuit Diagram</h5>

<img class="image-center" src="images/ArduinoEx1Blink.png" alt="Blinking LED" />

<h5>Program</h5>

<p>Run the program in &quot;<code>$ARDUINO_HOME\examples\01.Basics\Blink\Blink.ino</code>&quot;, or the following:</p>

<pre class="color-example">
<span class="color-comment">/*
 * Blink: Turns ON an LED on for one second, then turn OFF for one second, repeatedly.
 */</span>
#define LED_PIN 13   <span class="color-comment">// Give it a name for easy referencing</span>

<span class="color-comment">/* 
 * setup() run once for initialization
 */
</span>void setup() {
   pinMode(LED_PIN, OUTPUT);  <span class="color-comment">// initialize the digital pin as output</span>
}

<span class="color-comment">/*
 * loop() repeats forever after setup() completes
 */
</span>void loop() {
   digitalWrite(LED_PIN, HIGH);  <span class="color-comment">// turn the LED ON by making the voltage HIGH (5V)</span>
   delay(1000);                  <span class="color-comment">// wait for the given millisecond</span>
 
   digitalWrite(LED_PIN, LOW);   <span class="color-comment">// turn the LED OFF by making the voltage LOW (0V)</span>
   delay(1000);                  <span class="color-comment">// wait for the given millisecond</span>
}</pre>

<ul>
<li>An arduino program (called sketch) has at least two functions: <code>setup()</code> which runs once at startup (or reset) for initialization tasks; and <code>loop()</code> which repeats forever after <code>setup()</code>.</li>

<li>The program initializes (in <code>setup()</code>) by setting Pin 13 to OUTPUT mode (via <code>pinMode()</code>), which could output a digital HIGH (5V) or LOW (0V). It then outputs a HIGH (5V), delays for 1000 msec (1 sec), outputs a LOW (0V), delays for 1000 msec, repeatedly (in <code>loop()</code>).</li>

</ul>

<h5>Dissecting the Circuit for Engineering Students</h5>

<img class="image-center" src="images/LED5mm_Spec.png" alt="LED Spec" />

<ul>
<li>Unlike resistor, LEDs are non-linear devices and they do not follow Ohm's law. LEDs are treated as current devices with a constant voltage drop. The suggested forward current for a typical 5mm LED is 20mA to get its full brightness.</li>
<li>In  practical design, we treat LED's forward voltage as constant at 3.6V (for white, blue and green LED), or 2.2V (for red LED, see <a href="https://www.sparkfun.com/products/9590">datasheet</a>).</li>
<li>We need to choose a resistor R (known as current limiting resistor) such that <code>I<sub>L</sub>=20mA</code> flowing through the resistor and the LED. Suppose that the supply is 5V (digital pin 13 outputs 5V when it is set to HIGH), <code>R=(5-3.6)V/20mA=70Ω</code> (for white, green or blue LED) or <code>R=(5-2.2)V/20mA=140Ω</code> (for red LED). Using a higher resistor results in lower current, and thus a dimmer LED (or NOT lighting up). Using a lower resistor results in higher current. This wastes power and may burn the LED. In engineering design, this R value serves as a starting point. Observe the brightness, measure the voltage/current, then fine-tune the R value.</li>
<li>The power consumption of the LED is <code>20mA*3.6V=72mW</code> (white, green, blue LED), or <code>20mA*2.2V=44mW</code> (red LED). Total power consumed is <code>20mA*5V=100mW</code>.</li>
<li>Take note that the Arduino's digital output pins provide a maximum current of 
40mA (or 20mA of continuous current), which is sufficient to drive 1-2 LEDs in parallel (@ 20mA each), but not more than two LEDs to their full brightness.</li>
<li>2 LEDs in series has voltage drop of <code>(2.2 to 3.6)*2=4.4 to 7.2V</code>. A 5V supply cannot drive more than 2 LEDs in series. We typically use a 12V supply to drive 3 LEDs in series (in some LED strips).</li>
</ul>

<h5>Practices for Engineering Students</h5>

<p>Different LEDs from different manufacturers have different rating (forward current and forward voltage). Worst still, you will not be able to find the correct datasheet. So, dig out your multimeter and measure yourself!</p>
<p>Note: If you are given 330&Omega; resistor only, you can connect two in parallel to get 165&Omega; (by applying  Ohm's law); three in parallel to get 110&Omega;.</p>

<ol>

<li>Set pin 13 to HIGH (to turn on the LED):

<ol>
<li>Using a digital multimeter, measure the voltage at pin 13 and the voltage across the LED. To measure voltage, place the meter in parallel (as illustrated) and set it to measure 20V (or auto-range).<br />
<img class="image-center" src="images/Arduino&#32;-&#32;Measure&#32;Voltage.png" /></li>
<li>Apply Ohm's law to compute the current flowing through the resistor (this same current 
flowing through the LED).</li>
<li>Using a digital multimeter, measure this current and compare with the computed value. To measure current, BREAK the circuit and place the meter in SERIES (as illustrated) and set the meter to measure 200mA (or auto-range).<br />
<img class="image-center" src="images/Arduino&#32;-&#32;Measure&#32;Current.png" /></li>
</ol>

ANS:
<ul>
<li>For white LED with a 330&Omega; resistor, measured LED forward voltage = 2.77V, measured forward current = 5.9mA. Computed <code>I<sub>L</sub>=(5-2.77)/330=5.75mA</code>.</li>
<li>For white LED with a 165&Omega; resistor, measured LED forward voltage = 2.85V, measured forward current = 10.6mA. Computed <code>I<sub>L</sub>=(5-2.85)/165=13mA</code>.</li>
<li>For red LED with a 330&Omega; resistor, measured LED forward voltage = 1.90V, measured forward current = 8.4mA. Computed <code>I<sub>L</sub>=(5-1.90)/330=9.3mA</code>.</li>
<li>For red LED with a 165&Omega; resistor, measured LED forward voltage = 1.95V, measured forward current = 15mA. Computed <code>I<sub>L</sub>=(5-1.95)/165=18.5mA</code>.</li>
<li>Take note that the forward voltages measured are fairly constant; while the forward current and LED brightness changes.</li>
</ul>

</li>

<li>Set pin 13 to LOW (to turn off the LED). Repeat the above measurements.</li>
<li>Repeat the above for RED, WHITE, GREEN and BLUE LEDs.</li>
<li>Repeat the above for two LEDs in parallel.</li>
<li>Repeat the above for two LEDs in series.</li>
<li>Repeat the above for three LEDs in parallel.</li>
</ol>

<h5>LED Exercise 1a: Change the Blinking Time</h5>
<p>To change the blinking rate, you can modify the delay, currently set at 1000 msec (or 1 sec).</p>

<h4>LED Ex 2: Controlling the Brightness of a Single-Color LED via PWM</h4>
<p>To control the brightness of the LED, use pin 9 (instead of pin 13), 
which can produce a PWM (Pulse Width Modulation) square wave via 
function <code>analogWrite(pinNumber, dutyCycle)</code> (<a href="http://arduino.cc/en/Tutorial/PWM">PWM Tutorial</a>). The <code>dutyCycle </code>sets the ON duration of the square wave, <code></code>with value ranges from 0 (always OFF) to 255 (always ON).</p>

<p>Try the following program:</p>

<pre class="color-example">
#define LED_PIN 9       <span class="color-comment">// LED connected to digital PWM pin 9</span>
#define DUTY_CYCLE 192  <span class="color-comment">// Duty cycle for the PWM over [0,255]</span>
 
<span class="color-comment">/* Setup() runs only once */</span>
void setup() {
   pinMode(LED_PIN, OUTPUT);  <span class="color-comment">// Set to OUTPUT mode</span>
}
<span class="color-comment">
/* loop() repeats forever */</span>
void loop() {
   analogWrite(LED_PIN, DUTY_CYCLE);  <span class="color-comment">// Try other values from 0 to 255</span>
   delay(1000);                       <span class="color-comment">// time delay in msec before repeat</span>

   <span class="color-comment">// Fade in from min to max in increments of 5</span>
   for (int fadeValue = 0 ; fadeValue &lt;= 255; fadeValue += 5) {
      analogWrite(ledPin, fadeValue);
      delay(30); <span class="color-comment">// small delay to see the effect</span>
   }

   <span class="color-comment">// Fade out from max to min in decrements of 5</span>
   for (int fadeValue = 255 ; fadeValue >= 0; fadeValue -= 5) {
      analogWrite(ledPin, fadeValue);
      delay(30);
   }
}</pre>

<p>The brightness of the LED is proportional to the duty cycle (ON duration). For example, if the value of duty cycle is 64, the LED is 25% of the full brightness. </p>

<h5>LED Exercise 2a: Fading LED</h5>

<p>Use pin 9 again, and run the program in "<code>$ARDUINO_HOME\examples\03.Analog\Fading\Fading.ino</code>". Study the program. Also run and study "<code>$ARDUINO_HOME\examples\01.Basics\Fade\Fade.ino</code>".</p>

<h4>LED Ex 3: Multiple LEDs</h4>

<p>Follow "CIRC02 8 LEDs Fun" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-02">http://www.oomlout.com/oom.php/products/ardx/circ-02</a>.</p>

<h4>LED Ex 4: RGB 4-Lead LED</h4>
<p>[TODO]</p>

<h4>LED Ex 5: Controlling the Color of RGB 4-Lead LED</h4>
<p>[TODO]</p>

<h3>LED - NOT for the Dummies</h3>

<h5>References</h5>
<ol>
<li>Ron Lenk and Carol Lenk, &quot;Practical Lighting Design with LEDs&quot;, Wiley, 2011.</li>
<li>Sparkfun's Tutorial - LED @ <a href="https://learn.sparkfun.com/tutorials/light-emitting-diodes-leds">https://learn.sparkfun.com/tutorials/light-emitting-diodes-leds</a>.</li>
</ol>


<h4>LED Basics</h4>
<h5>LED is a Diode</h5>

<p>An LED (Light Emitting Diode) is a diode!</p>

<p>A diode conducts current in the <em>forward</em> direction (from anode to cathode) and not the <em>reverse</em> direction.</p>

<ol>
<li>In the forward direction,  current flows from the anode to the cathode and light is emitted (all diodes emit a bit of light, but the amount of light emitted by ordinary diodes is very low). The voltage and current across the diode is called <em>forward voltage</em> and <em>forward current</em>, respectively. The forward voltage for a typical diode ranges from 0.7V to 1.0V.</li>
<li>In the reverse direction, no current (or  a minimal leakage current) flows thru the diode.</li>
</ol>

<img class="image-center" src="images/Arduino&#32;-&#32;Diode.png" />
<p>An LED has a much higher forward voltage than the ordinary diodes. While a diode has a voltage drop of about 0.7-1.0V, an LED may drop from 2.2V (Red LED) to 3.6V (Green, Blue and White LEDs). This is because LEDs are not made from silicon (it is hard to get silicon to emit light), but from other semiconductor materials (such as AlGaInP, InGaN, InGa1N).  Take note that white, green and blue LED has a higher forward voltage than red LED. This is because ...</p>
<p>The typical forward current for a 5mm LED is 20mA, resulting in power consumption of 20mA*(2.2-3.6)V = 44mW to 72mW.</p>

<h5>LEDs are Current Devices</h5>

<p>A resistor is a <em>linear</em> device that follows ohm's law, i.e., <code>V = I*R</code>.</p>

<p>A diode is a non-linear device, which does not follow ohm's law. The forward current <code>I<sub>f</sub></code> and forward  voltage <code>V<sub>f</sub></code> are exponentially related, i.e., <code>I<sub>f</sub> = I<sub>0</sub>*exp(k*V<sub>f</sub>)</code>; or <code>V<sub>f</sub> = (1/k)ln(I<sub>f</sub>/I<sub>0</sub>)</code>. Since <code>I<sub>f</sub></code> and <code>V<sub>f</sub></code> are exponentially related, doubling <code>I<sub>f</sub></code> results in only small increase in <code>V<sub>f</sub></code>. Hence, in practice, we can assume that the forward voltage <code>V<sub>f</sub></code> is always the same (e.g., 2.2V for red 5mm LED, 3.6V for green, blue and white 5mm LED), regardless of the forward current <code>I<sub>f</sub></code>. In other words, we treat diodes as current devices. We control the current to get the desired performance (e.g., 20mA for a 5mm LED to get its full brightness). Furthermore, as voltage is constant, the power consumption is determined by the current too (e.g., 4.4mW for red LED, 7.2mW for white LED).</p>
<p>[TODO] Voltage-Current Graph</p>

<h5>Classes of LEDs</h5>

<p>LEDs can be classified into two classes:</p>

<ol>
<li>Small Devices: typically 5mm (or T1 3/4) devices that run at 20mA. They are used as indicator, e.g., cell phone backlights, flashlights,  road signage, truck taillights, traffic lights, automobile dashboards, and so on. A typical 5mm white LED, with  forward current of 20mA and forward voltage of 3.6V, has a power of 72mW. You need 14 of them to make a 1W flashlight; 194 of them to make a 14W fluorescent bulb replacements (if we simply compare the wattages, ignoring the more important lumens).
<img class="image-center" src="images/LEDSamples.png" />
On LED Strips, you

will find the surface-mount 5050 RGB LED module. Each module has 3 LEDs, in red, green and blue. It takes 60mA (3x20mA) for full WHITE.</li>

<li>Power Devices: typically 1-3W devices that run at 350mA. They are used for lighting, rather than as indicators, e.g., flashlights, incandescent bulb/tube replacements, large-screen TVs, projector lights, automotive headlights, airstrip runway lighting, and so on.
<img class="image-center" src="images/PowerLEDSamples.png" />
</li>
</ol>


<h4>Driving LEDs (High-Current Load) using Power Transistor</h4>
<p>As mentioned, the maximum output current an Arduino's digital pin can supply is 40mA (or 20mA continuous current). You cannot use it to drive more than two 20mA LEDs in parallel. Likewise, the digital pin outputs 5V. You cannot use it to drive 3 LEDs in series (2.2V*3=6.6V). Suppose that we want to drive many LEDs in parallel via a single Arduino's digital output pin, we need an external power supply and a power-transistor switch, which can switch amperes of current.</p>

<h5>Choosing a Power Transistor</h5>
<p>The LED applications, we typically choose a &quot;TO-200&quot; package power transistor, which can dissipate 1W, as shown below. You can attach an external heat sink if needed.</p>

<p>There are two types of transistors:</p>
<ol>
<li>Bipolar Junction Transistors (BJT): BJT has three terminals, marked as Base (B), Emitter (E) and Collector (C). BJT is a current-controlled device where the Base's current controls the current at the collector and emitter. There are two types of BJT: NPN and PNP. They are identical, except on the polarity.</li>
<li>Metal Oxide Semiconductor Field-Effect Transistor (MOSFET): MOSFET also has three terminals, marked as Gate (G), Source (S) and Drain (D). Unlike BJT, MOSFET is a voltage-controlled device, where the Gate's voltage controls the current at the source and drain. There are two types of MOSFET, n-channel and p-channel.</li>
</ol>

<p>MOSFETs are more common nowadays for high power applications, as they handle power more efficiently. BJTs are still used for low current applications (like switches), as they are cheaper.</p>
<img class="image-center" src="images/PowerTransistor.png" />
<p>For examples,</p>
<ul>
<li>IRLB8721PbF N-channel Power MOSFETs (<a href="https://cdn-shop.adafruit.com/datasheets/irlb8721pbf.pdf">Datasheet</a>): can switch 30V of 16A (750 LEDs @ 20mA) with signal of 3.3V and 5V. Can dissipate up to 2 watts (400mA @ 5V) without a heat sink (at room temperature).</li>
<li>IRF630 N-Channel Power MOSFET can switch 200V of 9A, V<sub>GS</sub>=20V. IRF520 N-Channel Power MOSFET can switch 100V of 9A.</li>
<li>TIP120/121/122 NPN Epitaxial Darlington Transistor (<a href="https://cdn-shop.adafruit.com/datasheets/TIP120.pdf">Datasheet</a>): TIP120/121/122 can switch 60/80/100V of 5A (250 LEDs @ 20mA).</li>
</ul>

<h5>Transistor as an Electronic Switch</h5>

<p>A transistor can function as an amplifier (operating in active mode) or a switch (operating in saturation mode).</p>
<p>In this section, we shall focus on transistor as a switch. Just like a mechanical switch, you push it in to connect the circuit, and push it out to disconnect. A transistor can similarly serve as an &quot;electronic&quot; switch.</p>

<img class="image-center" src="images/MechanicalSwitch.png" />

<h5>N-Channel MOSFET as a Switch</h5>
<p>An N-channel MOSFET can be served as a active-high voltage-controlled switch. You set the Gate (G) to HIGH to connect  (switch-on) the Drain (D) and Source (S); and set the Gate (G) to LOW to disconnect  (switch-off) Drain (D) and Source (S), as illustrated.</p>
<img class="image-center" src="images/NMOSFETSwitch.png" />

<ul>
<li>The n-channel MOSFET is switched on when <code>V<sub>GS</sub>&gt;V<sub>TH</sub></code> (threshold voltage).</li>
<li>When the transistor is switched on by setting <code>V<sub>IN</sub>=HIGH</code>, <code>V<sub>DS</sub>≈0.2V</code>, and <code>I<sub>L</sub></code><sub> </sub>is controlled by the current limiting resistor <code>R<sub>L</sub></code>. Suppose that the load is 2.2V  and 350mA, <code>V<sub>DD</sub>=5V</code>, <code>R<sub>L</sub>=(5-2.2-0.2)V/350mA=7Ω</code>.</li>
<li>When the transitory is switched off by setting <code>V<sub>IN</sub>=LOW</code>, <code>I<sub>L</sub>=0</code>.</li>
<li>You may switch the position of <code>R<sub>L</sub></code> and the load.</li>
<li>MOSFET has an extremely high input resistance (almost infinite) making it possible to interface with nearly any logic gate or driver.</li>
<li>It is common practice to place a high-value resistor <code>R<sub>GS</sub></code> (10K&Omega; to 1M&Omega;) between the gate and source. It is used to bleed-off the electric charge from the gate and turn off the MOSFET. Otherwise, very small currents from your finger, capacitive coupling, inductive coupling, etc, may change the gate voltage.</li>
<li>The Gate resistor R<sub>G</sub> is optional. A small resistor (100&Omega;) could be used to prevent ringing, by dampen the ringing.</li>
</ul>

<p>Suppose that we are driving the following load:</p>

<img class="image-center" src="images/DrivingLoad.png" />

<p>Suppose that <code>V<sub>DD</sub>=5V</code>, <code>R<sub>L</sub>=(5-2.2-0.2)V/100mA=26Ω</code>.</p>


<h5>P-Channel MOSFET as a Switch</h5>
<img class="image-center" src="images/PMOSFETSwitch.png" />

<p>Similar to N-channel MOSFET, but P-channel MOSFET is:</p>
<ul>
<li>Active LOW, i.e., <code>V<sub>in</sub>=0V</code> to switch on, or <code>V<sub>SG</sub>&gt;V<sub>TH</sub></code> (threshold voltage).</li>
<li>You can connect one end of the load to the ground.</li>
<li>p-channel acts as a &quot;high-side&quot; switch, which is less popular than n-channel &quot;low-side&quot; switch.</li>
<li>For n-channel, the Source (S) is connected to the Ground; for n-channel, Source (S) is connected to V<sub>DD</sub>.</li>
</ul>

<h5>NPN BJT as a Switch</h5>

<p>For a NPN transistor, you set the base (B) to high (such that <code>I<sub>B</sub>&gt;I<sub>TH</sub></code> threshold current) to connect (switch on) the collector (C) and Emitter (E); and set the base (B) to low to disconnect (switch off) collector (C) and Emitter (E).</p>
<img class="image-center" src="images/NPNTransistorSwitch.png" />


<p>A NPN transistor functions as a current-controlled electronic switch, when it is operating in the so-called saturation mode:</p>
<ol>
<li>A small base current <code>I<sub>B</sub>&gt;I<sub>TH</sub></code> (threshold current) turns on the transistor, results in current flowing thru the collector and the emitter (and the load).</li>
<li>If <code>I<sub>B</sub>=0</code>, the transistor is switch OFF, results in no current flow thru the collector and emitter (and the load).</li>
</ol>

<p>You may switch the position of the <code>R<sub>L</sub></code> and the load.</p>
<img class="image-center" src="images/DrivingLoad.png" />

<p>We can turn ON an NPN transistor by setting <code>V<sub>IN</sub></code> to high (say 5V), results in <code>I<sub>B</sub></code> flowing from base to emitter<code></code>. When the transistor is turn on, we can accept that <code>V<sub>BE</sub>=0.8V</code> and <code>V<sub>CE</sub>=0.2V</code> (recall that diodes are treated as current devices, with constant voltage).  Suppose that <code>V<sub>DD</sub>=5V</code> and the desired <code>I<sub>L</sub>=100mA</code>, <code>R<sub>L</sub>=(5-2.2-0.2)V/100mA=26&Omega;</code>. To compute <code>R<sub>B</sub></code>, we use <code>I<sub>C</sub>=h<sub>FE</sub>*I<sub>B</sub></code>, where <code>h<sub>FE</sub></code> is the amplification factor. We can use <code>h<sub>FE</sub>=10</code> (or 20) at saturation region (amplification factor at saturation is much lower than active region). Suppose that <code>V<sub>IN</sub>=5V</code>, we have <code>R<sub>B</sub>=(5-0.8)V/(100mA/10)=420</code><code>&Omega;</code>. If the transistor does not turn on, use a lower resistance value. (Note: These values serve as a starting point for your design, use a multimeter to measure the voltages and currents to fine tune the values.)</p>
<p>We can turn OFF an npn transistor by setting <code>V<sub>IN</sub></code> to low (<code>0V</code>). In this case, <code>I<sub>B</sub>=0</code>, results in <code>I<sub>C</sub>=0</code>.</p>
<h5>PNP BJT as a Switch</h5>

<img class="image-center" src="images/PNPTransistorSwitch.png" />

<ul>
<li>Active low (instead of active high for NPN).</li>
<li>&quot;high-side&quot; switch (instead of &quot;low-side&quot; switch for NPN).</li>
<li>One terminal of load can be connected to ground (instead of one terminal to V<sub>DD</sub> for NPN).</li>
<li>Emitter connects to V<sub>DD</sub> (instead of Ground for NPN).</li>
</ul>



<h5>Exercises</h5>

<p>Use a transistor (NPN BJT or N-channel MOSFET) to drive 5 LEDs in parallel. Use a multimeter, measure the currents and voltages.</p>

<h3>LED Strips</h3>

<p>An LED Strip (also known as an LED Tape or Ribbon Light) is a flexible circuit board populated by surface-mounted LEDs (such as 5050 SMD RGB LED module) and other components, and usually comes with an adhesive backing. Some strips are waterproof for outdoor applications.</p>

<img class="image-center" src="images/LED5050.png" />

<p>LED strips can be classified as:</p>
<ol>
  <li>Non-addressable (or Analog): You cannot control individual LEDs. All LEDs show the SAME color.</li>
<li>Addressable (or Digital): Each segment has an Driver IC chip (containing latches and shift registers). You can control the color of each LED individually by sending serial digitally coded data to the chips, via the Data-In (DI) and an optional Clock-In (CI) leads, which propagates down the segments. They are more expensive.</li> 
</ol>

<p>An LED strip composes of identical segments. Each segment has 1-3 LED modules, with current limiting resistors. All segments are powered in parallel. LED strips typically operate on 12V (for 3 LED modules in series per segment) or 5V (for one LED module per segment). This is because an LED has forward voltage of 2.2-3.6V and 5V is not sufficient to drive more than one LEDs in series.</p>

<p>Each red, green and blue LED draws 20mA. Hence, full white draws 60mA. For a 20-RGB-module per meter, it draws 60mA*20=1.2A per meter, which is HUGE!!!</p>

<p>You CANNOT power the LED strips by the Arduino board (&lt;500mA - not enough current). You need to connect to an external power supply.</p>

<h4>Non-Addressable (Analog) 12V RGB LED Strip</h4>

<img class="image-center" src="images/RGB_LEDStrip.png" />
<img class="image-center" src="images/RGB_LEDStrip_Segment.png" />

<ul>
  <li>4 leads, marked as +12V, G, R, and B.</li>
  <li>Each segment has three 5050 RGB LED modules connected in series,  with common-anode (+) connected to 12V lead. Each component has a current limiting resistor (150-390&Omega;). All segment are connected in parallel.</li>
<li>Given that the forward voltage of an LED is between 2.2-3.6V, three LEDs in series take 6.6-10.8V. Hence, you need a 9-12V supply to drive three LEDs in series. Each LED draws 20mA.</li>
<li>Maximum 12V @ 60mA per strip segment.</li>
<li>Each segment is 50mm or 100mm, i.e., 20 or 10 segment per meter. For 20 segments per meter, the maximum current is 1.2A per meter. (My own measurements for a 20 segments per meter RGB LED strip draws about 970mA @ 12V; and 370mA @ 9V (which is sufficiently bright.)</li>
</ul>

<h5>Transistor Driver</h5>
<p>You need an external power source to drive the LED strip. You also need 3 Power Transistors (e.g., N-channel MOSFET or NPN BJT) to drive the current for each of the RGB components, as follows. The arduino pins are connected to <code>R<sub>IN</sub></code>, <code>G<sub>IN</sub></code>, <code>B<sub>IN</sub></code> to switch on/off the RGB LEDs.</p>

<img class="image-center" src="images/RGB_LEDStrip_Driver.png" />

<h5>Arduino Connection</h5>

<ol>
<li>Connect <code>R<sub>IN</sub></code>, <code>G<sub>IN</sub></code> and <code>B<sub>IN</sub></code> to Arduino pins;</li>
<li>Connect the 12V/GND to power supply;</li>
<li>Connect the GND from power supply to arduino (to establish common ground).</li>
</ol>

<p>To control the brightness and color of the LEDs, you can use PWM output to drive <code>R<sub>IN</sub></code>, <code>G<sub>IN</sub></code> and <code>B<sub>IN</sub></code> to turn on/off the LED at the specified duty cycle.</p>

<p>[TODO] more</p>

<h4>Addressable (Digital) RGB LED Strip</h4>

<p>Some addressable LED strips have 4 leads, labeled as GND/DI/CI/+5|12V or GND/DO/CO/+5|12V. DI and CI stand for &quot;Data-In&quot; and &quot;Clock-In&quot;; while &quot;DO&quot; and &quot;CO&quot; stands for &quot;Data-Out&quot; and &quot;Clock-Out&quot;. We need to connect to the &quot;IN&quot; end. The &quot;OUT&quot; end is used to cascade to the &quot;IN&quot; end of another strip.</p>
<p>There is an LED driver clip for each segment, which contains latches and shift registers. Data (thru DI) propagates through shift registers on each LED, using the clock at CI. The first LED driver reads the first 24 bits of data (8 bits each for Red, Green and Blue) on the DI, the second LED driver reads the next 24 bits, and so on.</p>
<p>Some addressable LED strips have only 3 leads, without the CI (Clock-In). In this case, you need to send the coded data in a specific timing (thru DI), typically at 800kHz or 400kHz.</p>

<p>Addressable LED strips come in 12V or 5V. For the 12V version, there are 3  LED modules in series for each segment. For 5V version, there is only one LED module per segment (This is because LED has forward voltage of 2.2-3.6V, 5V supply cannot drive more than one LED in series).</p>

<p>Connecting addressable LED strip is straight-forward:</p>
<ol>
<li>Connect the LED Strip's +12V/+5V and GND to an external power supply directly.</li>
<li>Connect DI and CI to any of the Arduino's digital pins.</li>
<li>Join the power supply's GND and Arduino's GND to establish a common ground (<strong>IMPORTANT!!!</strong>)</li>
</ol>

<p>You can simplify your programming using library codes. There are two popular libraries for programming addressable LED strip: NeoPixel and FastLED (work with 3-wire and 4-wire chipset) - to be discussed below.</p>

<h5>3-Lead 12V RGB Addressable LED Strip (WS2811) / 3-Lead 5V RGB Addressable LED Strip (WS2812)</h5>
<img class="image-center" src="images/WS2811LEDStrip.png" />
<img class="image-center" src="images/WS2812LEDStrip.png" />

<ul>
<li>WS2812 is an integrated package of a WS2811 LED driver IC chip and a 5050 RGB LED per segment (the 5050 is a  surface-mount 3-LED RGB module, in one 5mm x 5mm case). It can be driven by 5V supply. WS2812B is an upgraded version of WS2812.</li>
<li>12V RGB LED strips has three 5050 LED modules and a separate WS2811 LED driver IC chip (not integrated with 5050). You need 12V to drive three LEDs in series.</li>
<li>For WS2812 5V RGB LED strip, as there is only one LED per segment, with a forward voltage of 2.2-3.6V, it can be powered by a 5V supply. The maximum current drawn per segment is 60mA (3x20mA per RGB LED). For a 60-segment per meter LED strip, the maximum current is 60mA*60=3.6A. You need an external 5V power supply, instead of drawing the current from the Arduino Board.</li>
<li>For WS2811 12V RGB LED strip, the maximum current per segment is also 60mA. For a 20-segment per meter strip, it draws 1.2A per meter.</li>
<li>The WS2812/WS2811 LED strip has 3 wires: +5V|+12V, GND, and Data-In (DI), without the Clock-In (CI). The controller WS2811 generates the Clock-In internally. You need to send the serial coded data via DI at a specific timing (400kHz or 800 kHz).</li>
<li>Connecting the strip to Arduino is simple:
<ol>
<li>Connect +5V|+12V and GND to an external power supply.</li>
<li>Connect the power supply's GND to Arduino's GND.</li>
<li>Connect the DI to any Arduino's digital pin.</li>
</ol></li>
</ul>

<p>Programming WS2811 LED drivers requires the 24-bit RGB color code for each pixel to be cascaded down the DI line until it reaches is intended location, at a specific timing. But this has been greatly simplified by using library codes. There are two popular libraries for programming addressable LED strip: NeoPixel and FastLED (described below).</p>
<p> Read <a href="https://www.tweaking4all.com/hardware/arduino/arduino-ws2812-led/">https://www.tweaking4all.com/hardware/arduino/arduino-ws2812-led/</a>.</p>

<h5>4-Lead Addressable RGB LED Strip (LPD8806 Chipset)</h5>

<p>Read <a href="https://learn.adafruit.com/digital-led-strip">https://learn.adafruit.com/digital-led-strip</a>.</p>

<p>FastLED Wiki @ <a href="https://github.com/FastLED/FastLED/wiki/Overview">https://github.com/FastLED/FastLED/wiki/Overview</a>.</p>

<p>Adafruit's LPD8806 library @ <a href="https://github.com/adafruit/LPD8806">https://github.com/adafruit/LPD8806</a>.</p>

<p>[TODO] diagram + code</p>

<h5>Over Long Distance</h5>
<p>The Arduino digital pins are unable to drive the LED strip over a long distance (e.g., 5m). A solution is to cut out a segment of LED strip, place it near the Arduino digital pin and use it as a driver to drive the LED strip over a long distance. The WS2811 in the LED strip is capable of driving over 10m, according to the specification, but in practice, a few meters.</p>



<h4>NeoPixel</h4>



<p>You can download the ZIP file from <a href="https://github.com/adafruit/Adafruit_NeoPixel">https://github.com/adafruit/Adafruit_NeoPixel</a>. Unzip into Arduino's library folder. Restart Arduino IDE and check the examples at &quot;File&quot; &rArr; &quot;Examples&quot; &rArr; &quot;Adafruit NeoPixel&quot;. Run and study the examples: &quot;simple&quot; and &quot;striptest&quot;. The documentation is available @ <a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-use">https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-use</a>.</p>

<p>You need to customize these lines:</p>

<pre class="color-example">
#include &lt;Adafruit_NeoPixel.h&gt;
#define <strong>DATA_PIN</strong> <span class="color-new">6</span>       <span class="color-comment">// Data-In (DI) connects to this pin</span>
#define <strong>NUM_LEDS</strong> <span class="color-new">60</span>
Adafruit_NeoPixel <strong>strip</strong> = Adafruit_NeoPixel(<strong>NUM_LEDS</strong>, <strong>DATA_PIN</strong>, NEO_GRB + NEO_KHZ800);
</pre>

<p>In <code>setup()</code>:</p>
<pre class="color-example">
void setup() {
   strip.begin();  <span class="color-comment">// initialize strip's buffer to all zeros (off)</span>
   strip.show();   <span class="color-comment">// Update all LEDs</span><br />}</pre>

<p>You can then play with the color in <code>loop()</code>:</p>
<pre class="color-example">
<span class="color-comment">// Set the color of a particular LED via setPixelColor()</span>
uint32_t color = strip.Color(255, 0, 0);  <span class="color-comment">// Set R, G and B of a color</span>
strip.setPixelColor(8, color);            <span class="color-comment">// Set LED 8's color</span>
strip.show();                             <span class="color-comment">// Update ALL LEDs</span>
delay(1000);

<span class="color-comment">// You can retrieve the color of a LED via getPixelColor()</span>
strip.setPixelColor(9, strip.getPixelColor(8));
strip.show();                             <span class="color-comment">// Update ALL LEDs</span>
delay(1000);

<span class="color-comment">// To switch an LED off use the color BLACK (0,0,0)</span>
strip.setPixelColor(8, strip.Color(0,0,0));  <span class="color-comment">// Set LED color</span>
strip.show();                                <span class="color-comment">// Update all LEDs</span>
delay(1000);

<span class="color-comment">// Set all LEDs to green</span>
color = strip.Color(0, 255, 0);
for (int i = 0; i &lt; strip.numPixels(); ++i) {
   strip.setPixelColor(i, color);
}
strip.show();    <span class="color-comment">// Update all LEDs</span>
delay(1000);</pre>

<p>Run and study the other examples.</p>

<p>NeoPixel maintains a display buffer, which maps to all the LEDs in the strip. You need to call <code>strip.begin()</code> to set up the buffer. You can update the color in the buffer via <code>strip.setPixelColor(index, color)</code>, and invoke <code>strip.show()</code> to push all the buffer values to the strip. </p>
<p>Color is represented in a <code>uint32_t</code>, comprising red, green and blue components.</p>
<ul>
<li><code>strip.Color(R, G, B)</code>: translate the R, G and B into a color value in a <code>uint32_t</code>.</li>
<li><code>strip.setPixelColor(pixelIndex, color)</code>: set the color of a particular pixel.</li>
<li><code>strip.getPixelColor(pixelIndex)</code>: returns a 32-bit color value of a particular pixel.</li>
<li><code>strip.numPixels()</code>: returns the number of pixel declared during initialization.</li>
<li><code>strip.setBrightness(level)</code>: adjust the brightness of all the LEDs with <code>level</code> ranges from 0 (off) to 255 (max brightness). <code>setBrightness()</code> was intended to be called once, in <code>setup()</code>, to limit the current/brightness of the LEDs throughout the life of the sketch. It is not intended as an animation effect itself!</li>
</ul>

<p>NeoPixel seems to be easier in controlling multiple strips with varying number of LEDs, you can allocate different <code>Adafruit_NeoPixel</code> objects for different strips, and in an array control each of the strips independently.</p>

<p>[TODO] Check if NeoPixel works with 4-wire chipset (such as LPD8806) with Clock-In (CI)?</p>

<h5>SRAM Constraint</h5>
<p>Each LED pixel takes 3 bytes of SRAM.</p>
<p>Arduino UNO has 2KBytes of SRAM, and can drive 682 pixels even if all the SRAM is used for the LED buffer. In practice, it can drive about 300-400 pixels. Arduino Mega 2560 has 8KBytes of SRAM, and can drive 2730 pixels, but in practice, 1500+ pixels.</p>


<h4>FastLED 3.1</h4>

<p>FastLED is the successor of FastSPI_LED and FastSPI_LED2. You can download the ZIP file from <a href="https://github.com/FastLED/FastLED">https://github.com/FastLED/FastLED</a>. Unzip into the Arduino's library folder. Restart the Arduino IDE. You can find the examples under &quot;File&quot; &rArr; &quot;Examples&quot; &rArr; &quot;FastLED&quot;. Run and study examples such as &quot;testleds&quot; and &quot;blink&quot;.</p>

<p>FastLED supports 4-wire and 3-wire chipset, with or without Clock-In (CI). You need to customize these lines:</p>
<pre class="color-example">
#include &quot;FastLED.h&quot;
#define <strong>NUM_LEDS <span class="color-new">60</span></strong>    <span class="color-comment">// Number of LEDs in your LED strip</span>
#define <strong>DATA_PIN <span class="color-new">6</span></strong>     <span class="color-comment">// Data-In (DI) connecting to this pin</span>

<span class="color-comment">// For four-wire chipsets with a Clock-In (CI) only</span>
//#define <strong>CLOCK_PIN <span class="color-new">7</span></strong>    <span class="color-comment">// Clock-In (CI) connecting to this pin</span>
<span class="color-comment">
// Define an array of LEDs to keep the RGB values of each LED </span><br />CRGB leds[<strong>NUM_LEDS</strong>];</pre>

<p>In <code>setup()</code>:</p>
<pre class="color-example">
void setup() {
   <span class="color-comment">// For 3-wire chipsets without Clock-In (CI)</span>
   FastLED.addLeds&lt;NEOPIXEL, <strong>DATA_PIN</strong>&gt;(leds, <strong>NUM_LEDS</strong>);  <span class="color-comment">// or set to WS2812 or WS2811</span>
   ....
   <span class="color-comment">// For 4-wire chipsets with a Clock-In (CI)</span>
   //FastLED.addLeds&lt;LPD8806, <strong>DATA_PIN</strong>, <strong>CLOCK_PIN</strong>&gt;(leds, NUM_LEDS);
}</pre>

<p>You can then play with the color in <code>loop()</code>:</p>
<pre class="color-example">
<span class="color-comment">// To switch an LED Off, set the color to Black for that particular LED and call the show() function:</span>
leds[8] = CRGB::Black;  <span class="color-comment">// Array index begins at 0, up to NUM_LEDs - 1</span>
                        <span class="color-comment">// Set color to black via pre-defined constant CRGB::Black</span>
FastLED.show();         <span class="color-comment">// Show changes</span>

<span class="color-comment">// Set an LED to a specific color</span>
leds[8] = CRGB::Red;    <span class="color-comment">// Set LED 8 to red via pre-defined constant CRGB::Red</span>
FastLED.show();         <span class="color-comment">// Show changes</span>
delay(1000);

<span class="color-comment">// You can set each of the RGB components individually</span>
leds[18].r = 255;     <span class="color-comment">// Set red component, value between 0 and 255</span>
leds[18].g = 125;     <span class="color-comment">// Set green</span>
leds[18].b = 0;       <span class="color-comment">// Set blue</span>
FastLED.show();       <span class="color-comment">// Show changes, no change in leds[8]</span>
delay(1000);

<span class="color-comment">// Set all LEDs to pre-defined constant ForestGreen (0x228B22)</span>
for (i = 0; i &lt; NUM_LEDS; ++i) {
   leds[i] = CRGB::ForestGreen;
}
FastLED.show();       <span class="color-comment">// Show changes</span>
delay(1000);</pre>

<p>Run and study all the other examples.</p>



<h3>Motors</h3>

<h4>Motor Ex 1: DC Motor and Transistor (for driving larger load)</h4>

<p>Follow "CIRC03 Spin Motor Spin" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-03">http://www.oomlout.com/oom.php/products/ardx/circ-03</a>.</p>

<h5>Circuit Diagram</h5>

<img class="image-center" src="images/ArduinoEx3DCMotor.png" alt="DC motor" />

<h5>Dissecting the Circuit</h5>
<p>A transistor (P2N2222AG NPN BJT, rated at 40V and 200mA max) (<a href="https://www.sparkfun.com/products/12852">datasheet</a>) is used as an electronic switch in the above circuit. It is turned ON when pin 9 (connected to the <em>base</em> (b) of transistor) outputs a HIGH (5V), with base current I<sub>B</sub> = (5V-0.8V)/330Ω = 13mA; and voltage drop across <em>collector</em> (c) and <em>emitter</em> (e) of 0.2V. It is OFF when pin 9 is LOW (0V).</p>
<p>A transistor is needed here as the output from pin 9 (with maximum 
current of 40mA) is not sufficient to drive the DC motor directly. But 
only a small amount of current (2mA) is required to turn on the 
transistor.</p>

<p>A DC motor spins at a rate proportional to the applied voltage (once 
sufficient voltage is applied) at no load. The speed decreases when load
 is applied. The current is also proportional to the torque. (See <a href="http://www.micromo.com/dc-motor-tutorials">DC Motor Tutorials</a>.)</p>
<p>DC motors have various specifications. A toy DC motor has an 
operating voltage range of 1.5 to 4.5V and a no load speed of 23000 RPM 
(@4.5VDC, 70mA) (<a href="https://www.sparkfun.com/products/retired/9608">datasheet</a>); another has an operating voltage range of 1.0 to 3.0V and a no load speed of 6600 RPM (@1.0V DC, 110mA) (<a href="https://www.sparkfun.com/products/11696">datasheet</a>).
 Generally, it requires around 100mA and cannot be supplied via output 
pin (max of 40mA). The transistor has a rating of 200mA.</p>

<h5>Practice</h5>

<p>Connect the DC motor directly to 5V. Measure the no load current.</p>

<p>Set pin 9 to HIGH (to turn on the transistor):</p>
<ol>
<li>Using a digital multimeter, measure the voltage at pin 9, the voltage across the base and emitter V<sub>BE</sub>. Compute the base current I<sub>B</sub> (through the base resistor).</li>
<li>Measure the voltage across the collector and emitter V<sub>CE</sub>.</li>
<li>Measure the collector current I<sub>C</sub>.</li>
</ol>

<h4>Motor Ex 2: Servo Motor</h4>

<p>Follow "CIRC04 Servo" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-04">http://www.oomlout.com/oom.php/products/ardx/circ-04</a>.</p>

<h5>Dissecting the Circuit</h5>

<p>A servo motor (sample <a href="https://www.sparkfun.com/products/9347">datasheet</a>) is a rotary actuator that allows for precise control of angular position, velocity and acceleration.</p>

<h3>Sensors, Actuators and Other Devices</h3>

<h4>Shift Register</h4>

<p>Follow "CIRC05 Shift Register" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-05">http://www.oomlout.com/oom.php/products/ardx/circ-05</a>.</p>

<h4>Piezo Speaker</h4>

<p>Follow "CIRC06 Piezo speaker" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-06">http://www.oomlout.com/oom.php/products/ardx/circ-06</a>.</p>

<h4>Push Button</h4>

<p>Follow "CIRC07 Push Button" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-07">http://www.oomlout.com/oom.php/products/ardx/circ-07</a>.</p>

<h4>Potentialmeter</h4>

<p>Follow "CIRC08 Potentialmeter" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-08">http://www.oomlout.com/oom.php/products/ardx/circ-08</a>.</p>

<h5>Practice</h5>
<p>Use a multimeter, measure the resistance across the entire potentiometer. (Mine is 10 kΩ).</p>

<h4>Photo-Resistor</h4>

<p>Follow "CIRC09 Photo-Resistor" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-09">http://www.oomlout.com/oom.php/products/ardx/circ-09</a>.</p>

<h5>Practice</h5>
<p>Use a multimeter, measure the resistance of the photo-resistor at 
darkness (by covering the surface) and at full brightness (shine light 
on it). (Darkness: 60 kΩ; brightness: 3 kΩ).</p>

<h4>Temperature Sensor</h4>

<p>Follow "CIRC10 Precision Temperature Sensor" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-10">http://www.oomlout.com/oom.php/products/ardx/circ-10</a>.</p>

<h4>Relay (for large load)</h4>

<p>Follow "CIRC11 Larger Load Relay" @ <a href="http://www.oomlout.com/oom.php/products/ardx/circ-11">http://www.oomlout.com/oom.php/products/ardx/circ-11</a>.</p>

<h4>Real-Time Clock (RTC) Module</h4>

<p><strong>Reference</strong>:</p>
<ol>
<li>&quot;DS1307 Real Time Clock Breakout Board Kit&quot; @ <a href="https://learn.adafruit.com/ds1307-real-time-clock-breakout-board-kit/overview">https://learn.adafruit.com/ds1307-real-time-clock-breakout-board-kit/overview</a>.</li>
<li>&quot;RTCLib&quot; @ <a href="https://github.com/adafruit/RTClib">https://github.com/adafruit/RTClib</a>.</li>
<li>&quot;DS1307&quot; Data Sheet @ <a href="https://datasheets.maximintegrated.com/en/ds/DS1307.pdf">https://datasheets.maximintegrated.com/en/ds/DS1307.pdf</a>.</li>
</ol>

<p>Arduino has a built-in timer for time keeping, which you can read via function <code>millis()</code>, which returns the number of milliseconds (in <code>unsigned long</code>) since the current program is launched. However, it is reset to zero, when the power is turned off and on, or the program is reset.</p>
<p>For consistent timekeeping, we could use a Real-Time Clock (RTC) module (such as DS1307), that has a small lithium battery (3V CR1225 or CR1220) to keep the timer running (for up to 5 years) even if the Arduino is powered off. The RTC chip is a specialized chip that just keeps track of time. It can count leap-years and knows how many days are in a month, but it does not handle daylight savings Time.</p>

<img class="image-center" src="images/RTC-DS1307&#32;Module.png" />

<p>RTC DS1307 can be connected to Arduino easily. There are five wires:</p>

<ol>
<li>5V (Primary Power Supply): Used to power the RTC chip for querying time. When the 5V is absent, the battery is still powering its internal timer. Connect to Arduino's 5V pin.</li>
<li>GND (Ground): Connect to Arduino's GND pin.</li>
<li>SCL (Serial Clock Input): Connect to Arduino UNO's A4; or Arduino Mega's digital 21.</li>
<li>SDA (Serial Data Input/Output): Connect to Arduino UNO's A5; or Arduino Mega's digital 20.</li>
<li>SQW (Square Wave): Optional square wave output. Most people don't use it.</li>
</ol>

<p>The RTC is an i2c device, which uses 2 wires to communicate with Arduino UNO (SCL to A4, SDA to A5), for setting the time and retrieving it. It takes up 2 of the 6 analog inputs pins.</p>

<h5>RTClib Arduino Library</h5>

<p>Download the &quot;RTCLib&quot; from <a href="https://github.com/adafruit/RTClib">https://github.com/adafruit/RTClib</a>, and unzip into Arduino IDE's library folder. Read the tutorial @ <a href="https://learn.adafruit.com/ds1307-real-time-clock-breakout-board-kit/overview">https://learn.adafruit.com/ds1307-real-time-clock-breakout-board-kit/overview</a>.</p>


<h5>Example</h5>
<p>Run and study  example &quot;<code>ds1307</code>&quot;, touched up as below:</p>

<pre class="color-example">
#include &lt;Wire.h&gt;     <span class="color-comment">// Built-in library for i2c communication</span>
#include &quot;RTClib.h&quot;   <span class="color-comment">// RCTLib</span>

RTC_DS1307 rtc;    <span class="color-comment">// Declare an instance</span>

void setup () {
   Serial.begin(57600);  <span class="color-comment">// Enable serial for debugging</span>
   if (!rtc.begin()) {
      Serial.println("Couldn't find RTC");
      while(1);
   }

   if (!rtc.isrunning()) {
      Serial.println("RTC is NOT running!");
      <span class="color-comment">// Sets the RTC to the datetime this sketch was compiled using the computer time</span>
      rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
      <span class="color-comment">// Or, sets the RTC with an explicit year, month, day, hour, minute, second</span>
      //rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
   }
}

void loop () {
   <span class="color-comment">// Read datetime</span>
   DateTime now = rtc.now();
   
   <span class="color-comment">// Print time</span>
   Serial.print(now.year(), DEC);
   Serial.print('/');
   Serial.print(now.month(), DEC);
   Serial.print('/');
   Serial.print(now.day(), DEC);
   Serial.print(" ");
   Serial.print(now.hour(), DEC);
   Serial.print(':');
   Serial.print(now.minute(), DEC);
   Serial.print(':');
   Serial.print(now.second(), DEC);
   Serial.println();
    
   delay(2000);
}</pre>

<ul>
<li><code>rtc.begin()</code>: to establish communication. Return false if RTC is not found.</li>
<li><code>rtc.isrunning()</code>: Return false if RTC is not running.</li>
<li><code>rtc.adjust(DateTime(__DATE__, __TIME__))</code>: Set the RTC's time to your computer's time when the sketch was compiled. This is needed if you took out the RTC's battery, or re-synchronize the time. This is NOT needed if you power down the Arduino Board, as RTC's battery is still powering the RTC's timer.</li>
<li><code>DateTime now = rtc.now()</code>: Return the RTC's time in a <code>DateTime</code> object.</li>
<li><code>now.year()</code>, <code>now.month()</code>, <code>now.day()</code>, <code>now.hour()</code>, <code>now.minute()</code>, <code>now.second()</code>, <code>now.dayOfTheWeek()</code>: Get the <code>DateTime</code> object's components.</li>
</ul>
    
<h4>Ultrasonic Ranging Sensor HC-SR04</h4>

<p><strong>Reference</strong>:</p>
<ol>
<li>&quot;Ultrasonic Sensor HC-SR04 and Arduino Tutorial&quot; @ <a href="http://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/">http://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/</a>.</li>
<li>Arduino-HC-SR04-library @ <a href="https://github.com/bbkbarbar/Arduino-HC-SR04-library">https://github.com/bbkbarbar/Arduino-HC-SR04-library</a>.</li>
<li>&quot;HC-SR04&quot; datasheet @ <a href="http://www.micropik.com/PDF/HCSR04.pdf">http://www.micropik.com/PDF/HCSR04.pdf</a>.</li>
</ol>

<img class="image-center" src="images/HC-SRO4.png" />

<p>&quot;A proximity sensor is a sensor able to detect the presence of nearby objects without any physical contact. A proximity sensor often emits an electromagnetic field or a beam of electromagnetic radiation (infrared, for instance), and looks for changes in the field or return signal.&quot;</p>
<p>HC-SR04 ultrasonic distance measurement sensor is a low-cost sensor that supports non-contact distance measurement from 2cm to 400cm (4m) with a ranging accuracy of up to 3mm. Take note the there is a minimum range of 2cm (i.e., you cannot cover the sensor, which blocks the Ultrasonic wave path). The measuring angle is 15 degrees.</p>
<p>Each HC-SR04 module has an ultrasonic transmitter, a receiver and a control circuit. It emits an ultrasound at 40KHz, which travels through the air and bounces back if   there is an object or obstacle on its path. You can   calculate the distance from the travel time and the speed of the sound (340 m/s = 0.034 cm/&micro;s), as follows:</p>
<pre class="color-command">speed = distance / time 
distance (cm) = 0.034 (cm/&micro;s) * time (&micro;s)  / 2 = 0.017 * timeIn&micro;s
</pre>


<p>HC-SR04 module  has  four pins: VCC (Power), TRIG (Trigger), ECHO (Receive), and GND (Ground). Connect the VCC and GND pins to Arduino's 5V and GND. Connect TRIG and ECHO to any Arduino's digital I/O pins.</p>
<p>In order to generate the ultrasound signal you need to set the TRIG HIGH for 10 µs. This will trigger an 8-cycle sonic burst which   will travel at the sound speed (340 m/s) and bounce back to the ECHO pin.   The ECHO pin will maintain HIGH for the duration (in microseconds) that sound wave   traveled.</p>

<h5>Example of Raw Source Code</h5>
<pre class="color-example">
<span class="color-comment">/*
 * Using HC-SR04 Ultrasonic Ranging Sensor
 * Measurement Range is 2cm to 400cm (4m), 15 degree angle.
 */</span>
#define RANGING_TRIG_PIN 4    <span class="color-comment">// TRIG pin to any Arduino's digital pin</span>
#define RANGING_ECHO_PIN 3    <span class="color-comment">// ECHO pin to any Arduino's digital pin</span>

unsigned long distanceInCm;   <span class="color-comment">// in cm</span>

void setup() {
   Serial.begin(57600);

   <span class="color-comment">// Set up Ultrasonic Ranging Sensor</span>
   pinMode(RANGING_TRIG_PIN, OUTPUT);
   pinMode(RANGING_ECHO_PIN, INPUT);
}

void loop() {
   <span class="color-comment">// Get distance from ranging sensor</span>
   distanceInCm = getDistanceInCm();
   <span class="color-comment">// Print for debugging</span>
   Serial.print(distanceInCm);
   Serial.println(&quot;cm&quot;);
   delay(1000);

   distanceInCm = getAverageDistanceInCm();
   <span class="color-comment">// Print for debugging</span>
   Serial.print(distanceInCm);
   Serial.println(&quot;cm&quot;);
   delay(1000);

   distanceInCm = getAccurateDistanceInCm();
   <span class="color-comment">// Print for debugging</span>
   Serial.print(distanceInCm);
   Serial.println(&quot;cm&quot;);
   delay(1000);
}

<span class="color-comment">/*
 * Get distance in cm via the ranging sensor HC-SR04
 */
</span>unsigned long getDistanceInCm() {
   <span class="color-comment">// Clear trigger signal for 2 usec</span>
   digitalWrite(RANGING_TRIG_PIN, LOW);
   delayMicroseconds(2);
   <span class="color-comment">// Set Trigger pin HIGH for 10 usec</span>
   digitalWrite(RANGING_TRIG_PIN, HIGH);
   delayMicroseconds(10);
   digitalWrite(RANGING_TRIG_PIN, LOW);
   <span class="color-comment">// Read Echo pin HIGH duration in usec, convert to cm
   // The speed of sound is 340 m/s = 0.034 cm/us
   // The ping travels out and back, need to divide by 2.</span>
   return pulseIn(RANGING_ECHO_PIN, HIGH) * 0.017;
}

<span class="color-comment">/*
 * Read distance in cm using the ranging sensor HC-SR04
 * Return the average of 3 readings
 */</span>
unsigned long getAverageDistanceInCm() {
   <span class="color-comment">// Get the average of 3 readings</span>
   unsigned long distances[3];
   for (uint8_t i = 0; i &lt; 3; ++i) {
      distances[i] = getDistanceInCm();
   }
   return (distances[0] + distances[1] + distances[2]) / 3;
}

<span class="color-comment">/*
 * Read distance in cm using the ranging sensor HC-SR04
 * Take 5 readings, discard max and min and return the average of remaining three
 */</span>
unsigned long getAccurateDistanceInCm() {
   unsigned long distances[5];
   for (uint8_t i = 0; i &lt; 5; ++i) {
      distances[i] = getDistanceInCm();
   }
   unsigned long max = distances[0];
   unsigned long min = distances[0];
   for (int i = 1; i &lt; 5; ++i) {
      if (distances[i] &gt; max) max = distances[i];
      if (distances[i] &lt; min) min = distances[i];
   }
   return (distances[0] + distances[1] + distances[2] + distances[3] + distances[4] - max - min) / 3;
}
</pre>

<p>Take note that the minimum range is 2cm (you cannot cover the sensor, which blocks the wave path). Hence, readings of 0cm is invalid!</p>

<h5>Debugging Tips</h5>
<p>Use a multimeter to measure the voltage across the HC-SR04 V<sub>CC</sub> and GND. It ought to be 5V. Otherwise, some other components (such as LED strips) might have pull down the voltage.</p>

<h5>Arduino Library</h5>
<p>You can simplify your programming using an library. There are a few HC-SR04 library available:</p>
<ul>
<li>Arduino-HC-SR04-library @ <a href="https://github.com/bbkbarbar/Arduino-HC-SR04-library">https://github.com/bbkbarbar/Arduino-HC-SR04-library</a>.</li>
</ul>

<h5>Example of Using Arduino-HC-SR04-Library</h5>

<pre class="color-example">
#include "hcsr04.h"   <span class="color-comment">// Using &quot;Arduino-HC-SR04-library&quot;</span>
#define <strong>RANGING_TRIG_PIN</strong>  4   <span class="color-comment">// TRIG pin to any Arduino's digital pin</span>
#define <strong>RANGING_ECHO_PIN</strong>  3   <span class="color-comment">// ECHO pin to any Arduino's digital pin</span>

HCSR04 sensor;        <span class="color-comment">// Declare an instance of HC-SR04 sensor</span>
unsigned short distance;  <span class="color-comment">// measured distance</span>

void setup() {
   sensor.init(<strong>RANGING_TRIG_PIN</strong>, <strong>RANGING_ECHO_PIN</strong>);  <span class="color-comment">// init</span>
}

void loop(){
   Serial.begin(57600);  <span class="color-comment">// Use serial port for display</span>

   <span class="color-comment">// One measurement</span>
   distance = sensor.readDistanceInMm();
   Serial.print("distance (instantaneous): ");
   Serial.print(distance);
   Serial.println("mm");

   <span class="color-comment">// Average of n measurements</span>
   distance = sensor.readAvgDistanceInMm(2);
   Serial.print("distance (average of two): ");
   Serial.print(distance);
   Serial.println("mm");

   <span class="color-comment">// 5 measurements, but discard the max and min</span>
   distance = sensor.readAccurateDistanceInMm();
   Serial.print("distance (accurate): ");
   Serial.print(distance);
   Serial.println("mm");
  
   delay(1000);
}</pre>

<h4>Bluetooth Shields</h4>
<p>Reference:</p>
<ol>
<li>Using the BlueSMiRF @ <a href="https://learn.sparkfun.com/tutorials/using-the-bluesmirf">https://learn.sparkfun.com/tutorials/using-the-bluesmirf</a>.</li>
<li>Bluetooth Serial Terminal @ <a href="https://www.microsoft.com/en-us/store/p/bluetooth-serial-terminal/9wzdncrdfst8">https://www.microsoft.com/en-us/store/p/bluetooth-serial-terminal/9wzdncrdfst8</a>.</li>
<li>Arduino and HC-05 Bluetooth Module Tutorial @ <a href="https://howtomechatronics.com/tutorials/arduino/arduino-and-hc-05-bluetooth-module-tutorial/">https://howtomechatronics.com/tutorials/arduino/arduino-and-hc-05-bluetooth-module-tutorial/</a>.</li>
<li>Arduino Bluetooth Basic Tutorial @ <a href="https://create.arduino.cc/projecthub/user206876468/arduino-bluetooth-basic-tutorial-d8b737">https://create.arduino.cc/projecthub/user206876468/arduino-bluetooth-basic-tutorial-d8b737</a>.</li>
</ol>

<p>&nbsp;</p>
<p>There are many Bluetooth Shields available for Arduino. I have tried the followings:</p>

<h5>HC-05 6-Pin Bluetooth RF Receiver Transceiver Module</h5>

<img class="image-center" src="images/HC-05&#32;Bluetooth.png" />
<p>The HC-05 is a class 2 Bluetooth module (10m range). It is pre-configured as a slave Bluetooth device with Baud rate of 38400 (older version at 9600), 8 data bits, No Parity, 1 stop bit (8N1). Once it is paired to a master Bluetooth device such as PC, smart phones and tablet, its operation becomes transparent to the user.</p>
<p>HC-05 can be powered by 3.6V to 6V. Hence, it can be powered by Arduino's 5V supply. However, the level of RX/TX is 3.3V, which is not compatible with Arduino's digital output of 5V. For RX input, you need to use a voltage divider (formed by a 10K&Omega; and a 20K&Omega; resistors) to bring 5V down to 3.3V. But the TX output of 3.3V can drive Arduino's digital input pin directly.</p>

<h5>RN-41/RN-42 Sparkfun BlueSMiRF Gold/Silver Bluetooth Module</h5>

<img class="image-center" src="images/Bluetooth&#32;RN-41.png" />
<p>RN-41 is a class 1 device with range of 100m; while RN-42 is a class 2 device with range of 10m. They can be powered by 3.3V to 6V, and designed to work with 3.3V and 5V systems. Hence, they can be connected directly to Arduino (without Voltage Level Shifter). The baud rate is 2400 to 115200bps. The default baud rate is 115200, 8 data bits, no parity, 1 stop bit (8N1).</p>

<h5>Data Mode vs. Command Mode</h5>
<p>Bluetooth module operates in two modes:</p>
<ol>
<li>Command Mode: used to configure the Bluetooth module, such as device name, baud rate, Pin Code, etc. The HC-05 Bluetooth Module has a switch to enter the command mode.</li>
<li>Data Mode: for data transfer between the Bluetooth module and the Arduino controller. The Bluetooth module acts as a transparent data gateway. Any data received over Bluetooth connection is routed to the TX pin. Any data sent to RX pin is piped out over Bluetooth.</li>
</ol>

<h5>Connection</h5>

<img class="image-center" src="images/Bluetooth_Arduino.png" />
<p>Instead of connecting the Bluetooth to the Arduino's sore hardware Serial (Pins 0 and 1), we shall use <code>SoftwareSerial</code> and connect the bluetooth's RX and TX pins to any of the Arduino’s free digital pins. This will help to avoid bus contention and will make sure the Bluetooth doesn't receive any spurious data during a sketch upload. In our test program, we choose pin 2 for <code>SoftwareSerial</code>'s RX and pin 3 for TX.</p>

<ol>
<li>Connect Bluetooth's RX to Arduino's TX.
  <ul>
<li>For HC-05, the bluetooth's RX is operating at 3.3V, you need a voltage divider (voltage level shifter). You can use a 1K&Omega; and a 2K&Omega; resistors to form a voltage divider to bring 5V down to 3.3V.</li>
<li>For RN-41, no voltage level shifter is need as it can operate on 3.3V and 5V.</li>
</ul></li>
<li>Connect the Bluetooth's TX to Arduino's RX. No voltage divider is needed, as 3.3V is able to drive Arduino's 5V digital pin.</li>
<li>Connect the Bluetooth's Vcc/GND to Arduino's 5V/GND (provided the bluetooth can be powered by 5V, otherwise, use Arduino's 3.3V output supply).</li>
<li>Ignore the other pins.</li>
</ol>

<p>Take note that you need to connect the Bluetooth's RX to Arduino's TX, and vice versa.</p>

<h5>Arduino Test Program</h5>

<p>The following program turns on/off Pin-13's built-in LED via command sent through a Bluetooth module. Send <code>'0'</code> to turn off and <code>'1'</code> to turn on.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Turn on/off LED via command sent through a Bluetooth module
 * Send '0' to turn off and '1' to turn on
 */
// The default Serial uses pins 0 and 1
// Use SoftwareSerial to switch the TX/RX pins and leave pins 0 and 1 for debugging
// Use built-in SoftwareSerial header @ https://www.arduino.cc/en/Reference/SoftwareSerial</span>
#include &lt;SoftwareSerial.h&gt;

<span class="color-comment">// Connect the Bluetooth's RX to Arduino's TX, Bluetooth's TX to Arduino's RX</span>
#define BT_RX_PIN 2    <span class="color-comment">// Connect to Bluetooth's TX pin</span>
#define BT_TX_PIN 3    <span class="color-comment">// Connect to Bluetooth's RX pin</span>
<span class="color-comment">// Setup SoftwareSerial (RX, TX)</span>
SoftwareSerial bluetooth(BT_RX_PIN, BT_TX_PIN);

#define LED_PIN 13     <span class="color-comment">// Use Pin 13's built-in LED</span>
byte ledState = LOW;   <span class="color-comment">// HIGH or LOW</span>
char btCommandChar;    <span class="color-comment">// Bluetooth command character</span>

void setup() {
   <span class="color-comment">// Set up bluetooth (choose your device)</span>
   bluetooth.begin(115200);  <span class="color-comment"> // default baud rate for RN-41/RN-42</span>
   //bluetooth.begin(38400);  <span class="color-comment">// default baud rate for HC-05 (older version at 9600)</span>
<span class="color-comment"></span>
   <span class="color-comment">// Set up LED and Test LED by blinking thrice</span>
   pinMode(LED_PIN, OUTPUT);
   for (int i = 0; i &lt; 3; ++i) {
      ledState = LOW;
      digitalWrite(LED_PIN, ledState);
      delay(1000);
      ledState = HIGH;
      digitalWrite(LED_PIN, ledState);
      delay(1000);
   }

   <span class="color-comment">// Start the serial communications for debugging</span>
   Serial.begin(9600);
   Serial.println(&quot;LED ON and READY&quot;);
}

void loop() {
   <span class="color-comment">// Read bluetooth command, if available</span>
   if (bluetooth.available()) {   <span class="color-comment">// Check if the bluetooth sends any characters</span>
      btCommandChar = (char)bluetooth.read();

      if (btCommandChar == '0') {  <span class="color-comment">// Turn off LED</span>
         if (ledState == HIGH) {
            ledState = LOW;
            digitalWrite(LED_PIN, ledState);
            Serial.println(&quot;LED OFF&quot;);  <span class="color-comment">// Debugging</span>
         }
      } else if (btCommandChar == '1') {  <span class="color-comment">// Turn on LED</span>
         if (ledState == LOW) {
            ledState = HIGH;
            digitalWrite(LED_PIN, ledState);
            Serial.println(&quot;LED ON&quot;);  <span class="color-comment">// Debugging</span>
         }
      } else {
         Serial.print(&quot;error: unknown command &quot;);  <span class="color-comment">// Debugging</span>
         Serial.println(btCommandChar);
      }
   }
   delay(1000);
}</pre>

<h5>Testing on PC using &quot;Bluetooth Serial Terminal&quot;</h5>

<p>There are many free Bluetooth Terminal available. I used the Bluetooth Serial Terminal (@ <a href="https://www.microsoft.com/en-us/store/p/bluetooth-serial-terminal/9wzdncrdfst8">https://www.microsoft.com/en-us/store/p/bluetooth-serial-terminal/9wzdncrdfst8</a>) which has PC and Mobile version to test  the bluetooth module.</p>

<ol>
<li>Enable Bluetooth on PC: (Windows 10) Bluetooth &amp; Other Devices &rArr; Bluetooth ON.</li>

<li>Pair the bluetooth device: (Windows 10) Bluetooth &amp; Other Devices &rArr; &quot;Firefly 9AC4&quot; (for RN-41), HC-05 (for HC-05) &rArr; Connect &rArr; Enter password (default &quot;1234&quot; or &quot;0000&quot;).</li>

<li>Upload the Sketch.</li>

<li>Start &quot;Bluetooth Serial Terminal&quot; (or any Bluetooth Terminal): Connect.</li>
<li> In &quot;Transmit&quot;, enter &quot;0&quot; and &quot;Send&quot;. Observe the the LED is turned off.</li>
<li> In &quot;Transmit&quot;, enter &quot;1&quot; and &quot;Send&quot;. Observe the the LED is turned on.</li>
</ol>

<h5>Working with Android</h5>
<p>[TODO]</p>


<h5>RN-41 Bluetooth Module's Command Mode</h5>
<p>You can use the following sketch to test the &quot;command mode&quot; of RN-41 Bluetooth module, via passing thru all data between &quot;Arduino Serial Monitor&quot; and &quot;Bluetooth Module&quot;.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Test Bluetooth module via passing thru all data between &quot;Arduino Serial Monitor&quot;
 * and &quot;Bluetooth Module&quot;.
 */
// The default Serial uses pins 0 and 1
// Use SoftwareSerial to switch the TX/RX pins and leave pins 0 and 1 for debugging
// Use built-in SoftwareSerial header @ https://www.arduino.cc/en/Reference/SoftwareSerial</span>
#include &lt;SoftwareSerial.h&gt;

<span class="color-comment">// Connect the Bluetooth's RX to Arduino's TX, Bluetooth's TX to Arduino's RX</span>
#define BT_RX_PIN 2    <span class="color-comment">// Connect to Bluetooth's TX pin</span>
#define BT_TX_PIN 3    <span class="color-comment">// Connect to Bluetooth's RX pin</span>
<span class="color-comment">// Setup SoftwareSerial (RX, TX)</span>
SoftwareSerial bluetooth(BT_RX_PIN, BT_TX_PIN);

void setup() {
   bluetooth.begin(115200);  <span class="color-comment">// default for RN-41/42</span>

<span class="color-comment">   // == For RN-41/42 only ==
   // Change the baud rate thru the command mode
   // 115200 can be too fast at times for SoftwareSerial to relay the data reliably</span>
   bluetooth.print(&quot;$&quot;);  <span class="color-comment">// Send &quot;$$$&quot; to enter command mode</span>
   bluetooth.print(&quot;$&quot;);
   bluetooth.print(&quot;$&quot;);
   delay(100);  <span class="color-comment">// Short delay, wait for the Bluetooth to send back &quot;CMD&quot;</span>
   bluetooth.println(&quot;U,9600,N&quot;);  // Temporarily Change the baud rate to 9600, no parity
   bluetooth.begin(9600);          // Start bluetooth serial at 9600

   <span class="color-comment">// Start the serial communications for debugging</span>
   Serial.begin(9600);
   Serial.println(&quot;READY&quot;);
}

void loop() {
   <span class="color-comment">// Pass all data from Arduino Serial Monitor to Bluetooth</span>
   if (Serial.available()) {
      bluetooth.print((char)Serial.read());
   }
   <span class="color-comment">// Pass all data from Bluetooth to Arduino Serial Monitor</span>
   if (bluetooth.available()) {
      Serial.print((char)bluetooth.read());  
   }
}</pre>

<ol>
<li>Upload the sketch.</li>
<li>Open Arduino's &quot;Serial Monitor&quot;. Set Baud rate to 9600. Choose &quot;No Line Ending&quot;.</li>
<li>Enter &quot;$$$&quot; &rArr; Send. You shall receive &quot;CMD&quot;</li>
<li>Choose &quot;Newline&quot; for the Serial Monitor.</li>
<li>Enter &quot;D&quot;  &rArr; Send. You shall receive the &quot;Settings&quot; (such as BTName, Baud rate, Mode, Pin Code, etc.).</li>
<li>Enter &quot;E&quot;   &rArr; Send. You shall receive the &quot;Advanced Settings&quot;.</li>
</ol>

<h5>HC-05 Bluetooth Module's Command Mode</h5>
<p>To enter HC-05 command mode, you need to pull pin 34 to HIGH (at 3.3V). You can connect HC-05's pin 34 to Arduino's pin 9 (via a voltage divider) and set it to HIGH to enter the command mode. You can also PUSH the button while sending the AT command (the button is internally connected to pin 34).</p>

<p>In the command mode, HC-05 can process AT commands. For examples,</p>

<ul>
<li><code>AT</code> &rArr; <code>OK</code></li>
<li><code>AT+VERSION</code> &rArr; Display version</li>
<li><code>AT+NAME=MYBTNAME</code> &rArr; Set device name</li>
<li><code>AT+PSWD</code> &rArr; Display password</li>
<li><code>AT+UART</code> &rArr; Display UART settings</li>
<li><code>AT+UART=115200,1,0</code> &rArr; Set UART baudrate = 115200, 1 stop bit, no parity</li>
</ul>

<p>Again, we shall use the following pass thru program to test the command mode:</p>
<pre class="color-example">
<span class="color-comment">/*
 * Test Bluetooth module via passing thru all data between &quot;Arduino Serial Monitor&quot;
 * and &quot;Bluetooth Module&quot;.
 */
// The default Serial uses pins 0 and 1
// Use SoftwareSerial to switch the TX/RX pins and leave pins 0 and 1 for debugging
// Use built-in SoftwareSerial header @ https://www.arduino.cc/en/Reference/SoftwareSerial</span>
#include &lt;SoftwareSerial.h&gt;

<span class="color-comment">// Connect the Bluetooth's RX to Arduino's TX, Bluetooth's TX to Arduino's RX</span>
#define BT_RX_PIN 2    <span class="color-comment">// Connect to Bluetooth's TX pin</span>
#define BT_TX_PIN 3    <span class="color-comment">// Connect to Bluetooth's RX pin</span>
<span class="color-comment">// Setup SoftwareSerial (RX, TX)</span>
SoftwareSerial bluetooth(BT_RX_PIN, BT_TX_PIN);

void setup() {
   bluetooth.begin(38400);  <span class="color-comment">// default for HC-05</span>

   <span class="color-comment">// Start the serial communications for debugging</span>
   Serial.begin(9600);
   Serial.println(&quot;READY&quot;);
}

void loop() {
   <span class="color-comment">// Pass all data from Arduino Serial Monitor to Bluetooth</span>
   if (Serial.available()) {
      bluetooth.print((char)Serial.read());
   }
   <span class="color-comment">// Pass all data from Bluetooth to Arduino Serial Monitor</span>
   if (bluetooth.available()) {
      Serial.print((char)bluetooth.read());  
   }
}</pre>

<ol>
<li>Upload the sketch.</li>
<li>Open Arduino's &quot;Serial Monitor&quot;. Set Baudrate to 9600. Choose &quot;Both NL and CR&quot;.</li>
<li>Enter &quot;AT&quot;, Push the button and &quot;Send&quot;   &rArr; OK</li>
<li>Enter &quot;AT+VERSION&quot;, Push the button and &quot;Send&quot;   &rArr; VERSION:2.0-20161226   &rArr; OK<br />
</li>
<li>Enter &quot;AT+UART&quot;, Push the button and &quot;Send&quot;   &rArr; +UART:38400,0,0   &rArr; OK<br />
</li>
</ol>


<h4>Wifi Shield</h4>
<p>[TODO]</p>

<h4>MP3 Shield</h4>
<p>[TODO]</p>


<h3>Arduino Mega 2560</h3>

<p>Arduino UNO has its limitations (e.g., it can drive about 300-400 LED pixels due to its 2KB of SRAM; it has limited number of I/O pins). Many of your project may require a more powerful Arduino Mega 2560 (which obsoleted the Arduino Mega).</p>

<img class="image-center" src="images/ArduinoMega2560.png"  />

<p>Arduino Mega 2560 has:</p>
<ul>
<li>54 digital I/O pins, of which 15 can be used as PWM outputs (pins 2-13, 44-46). Each pin could provide 20mA current. (Compared with Arduino UNO: 14 digital pins, 6 PWMs.) <br />
  Use function <code>pinMode(0-53, INPUT|OUTPUT)</code> to configure the pin for input or output; and <code>digitalRead(0-53)</code> or <code>digitalWrite(0-53, HIGH|LOW)</code> to read or write.<br />
  For PWM pins, you can use function <code>analogWrite(2-13|44-46, <em>dutyCycle</em>)</code> with duty cycle of between 0 (off) to 255 (on) to output PWM signal.</li>
<li>16 analog input pins. (Compared with Arduino UNO: 6)<br />
  Use function <code>pinMode(A0-A13, INPUT)</code> (optional but nice to have) and <code>analogRead(A0-A13)</code> to read the 10-bit analog input <code>[0,1023]</code>.<br />
  These analog input pins can also be used for digital input/output like the digital I/O pins, with pin number for A0-A13.
</li>
<li>4 Serial ports (USART) (Compared with Arduino UNO: 1).</li>
<li>ATmega2560 micro-controller @ 16MHz, with 256KB of Flash memory for program, 8KB of SRAM for data, and 4KB of EEPROM for non-volatile data.</li>
</ul>

<h5>Arduino IDE</h5>
<p>Arduino IDE is applicable to Arduino Mega.</p>

<p>From &quot;Tools&quot; &rArr; &quot;Board&quot; &rArr; Select &quot;Arduino/Genuino Mega or Mega 2560&quot;.</p>
<p>Open &quot;File&quot; &rArr; &quot;Examples&quot; &rArr; &quot;01.basics&quot; &rArr; &quot;Blink&quot;, and run. Observe the orange LED attached to digital pin 13.</p>

<h3>More on Arduino</h3>

<h4>Microcontroller</h4>

<p>Arduino UNO uses ATmega328P microcontroller, with these features:</p>
<ul>
<li>Low-power CMOS 8-bit microcontroller based on the AVR enhanced RISC architecture.</li>
<li>Advanced RISC Architecture:
<ul>
<li>131 instructions, most single-clock-cycle execution.</li>
<li>32x8 general purpose registers.</li>
<li>Up to 20 MIPS throughput at 20MHz.</li>
</ul></li>

<li>Memory
<ul>
<li>32 KBytes Flash for program with 10,000 write/erase cycles.</li>
<li>1 KBytes EEPROM with 100,000 write/erase cycles.</li>
<li>2 KBytes SRAM</li>
</ul></li>

<li>Peripheral:
<ul>
<li>Six PWM channels</li>
<li>6-channel 10-bit ADC</li>
<li>One programmable Serial USART</li>
<li>Two Master/Slave SPI Serial Interface</li>
<li>One Byte-oriented 2-wire Series Interface (I<sup>2</sup>C compatible)</li>
<li>Two 8-bit Timer/Counter with separate prescaler and compare mode</li>
<li>One 16-bit Timer/Counter with separate prescalar, compare mode and capture mode</li>
<li>Interrupt and wake-up on pin change</li></ul>
</li>

<li>Operating Voltage: 1.8V to 5.5V</li>
<li>Power Consumption  Active Mode @ 1MHz, 1.8V, 25&deg;C: 0.2mA</li>

</ul>


<p>Arduino Mega2560 uses ATmega2560 microcontroller.</p>
<ul>
<li>8-bit microcontroller.</li>
<li>[TODO]</li>
</ul>

<h4>Memory</h4>
<h5>Types of Memory</h5>
<p>There are three pools of memory in Arduino board:</p>
<ol>
<li>Flash Memory: for storing the program (i.e., program space)</li>
<li>SRAM (Static RAM): for storing program data and variables.</li>
<li>EEPROM (Electrical Erasable Programmable Read-Only Memory): for storing long-term data.</li>
</ol>

<p>Flash and EEPROM are non-volatile, i.e., the data stored persists even if the power is turned off. SRAM is volatile, i.e., the data stored is lost when the power is turned off.</p>
<p>Arduino UNO (ATmega328) has: 32KB of Flash (about 0.5KB is used for the bootloader), 2KB of SRAM and 1KB of EEPROM.</p>
<p>Arduino Mega2560 (ATmega2560) has: 256KB of Flash (about 8K is used for the bootloader), 8KB of SRAM and 4KB of EEPROM.</p>
<p> Take note that SRAM is very limited in Arduino UNO. For example, each LED in a LED strip requires 3 bytes of SRAM, 2KB of SRAM is only capable of support 682 LEDs, even if all the SRAM are used. If you run out of SRAM, your program appears to be loaded successfully, but not run or run strangely. To conserve SRAM:</p>

<ul>
<li>Use smaller data type, e.g., an <code>int</code> takes two bytes, but a <code>byte</code> or <code>uint8_t</code> takes only one byte.</li>
<li>If you don't need to modify the data, store them in flash.</li>
</ul>

<h5>Programming EEPROM</h5>

<ul>
<li><code>EEPROM.length()</code>: return total number of bytes of EEPROM.</li>
<li><code>EEPROM.write(<em>address</em>, <em>value</em>)</code>: write a byte with <code><em>value</em></code> of 0 to 255 to the EEPROM at  <em><code>address</code></em><code></code>. For example, to initialize and clear the EEPROM:
  <pre class="color-example">
for (int i = 0 ; i &lt; EEPROM.length() ; i++) {
   EEPROM.write(i, 0);  <span class="color-comment">// write 0 to all the addresses</span>
}</pre>
An EEPROM write takes 3.3ms to complete. The EEPROM memory has a specified life of 100,000 write/erase cycles, so you may need to be careful about how often you write to it. 
</li>
<li><code>EEPROM.read(<em>address</em>)</code>: read the value (in <code>byte</code>) from the EEPROM <code><em>address</em></code>.</li>
<li><code>EEPROM.put(<em>address</em>, <em>data</em>)</code>: write any data type or object (<code>struct</code>) to the EEPROM starting from <code><em>address</em></code>. The <code><em>data</em></code> could be multi-byte, you can use <code>sizeof(<em>type</em>)</code> to check the size of data type in bytes.</li>
<li><code>EEPROM.update(<em>address</em>, <em>data</em>)</code>: Similar to <code>EEPROM.put()</code>, but does not rewrite the value if it didn't change (Recall that EEPROM has a certain write/erase life).</li>
<li><code>EEPROM.get(<em>address</em>, <em>data</em>)</code>: read any data type or object from EEPROM starting from <code><em>address</em></code> into <code><em>data</em></code>.</li>
</ul>

<h4>Delay and Timer</h4>

<p>[TODO]</p>

<h4>Serial Communication</h4>

<p>All Arduino board has at least one serial port (aka UART or USART). It communicates on digital pin 0 (RX) and pin 1 (TX), as well as with the computer via USB (via USB-to-Serial adaptor). This serial port is represented by the <code>Serial</code> object. If you started serial, you cannot use pins 0 and 1. You can use Arduino IDE's Serial Monitor to communicate with Arduino board.</p>
<p>The Arduino Mega2560 has three additional serial ports: <code>Serial1</code> on pins 18 (TX) and 19 (RX), <code>Serial2</code> on pins 16 (TX) and 17 (RX), <code>Serial3</code> on pins 14 (TX) and 15 (RX). There are NOT connected to the built-in USB-to-Serial adaptor, and you need an additional USB-to-Serial adaptor.</p>
<p>To use serial port, call <code>Serial.begin(baudRate)</code> or <code>Serial.begin(baudRate, config)</code> to set its speed and configuration (data, parity, stop bits). For example,</p>
<pre class="color-example">void setup() {
   <span class="color-comment">// open serial port, set baud rate to 57600</span>
   Serial.begin(57600);
   <span class="color-comment">// Arduino board writes to computer via serial port</span>
   Serial.println(&quot;Serial port started at baud rate of 57600&quot;);
}</pre>

<p>The <code>Serial</code>'s functions are:</p>
<ul>
<li><code>Serial.begin(<em>baudRate</em>, [<em>config</em>])</code>: setup serial communication.</li>
<li><code>Serial.end()</code>: Disable serial communication. Pins RX and TX can be used for general input/output.</li>
<li><code>Serial.print(<em>value</em>, [<em>format</em>])</code> and <code>Serial.println(<em>value</em>, [<em>format</em>])</code>: Prints data to the serial port as human-readable ASCII text, with an optional format. <code>Serial.println()</code> terminates with a newline. For examples,
  <pre class="color-example">
Serial.print(123);        <span class="color-comment">// 123</span>
Serial.print(1.23);       <span class="color-comment">// 1.23</span>
Serial.print(&quot;Hello&quot;);    <span class="color-comment">// Hello</span>
Serial.print(123, DEC);   <span class="color-comment">// 123</span>
Serial.print(123, HEX);   <span class="color-comment">// 7B</span>
Serial.print(123, OCT);   <span class="color-comment">// 173</span>
Serial.print(123, BIN);   <span class="color-comment">// 01111011</span>
Serial.print(1.2345, 2);  <span class="color-comment">// 1.23  (2 decimal places)</span>
Serial.print(1.2345, 3);  <span class="color-comment">// 1.234 (3 decimal places)</span></pre>
</li>
<li><code>Serial.write(<em>value</em>)</code>: Write binary data thru the serial port. The data is sent as a byte or a series of bytes. Use <code>print()</code> to send human-readable form.</li>

<li><code>Serial.available()</code>: Get the number of bytes (characters) available for reading from the serial port.</li>
<li><code>Serial.read()</code>: Read the first byte (in <code>int</code>) of the incoming serial data (or -1 if no data is available).
<pre class="color-example">
void setup() {
   Serial.begin(57600);
}
void loop() {
   char inChar;
   if (Serial.available() > 0) {
      inChar = (char)Serial.read();   <span class="color-comment">// Read one byte (in int)</span>
      Serial.println(inChar);         <span class="color-comment">// Format in ASCII text</span>
      Serial.println(inChar, DEC);    <span class="color-comment">// Format in DEC</span>
   }
}</pre></li>

<li><code>Serial.peek()</code>: Return the next byte (in <code>int</code>) of the incoming serial data without removing it from the internal serial buffer (or -1 if no data is available).</li>
<li><code>Serial.flush()</code>: wait for the transmission of outgoing serial data to complete.</li>
<li><code>serialEvent()</code>: Call back function when serial data is available. Use <code>Serial.read()</code> to read the data. Read &quot;<a href="https://www.arduino.cc/en/Tutorial/SerialEvent">serialEvent tutorial</a>&quot;.</li>
</ul>


<h4>Interrupts</h4>

<h5>Polling vs. Interrupt</h5>

<p>There are two ways for handling external inputs: polling and interrupt.</p>
<ol>
<li>In polling, you constantly poll the status of the external inputs and invoke the processing routine when the input is triggered.</li>
<li>In interrupt, you attach an interrupt service routine (ISR) to an external input. The ISR will be invoked when the input is triggered.</li>
</ol>

<h5>External Interrupt Pins</h5>
<p>In Arduino UNO, 2 pins (2 and 3) can be used for external interrupts and mapped to <code>INT0</code> and <code>INT1</code>. In Arduino Mega2560, 6 pins (2, 3, 18, 19, 20, 21) can be used for external interrupts.</p>

<h5>Interrupt Service Routine (ISR)</h5>
<p>ISRs are special functions that cannot have any parameters and return nothing. If there are multiple ISRs, only one can be run at a time, other interrupts will be invoked after the current one finishes, in an order that depends on their priority.</p>
<p>Since <code>millis()</code> replies on interrupt to count, it will never run (and increment) inside an ISR. <code>delay()</code> also requires interrupt and won't work inside ISR. Serial data may be lost. Global variables are used to pass data between main program and ISR. They should be declared as <code>volatile</code> (so that they are stored in RAM rather than register for multithreading).</p>
<p>Keep the ISR as short as possible. It shall update some global variables (<code>volatile</code>) to indicate state change.</p>
<p>To attach an ISR to an interrupt pin, use:</p>
<pre class="color-command">
attachedInterrupt(digitalPinToInterrupt(<em>pin</em>), <em>ISR</em>, <em>mode</em>)
</pre>

<p>The modes are:</p>
<ul>
<li><code>LOW|HIGH</code>: trigger when the pin is <code>LOW</code> or <code>HIGH</code>.</li>
<li><code>CHANGE</code>: trigger when the pin changes value.</li>
<li><code>RISING|FALLING</code>: trigger on the rising and falling edge.</li>
</ul>

<p>For example,</p>
<pre class="color-example">
const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;

void setup() {
   pinMode(ledPin, OUTPUT);
   pinMode(interruptPin, INPUT_PULLUP);
   attachInterrupt(digitalPinToInterrupt(interruptPin), toggle, CHANGE);
}

void loop() {
   digitalWrite(ledPin, state);
}

void toggle() {
   state = !state;
}</pre>

<h5>Enable/Disable Interrupts</h5>
<p>You can use <code>noInterrupts()</code> to disable all the interrupt, and <code>interrupts()</code> to re-enable all the interrupts. These could be useful for real-time applications, where certain critical, time-sensitive code need to be run. For examples,</p>

<pre class="color-example">
void loop() {
   ......
   noInterrupts();
   // critical, time-sensitive code here
   interrupts();
   ......
}</pre>

<h5>Pin-Change Interrupt</h5>

<p>As discussed, pins 2 and 3 can be used for external interrupts and triggered on <code>HIGH|LOW|CHANGE|RISING|FALLING</code>. On the other hands, all the 20 pins can be set to trigger on <code>RISING|FALLING</code> signal edge. However, there are only 3 interrupt vectors (subroutines) for all the 20 pins and you need to resolve the triggering pins.</p>

<h3>Arduino Language Reference</h3>

<h4>Data Types</h4>
<p>Arduino supports these data types. Take note that <code>int</code> is 16-bit, <code>long</code> is 32-bit, <code>float</code> and <code>double</code> are 32-bit.</p>
<ul>
<li>Integer:
<ul>
<li><code>byte</code>: 8-bit unsigned integer in the range of <code>[0,255]</code>.</li>
<li><code>short</code>: 16-bit signed integer in the range of <code>[-32768,32767]</code>, same as <code>int</code>.</li>
<li><code>int</code>: (for Arduino UNO and Mega) 16-bit signed integer in the range of <code>[-32768,32767]</code>.</li>
<li><code>unsigned int</code>: (for Arduino UNO and Mega) 16-bit unsigned integer in the range of <code>[0,65535]</code>.</li>
<li><code>long</code>: 32-bit signed integer in the range of <code>[-2147483648,2147483647]</code>.</li>
<li><code>unsigned long</code>: 32-bit unsigned integer in the range of <code>[0,4294967295]</code>.</li>
</ul>
</li>

<li>Character:
  <ul>
<li><code>char</code>: in ASCII code, represented as 8-bit signed integer in the range of <code>[-128,127]</code>.</li>
<li><code>unsigned char</code>: 8-bit unsigned integer in the range of <code>[0,255]</code><code></code>, same as <code>byte</code>.</li></ul></li>

<li>Floating Point:
<ul>
<li><code>float</code>: 32-bit floating point<code></code>.</li>
<li><code>double</code>: (for Arduino UNO and Mega) 32-bit floating point<code></code><code></code>, same as <code>float</code>.</li></ul>
</li>

<li>Boolean:
<ul>
<li><code>bool</code>: holds a value of either <code>true</code> or <code>false</code><code></code>. Occupied one byte of memory)</li>
<li><code>boolean</code>: same as <code>bool</code><code></code>.</li></ul>
</li>

<li>String: Strings can be represented in two ways: null-terminated <code>char</code> array or <code>String</code> object.
<ul>
<li>null-terminated <code>char</code> array: for example,
<pre class="color-example">char str1[8];               <span class="color-comment">// 7-character plus '\0'</span>
char str2[8] = {'a', 'r', 'd', 'u', 'i', 'n', 'o', '\0'};
char str3[8] = &quot;arduino&quot;;   <span class="color-comment">// terminated with '\0'</span>
char str4[] = &quot;arduino&quot;;    <span class="color-comment">// length is 8</span></pre>
</li>

<li><code>String</code> object: for examples,
<pre class="color-example">
String strObj1 = &quot;hello world&quot;;
String strObj2 = String(123);
String strObj3 = String(123, HEX);
String strObj3 = String(123, BIN);</pre>
<code>String</code> object has these functions:
<ul>
<li><code>aStr.length()</code>: returns the length of the string in characters, excluding the terminating null character.</li>
<li><code>aStr.charAt(unsigned int idx)</code>: returns the char at the given index. String character index begins at 0.</li>
<li><code>aStr.equals(String anotherStr)</code>: return <code>bool</code> of <code>true/false</code>.</li>
<li><code>aStr.substring(unsigned int fromIdx, unsigned int toIdx)</code>: return the substring from <code>fromIdx</code> (inclusive) to <code>toIdx</code> (exclusive).</li>
<li><code>aStr.toLowerCase()</code>, <code>aStr.toUpperCase()</code>:</li>
<li><code>aStr.indexOf(str|char)</code>: returns the index of the given substring or character; or -1 if not found.</li>
<li>more</li></ul></li>

</ul></li></ul>

<p>You can use these functions to perform type conversion: <code>byte()</code>, <code>char()</code>, <code>float()</code>, <code>int()</code>, <code>long()</code>.</p>
<p>You can use <code>sizeof()</code> to check the size of data type, variable and array. For examples,</p>

<pre class="color-example">
int myInt;
Serial.println(sizeof(myInt));
Serial.println(sizeof(int));

char myStr[] = &quot;hello world&quot;;
for (int i = 0; i &lt; sizeof(myStr) - 1; ++i) {   <span class="color-comment">// exclude terminating '\0'</span>
   Serial.println(myStr[i]);
}

int myIntArray[8];
for (int i = 0; i &lt; sizeof(myIntArray)/sizeof(int); ++i) {
   Serial.println(myIntArray[i]);
}</pre>

<h4>Literals</h4>

<ul>
<li>Integer Literals:
<ul>
<li>Base: For examples, <code>123</code> (base 10), <code>b1011</code> (base 2 with prefix <code>'B'</code> or <code>'b'</code>), <code>0123</code> (base 8 with prefix <code>'0'</code>), <code>0x123abc</code> (base 16 with prefix <code>'0x'</code> or <code>'0X'</code>).</li>

<li> Type:  By default, an integer literal is treated as <code>int</code>. You can use suffix <code>'u'</code> or <code>'U'</code> for <code>unsigned int</code> (e.g., 123u), suffix <code>'L'</code> or <code>'l'</code> for <code>long</code>, and suffix <code>'ul</code>' or <code>'UL'</code> for <code>unsigned long</code>.</li></ul></li>

<li>Floating Point Literals: for example, <code>12.3</code>, <code>-4.5</code>, <code>1.23e4</code>, <code>-1.234E-5</code>.</li>
</ul>

<h4>Constants</h4>

<p>Arduino defines these constants:</p>

<ul>
<li><code>bool</code> constants: <code>true</code> or <code>false</code>.</li>
<li>Digital pin levels: <code>HIGH</code> (&gt;3.0V on 5V board) or <code>LOW</code> (&lt;1.5V on 5V board).</li>
<li>Digital pin modes: <code>INPUT</code>, <code>OUTPUT</code>, <code>INPUT_PULLUP</code>.</li>
<li><code>LED_BUILTIN</code>: built-in LED pin number (Pin 13 for Arduino UNO and Mega).</li>
</ul>


<h4>Variable Scope and Qualifiers</h4>

<ul>
<li><code>const</code>: constant, cannot be modified. <code>const</code> is preferred over <code>#define</code>.</li>
<li><code>volatile</code>: direct the compiler to load the variable in RAM instead of register. This is useful in multithreading for concurrent access. For Arduino, it is used in Interrupt Service Routine (ISR).</li>
<li><code>static</code>: a <code>static</code> variable inside a function persists beyond the function calls and preserving its value between function calls.</li>
</ul>

<h4>Programming Constructs</h4>

<ul>
<li><code>if</code>, <code>if...else</code>, <code>if...elseif....elseif...else</code>:</li>
<li><code>switch...case</code>:</li>
<li><code>for</code>:</li>
<li><code>while</code>, <code>do...while</code>:</li>
<li><code>break</code>, <code>continue</code>:</li>
<li><code>return</code>:</li>
<li><code>#define</code>:</li>
<li><code>#include</code>:</li>
<li>Arithmetic Operators: <code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication), <code>/</code> (division), <code>%</code> (modulo), <code>++</code> (increment), <code>--</code> (decrement).</li>
<li>Comparison Operators: <code>==</code> (equal to), <code>!=</code> (not equal to), <code>&lt;</code> (less than), <code>&lt;=</code> (less than or equal to), <code>&gt;</code> (greater than), <code>&gt;=</code> (greater than or equal to).</li>
<li>Boolean Operators: <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR), <code>!</code> (logical NOT).</li>
<li>Bitwise Operators: <code>&amp;</code> (bitwise AND), <code>|</code> (bitwise OR), <code>~</code> (bitwise NOT), <code>^</code> (bitwise exclusive OR), <code>&lt;&lt;</code> (bitshift left), <code>&gt;&gt;</code> (bitshift right).</li>
<li>Assignment: <code>=</code> (assignment), <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> (compound assignment), <code>&amp;=</code>, <code>|=</code>, <code>^=</code> (compound bitwise assignment).</li>
<li>Pointers: <code>*</code> (dereference operating), <code>&amp;</code> (reference operator).</li>
</ul>

<h4>Built-In Functions</h4>

<ul>
<li><code>setup()</code>, <code>loop()</code>:</li>
<li>Digital IO: <code>pinMode()</code>, <code>digitalRead()</code>, <code>digitalWrite()</code>.</li>
<li>Analog IO: <code>analogRead()</code>, <code>analogWrite()</code>, <code>analogReference()</code>.</li>
<li>Advance IO:
<ul>
<li><code>tone(<em>pin</em>, <em>frequency</em>, [<em>duration</em>])</code>, <code>noTone()</code>: create a square wave of the specified <code><em>frequency</em></code> (<code>unsigned int</code>) (and 50% duty cycle) on a pin, for the optional <em><code>duration</code></em> in milliseconds (<code>unsigned long</code>).</li>
<li><code>pulseIn(<em>pin</em>, HIGH|LOW, [<em>timeout</em>])</code>, <code>pulseInLong()</code>: Read a pulse (either <code>HIGH</code> or <code>LOW</code>) on a pin, until an optional <code><em>timeout</em></code>, and return the pulse in microseconds (<code>unsigned long</code>).</li>
<li><code>shiftIn(<em>dataPin</em>, <em>clockPin</em>, MSBFIRST|LSBFIRST)</code>, <code>shiftOut(<em>dataPin</em>, <em>clockPin</em>, MSBFIRST|LSBFIRST, <em>value</em>)</code>:</li>
</ul></li>

<li>Delay: <code>delay()</code>, <code>delayMicroseconds()</code>: delay in milliseconds or microseconds.</li>
<li>Time: <code>mills()</code>, <code>micros()</code>: the number of milliseconds or microseconds since the current program started.</li>
<li>Math: <code>pow()</code>, <code>sqrt()</code>, <code>sq()</code>, <code>max()</code>, <code>min()</code>, <code>abs()</code>, <code>map()</code>, <code>constrain()</code>, <code>sin()</code>, <code>cos()</code>, <code>tan()</code>.</li>
<li>Random: <code>random(<em>min</em>|0, <em>max</em>)</code>, <code>randomSeed()</code>: returns a pseudo-random numbers between <code><em>min</em></code> and <code><em>max</em></code> (exclusive) (in <code>long</code>).</li>
<li>Characters: <code>isAlpha()</code>, <code>isDigit()</code>, <code>isAlphaNumeric()</code>, <code>isSpace()</code>, <code>isWhitespace()</code>, <code>isUpperCase()</code>, <code>isLowerCase()</code>, <code>isPunct()</code>,  <code>isASCII()</code>,  <code>isGraph()</code>,  <code>isPrintable()</code>,  <code>isHexadecimalDigit()</code>,  <code>isControl()</code>. </li>
<li>Interrupts: <code>interrutps()</code>, <code>nointerrupts()</code>:</li>
<li>External Interrupts: <code>attachInterrupt()</code>, <code>detachInterrutp()</code>:</li>
<li>Communication objects: <code>Serial</code>, <code>Stream</code>.</li>
<li>USB objects: <code>Keyboard</code>, <code>Mouse</code>.</li>
</ul>


<h3>Debugging Arduino Programs</h3>

<h4><span class="font-code">Serial.println()|print()|write()</span></h4>

<p>It is extremely DIFFICULT to debug Arduino programs. It is hard to build a debugger, as the program is run inside the Arduino board and NOT in your computer. There is no <em>runtime</em> error messages. Furthermore, the bug could be due to the external hardware or your software!!!</p>
<p>You could inspect the value of a variable inside the Arduino board by printing it back to your computer via serial port, using one of the following functions:</p>

<ul>
<li><code>Serial.print(var)</code> prints the value of a variable in human-readable ASCII texts.</li>
<li><code>Serial.println(var)</code> appends a new line at the end of the output.</li>
<li><code>Serial.write(var)</code> writes a raw byte.</li>
</ul>
<p>The output is captured in the &quot;Serial Monitor&quot; (under &quot;tools&quot; menu) of Arduino IDE.</p>

<p>You need to include a <code>Serial.open(9600)</code> statement in the <code>setup()</code>, where 9600 (or 57600) is a typical serial transmission baud rate.</p>

<h4>Atmel Studio</h4>

<p>Atmel Studio is a free Arduino IDE, which you can set breakpoints and trace through the program.</p>
<p>[TODO more]</p>

<h3>Arduino Projects</h3>

<h4>LED Cube</h4>

<h5>Circuit Diagram</h5>
<img class="image-center" src="images/LEDCube.png" alt="LED Cube" />

<h5>Pin Counts</h5>
<p>A 3x3x3 LED cube requires 3 layer pins + 3*3 column pins = 12 digital pins. For RGB, you need 3*3*3 = 27 column pins, with total of 30 digital pins.</p>
<p>A 4x4x4 LED cube requires 4 layer pins + 4*4 column pins = 20 digital pins. For RGB, you need 4*4*3 = 48 column pins, with total of 52 digital pins.</p>
<p>You could use an Arduino MEGA 2560, which has 54 digital pins (instead of Arduino UNO having 14 digital pins).</p>
<p>A 8x8x8 RGB LED cube requires 8 layer pin + 8*8*3 = 200 digital pins. You need to design a multiplexer circuit!</p>

<h5>Computation of Resistors' Value</h5>
<p>Assuming that only one layer is turned on at one time, <code>V<sub>EC</sub>=0.2V</code>, forward voltage and current of LED is 2.2V and 20mA respectively, then, <code>R2=(5-0.2-2.2)V/20mA=130Ω</code>. Suppose that <code>h<sub>FE</sub>=10</code> (at saturation) and <code>V<sub>EB</sub>=0.8V</code>,  we have <code>I<sub>B</sub>=I<sub>C</sub>/h<sub>FE</sub>=2mA</code>. Hence, <code>R1=(5-0.8)V/2mA=2.1KΩ</code>.</p>

<h5>Dissecting the Circuit Diagram</h5>
<ol>
<li>Your program shall turn on one layer at one time, via a refresh loop.</li>
<li>Your program shall place the values of XY in a display buffer.</li>
<li>When a layer is turn on (by setting the layer value low) and the XY is low, current flows from 5V thru the LED and turn on the LED.</li>
<li>On the other hand, when the layout value is high, the entire layout is off.</li>
</ol>

<h5>Using Multiplexers</h5>
<p>[TODO]</p>

<h4>Musical Tree/Tubes</h4>

<p>[TODO]</p>

<h4>Clock/Timer</h4>

<p>[TODO]</p>

<h3>Miscellaneous</h3>

<h4>How to choose the wires</h4>
<p>Reference: &quot;Wire and Connections&quot; @ <a href="https://learn.adafruit.com/wires-and-connections/overview">https://learn.adafruit.com/wires-and-connections/overview</a>.</p>

<h5>Solid verses Stranded Wires</h5>
<p>Solid wires are harder to bend and less flexible; but easier to insert into breadboard/connectors and easier to solder. Stranded wires are flexible but harder to make connections on the ends.</p>

<h5>Wire Gauge and Sizes</h5>

<p>Wire sizes are measured in standardized AWG (American Wire Gauge)  which is related to the diameter of the wire. The smaller the gauge number, the larger is the diameter of the wire and the more current its can carry.</p>

<p>The rules of thumb are:</p>

<ul>
  <li>Breadboards: Gauge-22 (5A) to Gauge-20 (6A). For starter, buy some Gauge-22 solid wires (Red, Black, and some colors) to work on breadboard.</li>
  <li>High current: If you need high current to drive large motor, many LEDs, or wearable, use thicker wire starting at Gauge-18 (9.5A) or Gauge-16 (13A) and lower.</li>
<li>Household electrical power: Gauge-16 (13A)(Extension Cords) to Gauge-10 (30A)(Air-Conditioners. Ovens).</li>
</ul>

<p>The voltage drop due to wire's resistance should not exceed 3% over the entire length. For example, for 12V, it should be at least 11.64V at the other end; for 5V, it should be at least 4.85V.</p>
<p>In Europe, wires are measured in metric (instead of AWG). E.g., 16/0.2 means 16 strands and 0.2mm diameter, which is roughly equivalent to AWG Gauge-20. Some typical specifications are:</p>

<ul>
<li>16/0.2: 16 strands, 0.2mm diameter per stand, 1.6mm overall diameter, 1.55m cable diameter, 0.5mm<sup>2</sup> cross sectional area, rating 1KV 3A (3KW) at 70&deg;C, tinned copper conductor.</li>
</ul>

<p>For DC circuit, use RED for power (Vcc) and BLACK for Ground (GND).</p>

<h4>Connectors</h4>

<h5>How to twist two wires?</h5>
<p>[TODO]</p>

<h5>For AC Wires: Wire Nuts / Electrical Terminal Connector Strip</h5>
<p>[TODO]</p>

<h5>3-pin/4-pin LED Strip Connector</h5>
<p>[TODO]</p>


<p class="references">REFERENCES &amp; RESOURCES</p>

<ol>
<li>Arduino mother site @ <a href="http://arduino.cc/">http://arduino.cc</a>.</li>
<li>Arduino github @ <a href="https://github.com/arduino/Arduino">https://github.com/arduino/Arduino</a> (source codes).</li>
<li>Oomlout @ <a href="http://oomlout.com/oom.php">http://oomlout.com/oom.php</a> (Arduino getting started tutorials).</li>
<li>Sparkfun @ <a href="https://www.sparkfun.com/">https://www.sparkfun.com</a> (Electronic components with datasheets).</li>
</ol>

<p class="references">Electronic Components Store @ SG</p>
<ol>
<li>SGBotic @ <a href="http://www.sgbotic.com/">http://www.sgbotic.com/</a>.</li>
<li>RS Components @ <a href="http://sg.rs-online.com/web/">http://sg.rs-online.com/web/</a>.</li>
<li>Sing Lim Tower.</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: Arduino IDE 1.8.5 on Arduino Uno/Mega2560<br />
Last modified: March, 2018</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>Feedback, comments, corrections, and errata can be sent to Chua Hock-Chuan (ehchua@ntu.edu.sg) &nbsp;&nbsp;|&nbsp;&nbsp; <a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html">HOME</a></p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->


</body></html>