<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>The Collection Framework - Java Programming Tutorial</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="J5c_Collection.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>The Java Collection Framework</h1>
<h2>Part 1: JDK 5</h2>
</div>

<div id="content-main">

<h3>Introduction to the  Collection Framework</h3>
<p>Although we can use an <em>array</em> as a <em>container</em> to store a group of elements of the same type (primitives or objects).  The array, however, does not support so-called <em>dynamic allocation</em> - it has a <em>fixed length</em> which cannot be changed once allocated.   Furthermore, array is a simple linear structure. Many applications may require more complex data structure such as linked list, stack, hash table, set, or tree.</p>

<p>In Java, dynamically allocated <em>data structures</em> (such as <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>, <code>Stack</code>, <code>HashSet</code>, <code>HashMap</code>, <code>Hashtable</code>) are supported in a <em>unified architecture</em> called the <em>Collection Framework</em>, which mandates the common behaviors of all the classes.</p>

<p>A <em>collection</em>, as its name implied, is simply <em>a container object that holds a collection of objects</em>. Each item in a collection is called an <em>element</em>.  A <em>framework</em>, by definition, is a set of interfaces that force you to adopt some design practices. A well-designed  framework can improve your productivity and provide ease of maintenance.</p>
<p>The <em>collection framework</em> provides a <em>unified interface</em> to store, retrieve and manipulate the elements of a collection, regardless of the underlying  actual implementation.  This allows the programmers to program at the interface specification, instead of the actual implementation.</p>

<p>The Java Collection Framework package (<code>java.util</code>) contains:</p>
<ol>
<li>A set of interfaces,</li>
<li>Implementation classes, and</li>
<li>Algorithms (such as sorting and searching).</li>
</ol>

<p>Similar Collection Framework is the C++ Standard Template Library (STL).</p>

<p>Prior to JDK 1.2, Java's data structures consist of array, <code>Vector</code>, and <code>Hashtable</code> that were designed in a non-unified way with inconsistent public interfaces. JDK 1.2 introduced the unified <em>collection framework</em>, and retrofits the legacy classes (<code>Vector</code> and <code>Hashtable</code>) to conform to this unified <em>collection framework</em>.</p>

<p>JDK 5 introduced <em>Generics </em>(which supports passing of types), and many related features (such as auto-boxing/auto-unboxing and for-each loop). The collection framework is retrofitted to support generics and takes full advantages of these new features.</p>

<p>To understand this chapter, you have to be familiar with:</p>
<ul>
<li>Interfaces, abstract methods and their implementations.</li>
<li>Inheritance and Polymorphism, especially the upcasting and downcasting operations. See &quot;<a href="JavaGeneric.html#ReviewInheritance">Inheritance, Substitution, Polymorphism and Type Casting</a>&quot; for a quick summary.</li>
</ul>

<p>You also need to be familiar with these concepts introduced in JDK 5:</p>
<ul>
<li>Auto-Boxing and Auto-Unboxing between primitive types and their wrapper classes. See &quot;<a href="JavaGeneric.html#J5Autobox">Auto-Boxing and Auto-Unboxing</a>&quot;.</li>
<li>The enhance fo-each loop. See &quot;<a href="JavaGeneric.html#J5ForEachLoop">Enhanced for-each Loop</a>&quot;.</li>
<li>Generics. See &quot;<a href="JavaGeneric.html">Generics</a>&quot;.</li>
</ul>

<p>You need to refer to the JDK API specification while reading this chapter.  The classes and interfaces for the <em>Collection Framework</em> are kept in package <code>java.util</code>.</p>

<h3>Generic Collection Framework (JDK 5) by Examples</h3>

<h4>Example 1: <span class="font-code">List&lt;String&gt;</span> (<span class="font-code">List</span> of <span class="font-code">Strings</span>) Implemented by <span class="font-code">ArrayList</span></h4>

<p>The <code>java.util.List&lt;E&gt;</code> interface is the most commonly used data structure of the Collection Framework, which models a resizable (dynamically-allocated) array supporting numerical index access. The <code>java.util.ArrayList&lt;E&gt;</code> class is the most commonly used implementation of <code>List&lt;E&gt;</code>.</p>
<p>The <code>&lt;E&gt;</code> indicates that the interfaces are <em>generic</em> in design. When you construct an instance of these generic types, you need to provide the <em>specific</em> type of the objects contained in these collection, e.g., <code>&lt;String&gt;</code>, <code>&lt;Integer&gt;</code>. This allows the compiler to perform type-checking when elements are added into the collection at compile-time to ensure type-safety at runtime.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

<span class="color-comment">// JDK 5 List&lt;String&gt; with Generics, implemented by an ArrayList</span>
public class <strong>J5ListOfStringTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Declare a List&lt;String&gt; (List of String)</span> <span class="color-comment">implemented by an ArrayList&lt;String&gt;</span>
      <span class="color-comment">// The compiler is informed about the type of objects in the collection via &lt;&gt;.
      // It performs type checking when elements are added into the collection</span>
      <span class="color-new">List&lt;String&gt;</span> coffeeLst = <span class="color-new">new ArrayList&lt;&gt;</span>();
         <span class="color-comment">// JDK 7 supports type inference on instantiation.</span>
         <span class="color-comment">// ArrayList&lt;String&gt; can be written as ArrayList&lt;&gt;, with type inferred from List&lt;String&gt;</span>
      coffeeLst.add(&quot;espresso&quot;);
      coffeeLst.add(&quot;latte&quot;);
      coffeeLst.add(&quot;cappuccino&quot;);
      System.out.println(coffeeLst);  <span class="color-comment">//<span class="color-output">[espresso, latte, cappuccino]</span></span>

      <span class="color-comment">// (1) Use an Iterator&lt;String&gt; to traverse through all the elements</span>
      <span class="color-new">Iterator&lt;String&gt;</span> iter = coffeeLst.iterator();
      while (iter.hasNext()) {
         <span class="color-new">String</span> str = iter.next();
         System.out.println(str);
      }
      <span class="color-comment">//<span class="color-output">espresso</span></span>
      <span class="color-comment">//<span class="color-output">latte</span></span>
      <span class="color-comment">//<span class="color-output">cappuccino</span></span>

      <span class="color-comment">// (2) Use an enhanced for-each loop (JDK 5) to traverse through the list</span>
      <span class="color-new">for (String str : coffeeLst)</span> System.out.println(str.toUpperCase());
      <span class="color-comment">//<span class="color-output">ESPRESSO</span></span>
      <span class="color-comment">//<span class="color-output">LATTE</span></span>
      <span class="color-comment">//<span class="color-output">CAPPUCCINO</span></span>

      <span class="color-comment">// A List supports numerical index access, where index begins at 0</span>
      for (int i = 0; i &lt; coffeeLst<span class="color-new">.size()</span>; ++i) {
         System.out.println(coffeeLst<span class="color-new">.get(i)</span>.substring(0, 3));
      }
      <span class="color-comment">//<span class="color-output">esp</span></span>
      <span class="color-comment">//<span class="color-output">lat</span></span>
      <span class="color-comment">//<span class="color-output">cap</span></span>

      <span class="color-comment">// Compiler checks the type of the elements added or retrieved</span>
      <span class="color-comment">//<span class="color-error">coffeeLst.add(new Integer(1234))</span>;</span>
      <span class="color-comment">//<span class="color-error">compilation error: incompatible types: Integer cannot be converted to String</span></span>
      <span class="color-comment">//<span class="color-error">Integer intObj = coffeeLst.get(0)</span>;</span>
      <span class="color-comment">//<span class="color-error">compilation error: incompatible types: String cannot be converted to Integer</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<h5>Dissecting the Program</h5>
<ul>
<li>Line 1-3 imports the collection framework classes and interfaces reside in the <code>java.util</code> package.
</li>

<img class="image-center" src="images/Collection_ListImplementation.png" alt="list implementation"/>
<li>The class hierarchy of the <code>ArrayList&lt;E&gt;</code> is shown above. We observe that <code>ArrayList&lt;E&gt;</code> implements <code>List&lt;E&gt;</code>, <code>Collection&lt;E&gt;</code> and <code>Iterable&lt;E&gt;</code> interfaces. The <code>Collection&lt;E&gt;</code> and <code>Iterable</code>&lt;E&gt; interfaces define the common behaviors of all the collection implementations.</li>

<li>The interfaces/classes are designed (by the class designer) to take a generics type <code>E</code>. To construct an instance of an <code>ArrayList&lt;E&gt;</code>, we need to provide the actual type for generic type <code>E</code>. In this example, we pass the actual type <code>String</code> for the generic type <code>E</code>.</li>

<li>In line 11, we construct an <code>ArrayList&lt;String&gt;</code> instance, and <em>upcast</em> it to the <code>List&lt;String&gt;</code> interface.  This is possible as the <code>ArrayList&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code>.  Remember that a good program operates on the specifications instead of an actual implementation. The <em>Collection Framework</em> provides a set of interfaces so that you can program on these interfaces instead of the actual implementation.</li>

<li>JDK 7 supports type inference on instantiation to simplify the codes:
<pre class="color-example">
<span class="color-comment">// Prior to JDK 7, you need to write</span>
List<span class="color-new">&lt;String&gt;</span> coffeeLst = new ArrayList<span class="color-new">&lt;String&gt;</span>();

<span class="color-comment">// JDK 7 can infer on type from the type of the assigned variable</span>
List<span class="color-new">&lt;String&gt;</span> coffeeLst = new ArrayList<span class="color-new">&lt;&gt;</span>();
</pre>
</li>

<li> Interface <code>Collection</code> defines how to add and remove an element into the collection.  Interface <code>Iterable</code> defines a mechanism to iterate or traverse through all the elements of a collection. </li>

<li>The super-interface <code>Collection&lt;E&gt;</code> interface defines the common behaviors expected from a <code>Collection&lt;E&gt;</code> object (such as getting the size, adding and removing element). Instead of using the interface <code>Collection&lt;E&gt;</code> directly, it is more common to use one of its specialized sub-interfaces: <code>List</code> (an ordered list supporting numerical indexed access), <code>Set</code> (models mathematical set with no duplicate elements) or <code>Queue</code> (FIFO, priority queues).<br />
The super-interface <code>Collection&lt;E&gt;</code> declares these <code>abstract</code> methods, implemented in concrete class <code>ArrayList&lt;E&gt;</code>:
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.</span><span class="color-new">Collection&lt;E&gt;</span>
abstract int <span class="color-new">size</span>()                       <span class="color-comment">// Returns the number of elements</span>
abstract boolean <span class="color-new">isEmpty</span>()                <span class="color-comment">// Returns true if there is no elements</span>
abstract boolean <span class="color-new">add</span>(E element)           <span class="color-comment">// Adds the given element (of the instantiated type only)</span>
abstract boolean <span class="color-new">remove</span>(Object element)   <span class="color-comment">// Removes the given element, if present
</span>abstract boolean <span class="color-new">contains</span>(Object element) <span class="color-comment">// Returns true if this Collection contains the given element</span>
......</pre>
Line 14-16 adds elements (of the instantiated actual type <code>String</code>) to the <code>Collection</code>.</li>

<li>There are a few ways of traversing through the elements of a <code>Collection</code>:
<ol>
<li>Via an associated <code>Iterator&lt;E&gt;</code> (Lines 20-24)</li>
<li>Use the new for-each loop introduced in JDK 5 (Line 30)</li>
<li>Use aggregate operations on Stream introduced in JDK 8. See &quot;Example 4&quot;.</li>
</ol>
</li>

<li>The super-interface <code>Iterable&lt;E&gt;</code> defines a mechanism to iterate (or traverse) through all the elements of a <code>Collection&lt;E&gt;</code> object via a so-called <code>Iterator&lt;E&gt;</code> object.  The <code>Iterable&lt;E&gt;</code> interface declares one <code>abstract</code> method to retrieve the <code>Iterator&lt;E&gt;<span class="color-comment"></span></code> object associated with the <code>Collection&lt;E&gt;</code>.
  <pre class="color-syntax">
<span class="color-comment">// Interface java.lang.<span class="color-new">Iterable&lt;E&gt;</span></span>
abstract Iterator&lt;E&gt; <span class="color-new">iterator</span>();
   <span class="color-comment">// Returns the associated Iterator instance that can be used to traverse thru all the elements</span>
</pre>
</li>

<li>The <code>Iterator&lt;E&gt;</code> interface declares the following <code>abstract</code> methods for traversing through the <code>Collection&lt;E&gt;</code>.
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Iterator&lt;E&gt;</span></span>
abstract boolean <span class="color-new">hasNext</span>()  <span class="color-comment">// Returns true if it has more elements</span>
abstract E <span class="color-new">next</span>()           <span class="color-comment">// Returns the next element (of the actual type)</span>
</pre>
Lines 20-24 retrieve the <code>Iterator&lt;String&gt;</code> associated with this <code>ArrayList&lt;String&gt;</code>, and use a while-loop to iterate through all the elements of this <code>ArrayList&lt;String&gt;</code>.  Take note that you need to specify the actual type.</li>

<li>Line 30 uses the new for-each loop introduced in JDK 5 to iterate through all the elements of a <code>Collection</code>.</li>

<li><code>List</code> supports numerical index access via <code>.get(index)</code> method, with index begins from 0, shown in Lines 36-38.</li>

<li>With the use of generics, the compiler checks the type of elements added or retrieved and issue compilation error &quot;incompatible type&quot;, as shown in lines 44-47. This is known as compiled-time type-safe.</li>
</ul>

<h4>Example 2: <span class="font-code">List&lt;Integer&gt;</span> with Auto-Boxing/Auto-Unboxing</h4>

<p>Collection can hold only objects, not primitives (such as <code>int</code>, <code>double</code>). JDK 5 introduces auto-boxing/auto-unboxing to simplify the conversion between primitives and their wrapper classes (such as <code>int/Integer</code>, <code>double/Double</code>, etc.)</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;

<span class="color-comment">// JDK 5 List of primitive wrapper objects with auto-boxing/auto-unboxing</span>
public class <strong>J5ListOfPrimitivesTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Collection holds only objects, not primitives</span>
      <span class="color-comment">// JDK 5 supports auto-boxing/auto-unboxing of primitives to their wrapper class</span>
      <span class="color-new">List&lt;Integer&gt;</span> numLst = <span class="color-new">new ArrayList&lt;&gt;</span>();  <span class="color-comment">// List of Integer object (not int)</span>
      numLst.add(<span class="color-new">111</span>);  <span class="color-comment">// auto-box primitive int to Integer object</span>
      numLst.add(<span class="color-new">222</span>);
      System.out.println(numLst);    <span class="color-comment">//<span class="color-output">[111, 222]</span></span>
      <span class="color-new">int</span> firstNum = numLst.get(0);  <span class="color-comment">// auto-unbox Integer object to int primitive</span>
      System.out.println(firstNum);  <span class="color-comment">//<span class="color-output">111</span></span>

      <span class="color-comment">//<span class="color-error">numLst.add(33.33)</span>;           // Only accept Integer or int(auto-box)
      //<span class="color-error">compilation error: incompatible types: double cannot be converted to Integer</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>In this example, we pass actual type <code>Integer</code> for the generic type <code>E</code>. In Line 9, we construct an <code>ArrayList&lt;Integer&gt;</code> and upcast to <code>List&lt;Integer&gt;</code>.</li>
<li>In lines 10-11, we pass <code>int</code> value into the <code>.add()</code>. The <code>int</code> value is auto-boxed into an <code>Integer</code> object, and added into the <code>List&lt;Integer&gt;</code>.</li>
<li>In line 13, the <code>.get()<span class="color-comment"></span></code> returns an <code>Integer</code> object, which is auto-unboxed to an <code>int</code> value.</li>
</ul>


<h4>Example 3: <span class="font-code">Set&lt;E&gt;</span> Implemented by <span class="font-code">HashSet</span></h4>

<p>This example shows how to create a <code>Collection</code> of an user-defined objects.</p>
<p>The <code>Set&lt;E&gt;</code> interface models an unordered mathematical set without duplicate elements. <code>HashSet&lt;E&gt;</code> is the most common implementation of <code>Set&lt;E&gt;</code>. </p>

<p>We define a <code>Person</code> class with two private variables <code>name</code> and <code>age</code>, as follows:</p>

<h5><span class="font-code">Person.java</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td>
<td>
<pre>
public class <strong>Person</strong> {
   private String name;  <span class="color-comment">// private instance variables</span>
   private int age;

   public Person(String name, int age) {  <span class="color-comment">// constructor</span>
      this.name = name; this.age = age;
   }
   public String getName() {  <span class="color-comment">// getter for name</span>
      return name;
   }
   public int getAge() {  <span class="color-comment">// getter for age</span>
      return age;
   }
   public String toString() {  <span class="color-comment">// describe itself</span>
      return name + &quot;(&quot; + age + &quot;)&quot;;
   }

   public void sayHello() {  <span class="color-comment">// for testing</span>
      System.out.println(name + &quot; says hello&quot;);
   }

   <span class="color-comment">// Compare two Person objects by name strings, case insensitive</span>
   @Override
   public boolean equals(Object o) {
      return o != null &amp;&amp; o instanceof Person &amp;&amp; this.name.equalsIgnoreCase(((Person)o).name);<br />   }
   <span class="color-comment">// To be consistent with equals()</span>
   <span class="color-comment">// Two objects which are equal shall have the same hashcode.</span>
   @Override
   public int hashCode() {
      return this.name.toLowerCase().hashCode();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>We shall test a <code>Set&lt;Person&gt;</code> is follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
import java.util.Set;
import java.util.HashSet;

<span class="color-comment">// JDK 5 Set of Person objects</span>
public class <strong>J5SetOfPersonTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">Set&lt;Person&gt;</span> personSet = <span class="color-new">new HashSet&lt;&gt;</span>();
      personSet.add(new Person(&quot;Peter&quot;, 21));
      personSet.add(new Person(&quot;Paul&quot;, 18));
      personSet.add(new Person(&quot;John&quot;, 60));
      System.out.println(personSet);  <span class="color-comment">//<span class="color-output">[John(60), Peter(21), Paul(18)]</span></span>
         <span class="color-comment">// Unlike List, a Set is NOT ordered</span>

      <span class="color-new">for (Person p : personSet)</span> p.sayHello();
      <span class="color-comment">//<span class="color-output">John says hello</span></span>
      <span class="color-comment">//<span class="color-output">Peter says hello</span></span>
      <span class="color-comment">//<span class="color-output">Paul says hello</span></span>

      <span class="color-comment">// Set does not support duplicate elements</span>
      System.out.println(personSet.<span class="color-new">add(new Person(&quot;Peter&quot;, 21))</span>);  <span class="color-comment">//<span class="color-output">false</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<h5>Dissecting the Program</h5>
<ul>
<li>We define our custom objects called <code>Person</code> in &quot;<code>Person.java</code>&quot;.</li>
<li>In this example, we pass actual type <code>Person</code> for the generic type <code>E</code>. In Line 7, we construct an instance of <code>HashSet&lt;Person&gt;</code>, and upcast to <code>Set&lt;Person&gt;</code>.</li>
<li>Take note that the elements in a <code>Set</code> are not ordered, as shown in the output of Line 11.</li>
<li>A <code>Set</code> does not duplicate elements, as shown in the output of Line 20. To compare two <code>Person</code> objects, we override the <code>.equal()</code> and <code>.hashCode()</code> methods in &quot;<code>Person.java</code>&quot;.</li>
</ul>

<h4>Example 4: JDK 8 Collection, Stream and Functional Programming (Preview)</h4>

<p>JDK 8 greatly enhances the Collection Framework with the introduction of Stream API to support functional programming.</p>

<p><span class="line-heading">Person.java<span class="font-code"></span></span>: See above</p>


<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

<span class="color-comment">// JDK 8 Collection, Stream and Functional Programming</span>
public class <strong>J8StreamOfPersonTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">List&lt;Person&gt;</span> personLst = <span class="color-new">List.of</span>(  <span class="color-comment">// JDK 9 instantiation of an unmodifiable List</span>
         new Person(&quot;Peter&quot;, 21),
         new Person(&quot;Paul&quot;, 18),
         new Person(&quot;John&quot;, 60)
      );
      System.out.println(personLst);  <span class="color-comment">//<span class="color-output">[Peter(21), Paul(18), John(60)]</span></span>

      <span class="color-comment">// Use a Predicate to filter the elements</span>
      Predicate&lt;Person&gt; adult = p -&gt; p.getAge() &gt;= 21;

      <span class="color-comment">// All adults say hello (filter-reduce(foreach))</span>
      personLst
         .stream()
         .filter(adult)
         .forEach(Person::sayHello);
      <span class="color-comment">//<span class="color-output">Peter says hello</span></span>
      <span class="color-comment">//<span class="color-output">John says hello</span></span>

      <span class="color-comment">// Use a parallel stream (reduce(foreach))</span>
      personLst
         .parallelStream()
         .forEach(p -&gt; System.out.println(p.getName()));
      <span class="color-comment">//<span class="color-output">Paul</span>
      //<span class="color-output">Peter</span>
      //<span class="color-output">John</span></span>

      <span class="color-comment">// Get the average age of all adults (filter-map-reduce(aggregate))</span>
      double aveAgeAdults = personLst
         .stream()
         .filter(adult)
         .mapToInt(Person::getAge)
         .average()
         .getAsDouble();
      System.out.println(aveAgeAdults);
      <span class="color-comment">//<span class="color-output">40.5</span></span>

      <span class="color-comment">// Collect the sum of ages (reduce(aggregate))</span>
      int sumAges = personLst
         .stream()
         .collect(Collectors.summingInt(Person::getAge));
      System.out.println(sumAges);
      <span class="color-comment">//<span class="color-output">99</span></span>

      <span class="color-comment">// Collect the names starting with 'P' (filter-map-reduce(collect))</span>
      List&lt;String&gt; nameStartWithP = personLst
         .stream()
         .filter(p -&gt; p.getName().charAt(0) == 'P')
         .map(Person::getName)
         .collect(Collectors.toList());
      System.out.println(nameStartWithP);
      <span class="color-comment">//<span class="color-output">[Peter, Paul]</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This article focuses on JDK 5 Collection Framework. Read &quot;<a href="JDK8_Lambda.html">Lambda Expressions, Streams and Functional Programming</a>&quot; and &quot;<a href="J5c_CollectionPart2.html">Collection Framework, Part 2</a>&quot; for details on JDK 8 enhancements.</p>


<h3>Pre-JDK 5 vs. JDK 5 Collection Framework</h3>

<p>JDK 5 introduces Generics to support parameterized type and retrofitted the Collection Framework. To understand the differences between Pre-JDK 5 and JDK 5 Collection Framework, read &quot;<a href="JavaGeneric.html#GenericsDetails">Generics</a>&quot;.</p>


<h3>The Collection Interfaces</h3>

<p>The hierarchy of the interfaces and the commonly-used implementation classes in the <em>Collection Framework</em> is as shown below:</p>

<img class="image-center" src="images/Collection_interfaces.png" alt="Collection Framework Interfaces" />

<ul>
<li>The <em>base</em> interface is <code>Collection&lt;E&gt;</code> (which is a subtype of <code>Iterable</code>&lt;E&gt;), that defines the common behaviors.</li>
<li>We hardly program at the <code>Collection&lt;E&gt;</code>, but one of its specialized subtypes. The commonly-used subtypes of are <code>List&lt;E&gt;</code> (ordered elements supporting index access), <code>Set&lt;E&gt;</code> (unordered and non-duplicate) and <code>Queue&lt;E&gt;</code> (FIFO and priority queues).</li>
<li>The popular implementation classes for <code>List&lt;E&gt;</code> are <code>ArrayList&lt;E&gt;</code> and <code>LinkedList&lt;E&gt;</code>; for <code>Set</code> are <code>HashSet&lt;E&gt;</code> and <code>TreeSet&lt;E&gt;</code>; for Queue is <code>PriorityQueue&lt;E&gt;</code>.</li>
<li>The <code>Iterator&lt;E&gt;</code> is used to traverse (or iterate) through each element of a <code>Collection&lt;E&gt;</code>.</li>
<li><code>Map&lt;K,V&gt;</code> (or associative array), which supports key-value pair, is NOT a subtype of <code>Collection&lt;E&gt;</code>. The popular implementation class is <code>HashMap&lt;K,V&gt;</code>.</li>
<li>The <code>Collections</code> (like Arrays) is a utility class, which contains <code>static</code> methods to support algorithms like searching and sorting.</li>
</ul>


<h4><span class="font-code">Iterable&lt;E&gt;/Iterator&lt;E&gt;</span> Interfaces and  for-each Loop</h4>

<p>There are three ways to traverse through all the elements of a <code>Collection</code>:</p>
<ol>
<li>Via the associated <code>Iterator&lt;E&gt;</code> object retrieved from the super-type <code>Iterable&lt;E&gt;</code></li>
<li>Using the for-each loop (introduced in JDK 5)</li>
<li>Via the Stream API (introduced in JDK 8) (to be discussed in &quot;<a href="J5c_CollectionPart2.html">Collection Framework, Part 2</a>&quot;)</li>
</ol>

<h5>The <span class="font-code">Iterable&lt;E&gt;</span> Interface</h5>
<p>The <code>java.lang.Iterable&lt;E&gt;</code> interface, which takes a generic type <code>&lt;E&gt;</code> and read as <code>Iterable</code> of elements of type <code>E</code>, declares one <code>abstract</code> method called <code>iterator()</code> to retrieve the <code>Iterator&lt;E&gt;</code> object associated with the <code>Collection&lt;E&gt;</code> object. This <code>Iterator&lt;E&gt;</code> object can then be used to traverse through all the elements of the associated collection.</p>

<pre class="color-syntax">
<span class="color-comment">// Interface java.lang.<span class="color-new">Iterable&lt;E&gt;</span></span>
abstract Iterator&lt;E&gt; <span class="color-new">iterator</span>();
<span class="color-comment">   // Returns the associated Iterator instance that can be used to traverse thru all the elements of the collection</span>
</pre>

<p>All implementations of the <code>Collection</code> (e.g., <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>) must implement this method, which returns an object that implements <code>Iterator</code> interface, for traversal of the <code>Collection</code>.</p>

<h5>The <span class="font-code">Iterator&lt;E&gt;</span> Interface</h5>

<p>The <code>Iterator&lt;E&gt;</code> interface, declares the following three <code>abstract</code> methods:</p>
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Iterator&lt;E&gt;</span></span>
abstract boolean <span class="color-new">hasNext</span>()  <span class="color-comment">// Returns true if it has more elements</span>
abstract E <span class="color-new">next</span>()           <span class="color-comment">// Returns the next element of generic type E</span>
abstract void <span class="color-new">remove</span>()      <span class="color-comment">// Removes the last element returned by the iterator</span></pre>

<p>You can use a while-loop to iterate through the elements with the <code>Iterator</code> as follows:</p>
<pre class="color-example">
List&lt;String&gt; lst = new ArrayList&lt;&gt;();   <span class="color-comment">// JDK 7 type inference</span>
lst.add(&quot;alpha&quot;);
lst.add(&quot;beta&quot;);
lst.add(&quot;charlie&quot;);
 
<span class="color-comment">// (1) Using the associated Iterator&lt;E&gt; to traverse through all elements
// Retrieve the Iterator associated with this List via the iterator() method</span>
Iterator&lt;String&gt; iter = lst.iterator();
<span class="color-comment">// Transverse thru this List via the Iterator</span>
while (iter.hasNext()) {
   <span class="color-comment">// Retrieve each element and process</span>
   String str = iter.next();
   System.out.println(str);
}

<span class="color-comment">//(2) Using the for-each loop (JDK 5) to traverse through all elements
// JDK 5 introduces a for-each loop to simplify the above</span>
for (str: lst) System.out.println(str);</pre>

<h5>The for-each Loop</h5>
<p>JDK 5 introduces a new for-each loop to simplify traversal of  a <code>Collection</code>, as shown in the above code.</p>


<h5>for-each Loop vs. <span class="font-code">Iterator</span></h5>

<p>The for-loop provides a convenience way to traverse through a collection of elements.  But it hides the <code>Iterator</code>, hence, you CANNOT remove (via <code>Iterator.remove()</code>) or replace the elements.</p>
<p>On the other hand, as the loop variable receives a &quot;cloned&quot; copy of the object reference, the enhanced for-loop can be used to modify  &quot;mutable&quot; elements (such as <code>StringBuilder</code>) via the &quot;cloned&quot; object references, but it cannot modify &quot;immutable&quot; objects (such as <code>String</code> and primitive wrapper classes) as new references are created.</p>

<h5>Example: Using Enhanced for-each Loop on Collection of &quot;Mutable&quot; Objects (such as <span class="font-code">StringBuilder</span>)</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
 
public class <strong>ForEachMutableTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">List&lt;StringBuilder&gt;</span> lst = new <span class="color-new">ArrayList&lt;&gt;</span>();
      lst.add(new StringBuilder(&quot;alpha&quot;));
      lst.add(new StringBuilder(&quot;beta&quot;));
      lst.add(new StringBuilder(&quot;charlie&quot;));
      System.out.println(lst);   <span class="color-comment">//</span><span class="color-output">[alpha, beta, charlie]</span>
 
      for (StringBuilder sb : lst) {
         sb.append(&quot;123&quot;);   <span class="color-comment">// can modify &quot;mutable&quot; objects</span>
      }
      System.out.println(lst);  <span class="color-comment">//</span><span class="color-output">[alpha123, beta123, charlie123]</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Example: Using Enhanced for-each loop on Collection of &quot;Immutable&quot; Objects (such as <span class="font-code">String</span>)</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
 
public class <strong>ForEachImmutableTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">List&lt;String&gt;</span> lst = new <span class="color-new">ArrayList&lt;&gt;</span>();
      lst.add(&quot;alpha&quot;);
      lst.add(&quot;beta&quot;);
      lst.add(&quot;charlie&quot;);
      System.out.println(lst);   <span class="color-comment">//<span class="color-output">[alpha, beta, charlie]</span></span>
 
      for (String str : lst) {
         str += &quot;change!&quot;;   <span class="color-comment">// cannot modify &quot;immutable&quot; objects</span>
      }
      System.out.println(lst);   <span class="color-comment">//<span class="color-output">[alpha, beta, charlie]</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4><span class="font-code">Collection&lt;E&gt;</span> Interface</h4>
<p>The  <code>Collection&lt;E&gt;</code>, which takes a generic type <code>E</code> and read as <code>Collection</code> of element of type <code>E</code>, is the <em>root</em> interface of the Collection Framework. It defines the common behaviors expected of all classes, such as how to add or remove an element, via the following <code>abstract</code> methods:</p>
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Collection&lt;E&gt;</span>
// Basic Operations</span>
abstract int <span class="color-new">size</span>()                        <span class="color-comment">// Returns the number of elements</span>
abstract boolean <span class="color-new">isEmpty</span>()                 <span class="color-comment">// Returns true if there is no element</span>

<span class="color-comment">// &quot;Individual Element&quot; Operations</span>
abstract boolean <span class="color-new">add</span>(E <em>element</em>)            <span class="color-comment">// Add the given <em>element</em></span>
abstract boolean <span class="color-new">remove</span>(Object <em>element</em>)    <span class="color-comment">// Removes the given <em>element</em>, if present</span>
abstract boolean <span class="color-new">contains</span>(Object <em>element</em>)  <span class="color-comment">// Returns true if this Collection contains the given <em>element</em></span>

<span class="color-comment">// &quot;Bulk&quot; (mutable) Operations</span>
abstract void <span class="color-new">clear</span>()                               <span class="color-comment">// Removes all the elements</span>
abstract boolean <span class="color-new">addAll</span>(Collection&lt;? extends E&gt; <em>c</em>)  <span class="color-comment">// Another Collection of E or E's subtypes</span>
abstract boolean <span class="color-new">containsAll</span>(Collection&lt;?&gt; <em>c</em>)       <span class="color-comment">// Another Collection of any types</span>
abstract boolean <span class="color-new">removeAll</span>(Collection&lt;?&gt; <em>c</em>)
abstract boolean <span class="color-new">retainAll</span>(Collection&lt;?&gt; <em>c</em>)
&nbsp;
<span class="color-comment">// Comparison - Objects that are equal shall have the same hashCode</span>
abstract boolean <span class="color-new">equals</span>(Object <em>o</em>)
abstract int <span class="color-new">hashCode</span>()
 
<span class="color-comment">// Array Operations</span>
abstract Object[] <span class="color-new">toArray</span>()       <span class="color-comment">// Convert to an Object array</span>
abstract &lt;T&gt; T[] <span class="color-new">toArray</span>(T[] <em>a</em>)   <span class="color-comment">// Convert to an array of the given type T</span>
</pre>

<p>Take note that many of these operations are mutable, i.e., they modify the <code>Collection</code> object. (In the Functional Programming introduced in JDK 8, operations are immutable and should not modify the source collection.)</p>

<h5>Collection of Primitives?</h5>

<p>A <code>Collection&lt;E&gt;</code> can only contain objects, not primitives (such as <code>int</code> or <code>double</code>). Primitive values are to be wrapped into objects (via the respective wrapper classes such as <code>Integer</code> and <code>Double</code>). JDK 5 introduces auto-boxing and auto-unboxing to simplify the wrapping and unwrapping processes. Read &quot;<a href="J5c_Collection.html#autoboxing">Auto-Boxing and Auto-Unboxing</a>&quot; section for example.</p>

<h4><span class="font-code">List&lt;E&gt;</span>, <span class="font-code">Set&lt;E&gt;</span> and <span class="font-code">Queue&lt;E&gt;</span>: Specialized Sub-Interfaces of <span class="font-code">Collection&lt;E&gt;</span></h4>

<p>In practice, we typically program on one of the <em>specialized</em> sub-interfaces of the <code>Collection&lt;E&gt;</code> interface: <code>List&lt;E&gt;</code>, <code>Set&lt;E&gt;</code>, or <code>Queue&lt;E&gt;</code>.</p>

<ul>
<li><code>List&lt;E&gt;</code>: models a<em> </em>resizable linear array, which allows <em>numerical indexed access</em>, with index starting from 0. <code>List&lt;E&gt;</code> can contain duplicate elements. Implementations of <code>List&lt;E&gt;</code> include <code>ArrayList&lt;E&gt;</code>, <code>LinkedList&lt;E&gt;</code>, <code>Vector&lt;E&gt;</code> and <code>Stack&lt;E&gt;</code>.</li>
<li><code>Set&lt;E&gt;</code>: models a mathematical set, where no duplicate elements are<em> </em>allowed.  Implementations of <code>Set&lt;E&gt;</code> include <code>HashSet&lt;E&gt;</code> and <code>LinkedHashSet&lt;E&gt;</code>. The sub-interface <code>SortedSet&lt;E&gt;</code> models an <em>ordered and sorted</em> set of elements, implemented by <code>TreeSet&lt;E&gt;</code>.</li>
<li><code>Queue&lt;E&gt;</code>: models queues such as First-in-First-out (FIFO) queue and priority queue. It sub-interface <code>Deque&lt;E&gt;</code> models queues that can be operated on both ends. Implementations include <code>PriorityQueue&lt;E&gt;</code>, <code>ArrayDeque&lt;E&gt;</code> and <code>LinkedList&lt;E&gt;</code>.</li>
</ul>

<p>The details of these sub-interfaces and implementations will be covered later in the implementation section.</p>

<h4><span class="font-code">Map&lt;K,V&gt;</span> Interface</h4>

<p>In Java, a <code>Map</code> (also known as associative array) contains a collection of key-value pairs. It is similar to <code>List</code> and array. But instead of an numerical key 0, 1, 2, ..., a <code>Map</code>'s key could be any arbitrary objects.</p>

<p>The interface <code>Map&lt;K,V&gt;</code>, which takes two generic types <code>K</code> and <code>V</code> (read as <code>Map</code> of key type <code>K</code> and value type <code>V</code>), is used as a collection of &quot;key-value pairs&quot;.  No duplicate key is allowed. Implementations include <code>HashMap&lt;K,V&gt;</code>, <code>Hashtable&lt;K,V&gt;</code> and <code>LinkedHashMap&lt;K,V&gt;</code>. Its sub-interface <code>SortedMap&lt;K,V&gt;</code> models an ordered and sorted map, based on its key, implemented in <code>TreeMap&lt;K,V&gt;</code>.</p>
<p>Take note that <code>Map&lt;K,V&gt;</code> is not a sub-interface of <code>Collection&lt;E&gt;</code>, as it involves a pair of objects for each element. The details will be covered later. </p>

<h3><span class="font-code">List</span> Interfaces, Implementations and Algorithms</h3>

<p>A <code>List&lt;E&gt;</code> models a resizable linear array, which supports <em>numerical indexed</em> access, with index starts from 0. Elements in a list can be retrieved and inserted at a specific index position based on an <code>int</code> index. It can contain <em>duplicate</em> elements. It can contain <code>null</code> elements. You can search a list, iterate through its elements, and perform operations on a selected range of values in the list.</p>
<p><code>List</code> is the most commonly-used data structure, as a resizable array.</p>

<img class="image-center" src="images/Collection_ListImplementation.png" alt="List Implementation"/>

<p>The <code>List&lt;E&gt;</code> interface declares the following <code>abstract</code> methods, in additional to its super-interfaces.  Since <code>List</code> has a positional index.  Operation such as <code>add()</code>, <code>remove()</code>, <code>set()</code> can be applied to an element at a specified index position.</p>

<pre class="color-syntax">
<span class="color-comment">// Methods inherited from Interface java.lang.<span class="color-new">Iterable&lt;E&gt;</span></span>
abstract Iterator&lt;E&gt; <span class="color-new">iterator</span>();

<span class="color-comment">// Methods inherited from Interface java.util.<span class="color-new">Collection&lt;E&gt;</span></span>
abstract int <span class="color-new">size</span>()
abstract boolean <span class="color-new">isEmpty</span>()
abstract boolean <span class="color-new">add</span>(E <em>element</em>)
abstract boolean <span class="color-new">remove</span>(Object <em>obj</em>)
abstract boolean <span class="color-new">contains</span>(Object <em>obj</em>)
abstract void <span class="color-new">clear</span>();
......

<span class="color-comment">// Interface java.util.<span class="color-new">List&lt;E&gt;</span>
// Operations at a specified index position</span>
abstract void <span class="color-new">add</span>(int <em>index</em>, E <em>element</em>)    <span class="color-comment">// add at index</span>
abstract E <span class="color-new">set</span>(int <em>index</em>, E <em>element</em>)       <span class="color-comment">// replace at index</span>
abstract E <span class="color-new">get</span>(int <em>index</em>)                  <span class="color-comment">// retrieve at index without remove</span>
abstract E <span class="color-new">remove</span>(int <em>index</em>)               <span class="color-comment">// remove at index</span>
abstract int <span class="color-new">indexOf</span>(Object <em>obj</em>)
abstract int <span class="color-new">lastIndexOf</span>(Object <em>obj</em>)

<span class="color-comment">// Operations on a range fromIndex (inclusive) toIndex (exclusive)</span>
abstract List&lt;E&gt; <span class="color-new">subList</span>(int <em>fromIndex</em>, int <em>toIndex</em>)</pre>

<p>The <code>abstract</code> superclass <code>AbstractList</code> provides implementations to many of the <code>abstract</code> methods declared in <code>List</code> and its super-types <code>Collection</code> and <code>Iterable</code>.  However, some methods such as <code>get(int index)</code> remains <code>abstract</code>.  These methods are implemented by the concrete subclasses such as <code>ArrayList</code> and <code>Vector</code>.</p>

<p>[TODO] Example</p>

<h4><span class="font-code">ArrayList&lt;E&gt;</span> and <span class="font-code">Vector&lt;E&gt;</span>: Implementation Classes for <span class="font-code">List&lt;E&gt;</span></h4>
<p><code>ArrayList&lt;E&gt;</code> is the <em>best all-around </em>implementation of the <code>List&lt;E&gt;</code> interface.  Many useful methods are already implemented in <code>AbstractList</code> but overridden for efficiency in <code>ArrayList</code> (e.g., <code>add()</code>, <code>remove()</code>, <code>set()</code> etc.).</p>

<p><code>Vector&lt;E&gt;</code> is a <em>legacy</em> class (since JDK 1.0), which is retrofitted to conform to the Collection Framework (in JDK 1.2).  <code>Vector</code> is a <em>synchronized</em> thread-safe implementation of the <code>List</code> interface. It also contains additional legacy methods (e.g., <code>addElement()</code>, <code>removeElement()</code>, <code>setElement()</code>, <code>elementAt()</code>, <code>firstElement()</code>, <code>lastElement()</code>, <code>insertElementAt()</code>).  There is no reason to use these legacy methods - other than to maintain backward compatibility.</p>

<p><code>ArrayList</code> is not synchronized.  The integrity of <code>ArrayList</code> instances is not guaranteed under multithreading.  Instead, it is the programmer's responsibility to ensure synchronization.  On the other hand, <code>Vector</code> is synchronized internally. Read &quot;<a href="J5c_Collection.html#synchronized_collection">Synchronized Collection</a>&quot; if you are dealing with multi-threads.</p>

<p><span class="line-heading">Java Performance Tuning Tip:</span>  Synchronization involves overheads.  Hence, if synchronization is not an issue, you should use <code>ArrayList</code> instead of <code>Vector</code> for better performance.</p>

<p>[TODO] Example</p>

<h4><span class="font-code">Stack&lt;E&gt;</span>: Implementation Class for <span class="font-code">List&lt;E&gt;</span></h4>

<p><code>Stack&lt;E&gt;</code> is a last-in-first-out queue (LIFO) of elements.  <code>Stack</code> extends <code>Vector</code>, which is a synchronized resizable array, with five additional methods:</p>
<pre class="color-syntax">
<span class="color-comment">// Class java.util.<span class="color-new">Stack&lt;E&gt;</span></span>
E <span class="color-new">push</span>(E <em>element</em>)       <span class="color-comment">// pushes the specified element onto the top of the stack</span>
E <span class="color-new">pop</span>()         <span class="color-comment">        // removes and returns the element at the top of the stack</span>
E <span class="color-new">peek</span>()        <span class="color-comment">        // returns the element at the top of stack without removing</span>
boolean <span class="color-new">empty</span>()         <span class="color-comment">// tests if this stack is empty</span>
int <span class="color-new">search</span>(Object <em>obj</em>)  <span class="color-comment">// returns the distance of the specified object from the top
                        //  of stack (distance of 1 for TOS), or -1 if not found</span>
</pre>
  
<p>[TODO] Example</p>

<h4><span class="font-code">LinkedList&lt;E&gt;</span>: Implementation Class for <span class="font-code">List&lt;E&gt;</span></h4>

<p><code>LinkedList&lt;E&gt;</code> is a double-linked list implementation of the <code>List&lt;E&gt;</code> interface, which is efficient for insertion and deletion of elements, in the expense of more complex structure.</p>
<p><code>LinkedList&lt;E&gt;</code> also implements <code>Queue&lt;E&gt;</code> and <code>Deque&lt;E&gt;</code> interfaces, and can be processed from both ends of the queue. It can serve as FIFO or LIFO queue.</p>

<p>[TODO] Example</p>

<h4>Converting a <span class="font-code">List</span> to an Array: <span class="font-code">toArray()</span></h4>
<p>The super-interface <code>Collection&lt;E&gt;</code> defines a method called <code>toArray()</code> to create a fixed-length array based on this list. The returned array is free for modification.</p>

<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Collection&lt;E&gt;</span></span>
abstract Object[] <span class="color-new">toArray</span>()      <span class="color-comment">// Object[] version</span>
abstract &lt;T&gt; T[] <span class="color-new">toArray</span>(T[] <em>a</em>)  <span class="color-comment">// Generic type version</span>
</pre>

<h5>Example - <span class="font-code">List</span> to array</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
public class <strong>ListToArrayTest</strong> {
   public static void main(String[] args) {
      List&lt;String&gt; lst = new ArrayList&lt;&gt;();
      lst.add(&quot;alpha&quot;);
      lst.add(&quot;beta&quot;);
      lst.add(&quot;charlie&quot;);
 
      <span class="color-comment">// Use the Object[] version</span>
      Object[] strArray1 = lst.toArray();
      System.out.println(Arrays.toString(strArray1));   <span class="color-comment">//</span><span class="color-output">[alpha, beta, charlie]</span>
 
      <span class="color-comment">// Use the generic type version - Need to specify the type in the argument</span>
      String[] strArray2 = lst.toArray(new String[lst.size()]);  <span class="color-comment">// pass a String array of the same size</span>
      System.out.println(strArray2.length);  <span class="color-comment">//<span class="color-output">3</span></span><br />      strArray2[0] = &quot;delta&quot;;   <span class="color-comment">// modify the returned array</span>
      System.out.println(Arrays.toString(strArray2));   <span class="color-comment">//</span><span class="color-output">[delta, beta, charlie]</span>
      System.out.println(lst);  <span class="color-comment">//<span class="color-output">[alpha, beta, charlie]</span> (no change in the original list)</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Using an Array as a <span class="font-code">List</span>: <span class="font-code">Arrays.asList()</span></h4>

<p>The utility class <code>java.util.Arrays</code> provides a <code>static</code> method <code>Arrays.asList()</code> to convert an array into a <code>List&lt;T&gt;</code>. However, change to the list write-thru the array and vice versa. Take note that the name of the method is <code>asList</code> and not <code>toList</code>.</p>

<pre class="color-syntax">
<span class="color-comment">// Returns a fixed-size list backed by the specified array.
// Change to the list write-thru to the array.</span>
public static &lt;T&gt; List&lt;T&gt; <strong>asList</strong>(T[] <em>a</em>)</pre>

<h5>Example - Array as <span class="font-code">List</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
public class <strong>TestArrayAsList</strong> {
   public static void main(String[] args) {
      String[] strs = {&quot;alpha&quot;, &quot;beta&quot;, &quot;charlie&quot;};
      System.out.println(Arrays.toString(strs));   <span class="color-comment">//</span><span class="color-output">[alpha, beta, charlie]</span>
 
      List&lt;String&gt; lst = <span class="color-new">Arrays.asList</span>(strs);
      System.out.println(lst);  <span class="color-comment">//</span><span class="color-output">[alpha, beta, charlie]</span>
 
      <span class="color-comment">// Changes in array or list write thru</span>
      strs[0] += &quot;88&quot;;
      lst.set(2, lst.get(2) + &quot;99&quot;);
      System.out.println(Arrays.toString(strs)); <span class="color-comment">//</span><span class="color-output">[alpha88, beta, charlie99]</span>
      System.out.println(lst);  <span class="color-comment">//</span><span class="color-output">[alpha88, beta, charlie99]</span>
 
      <span class="color-comment">// Initialize a list using an array</span>
      List&lt;Integer&gt; lstInt = Arrays.asList(22, 44, 11, 33);
      System.out.println(lstInt);  <span class="color-comment">//</span><span class="color-output">[22, 44, 11, 33]</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Comparison of <span class="font-code">ArrayList</span>, <span class="font-code">Vector</span>, <span class="font-code">LinkedList</span> and <span class="font-code">Stack</span></h4>
<p>[TODO] Example on benchmarking <code>ArrayList</code>, <code>Vector</code>, <code>LinkedList</code>, and <code>Stack</code></p>

<h4><span class="font-code">List</span>'s Algorithms</h4>

<p>The utility class <code>java.util.Collections</code> provides many useful algorithms for collection. Some work for any <code>Collection</code>s; while many work for <code>List</code>s (with numerical index) only.</p>

<h5>Mutating Operators</h5>

<pre class="color-syntax">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Collections</span></span>
static void <span class="color-new">swap</span>(List&lt;?&gt; lst, int i, int j)   <span class="color-comment">// Swaps the elements at the specified indexes</span>
static void <span class="color-new">shuffle</span>(List&lt;?&gt; lst)              <span class="color-comment">// Randomly permutes the List</span>
static void <span class="color-new">shuffle</span>(List&lt;?&gt; lst, Random rnd)  <span class="color-comment">// Randomly permutes the List using the specified source or randomness</span>
static void <span class="color-new">rotate</span>(List&lt;?&gt; lst, int distance) <span class="color-comment">// Rotates the elements by the specified distance</span>
static void <span class="color-new">reverse</span>(List&lt;?&gt; lst)              <span class="color-comment">// Reverses the order of elements</span>
static &lt;T&gt; void <span class="color-new">fill</span>(List&lt;? super T&gt;, T obj)  <span class="color-comment">// Replaces all elements with the specified object</span>
static &lt;T&gt; void <span class="color-new">copy</span>(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)  <span class="color-comment">// Copies all elements from src to dest</span>
static &lt;T&gt; boolean <span class="color-new">replaceAll</span>(List&lt;T&gt; lst, T oldVal, T newVal)     <span class="color-comment">// Replaces all occurrences</span></pre>

<p>[TODO] example</p>

<h5>Sub-List (Range-View) Operations</h5>

<p>The <code>List&lt;E&gt;</code> supports range-view operation via <code>.subList()</code> as follows. The returned <code>List</code> is backup by the given <code>List</code>, so change in the returned <code>List</code> are reflected in the original <code>List</code>.</p>
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">List&lt;E&gt;</span></span>
List&lt;E&gt; <span class="color-new">subList</span>(int fromIdx, int toIdx)</pre>


<p>The Utility class <code>Collections</code> supports these sub-list operations:</p>
<pre class="color-syntax">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Collections</span></span>
static int <span class="color-new">indexOfSubList</span>(List&lt;?&gt; src, List&lt;?&gt; target)
static int <span class="color-new">lastIndexOfSubList</span>(List&lt;?&gt; src, List&lt;?&gt; target)</pre>

<p>For example,</p>
<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
public class <strong>SubListTest</strong> {
   public static void main(String[] args) {
      List&lt;Integer&gt; lst = new ArrayList&lt;&gt;();
      for (int i = 0; i &lt; 10; ++i) lst.add(i * 10);
      System.out.println(lst);  <span class="color-comment">//<span class="color-output">[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span>

      lst.<span class="color-new">subList</span>(3, 6).clear();  <span class="color-comment">// Remove the sublist</span>
      System.out.println(lst);    <span class="color-comment">//<span class="color-output">[0, 10, 20, 60, 70, 80, 90]</span></span>

      System.out.println(lst.<span class="color-new">subList</span>(2, 5).indexOf(60));  <span class="color-comment">//<span class="color-output">1</span> (of the subList)</span>

      List&lt;Integer&gt; lst2 = List.of(20, 60, 70);  <span class="color-comment">// JDK 9</span>
      System.out.println(<span class="color-new">Collections.indexOfSubList</span>(lst, lst2));      <span class="color-comment">//<span class="color-output">2</span></span>
      System.out.println(<span class="color-new">Collections.lastIndexOfSubList</span>(lst, lst2));  <span class="color-comment">//<span class="color-output">2</span></span>
   }
}</pre>


<h5>Searching, Sorting and Ordering</h5>

<p>The utility class <code>Collections</code> provides these <code>static</code> methods for searching, sorting and ordering (max, min) of <code>List</code>:</p>

<pre class="color-syntax">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Collections</span>
</span>static &lt;T&gt; int <span class="color-new">binarySearch</span>(List&lt;? extends T&gt; lst, T key, Comparator&lt;? super T&gt; comp)
static &lt;T&gt; int <span class="color-new">binarySearch</span>(List&lt;? extends Comparable&lt;? super T&gt;&gt; lst, T key)
   <span class="color-comment">// Searches for the specified key using binary search</span>

static &lt;T&gt; void <span class="color-new">sort</span>(List&lt;T&gt; lst, Comparator&lt;? super T&gt; comp)
static &lt;T extends Comparable&lt;? super T&gt;&gt; void <span class="color-new">sort</span>(List&lt;T&gt; lst)

static &lt;T&gt; T <span class="color-new">max</span>(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)
static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T <span class="color-new">max</span>(Collection&lt;? extends T&gt; coll)
static &lt;T&gt; T <span class="color-new">min</span>(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)
static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T <span class="color-new">min</span>(Collection&lt;? extends T&gt; coll)</pre>

<p>Each of these algorithms has two versions:</p>
<ol>
<li>Requires a <code>Comparator</code> object with a <code>compare()</code> method to determine the order of the elements.</li>
<li>Requires a <code>List</code> which implement <code>Comparable</code> interface, with a method <code>compareTo()</code> to determine the order of elements.</li>
</ol>

<p>We shall elaborate in the next section.</p>

<h3 id="ordering"><span class="font-code">List</span> Ordering/Searching/Sorting with <span class="font-code">Comparable&lt;T&gt;/Comparator&lt;T&gt;</span></h3>

<p><em>Ordering</em> is needed in these two situations:</p>
<ol>
<li>To <em>sort</em> a <code>Collection</code> or an array (using the <code>Collections.sort()</code> or <code>Arrays.sort()</code> methods), an ordering specification is needed.</li>

<li>Some <code>Collection</code>s, in particular, <code>SortedSet</code> (<code>TreeSet</code>) and <code>SortMap</code> (<code>TreeMap</code>), are <em>ordered</em>.  That is, the objects are stored according to a specified order.</li>

</ol>

<p>There are two ways to specify the ordering of objects:</p>

<ol>
<li>Create a special <code>java.util.Comparator&lt;T&gt;</code> object, with a method <code>compare()</code> to specify the ordering of comparing two objects.</li>
<li>Make the objects implement the <code>java.lang.Comparable&lt;T&gt;</code> interface, and override the <code>compareTo()</code> method to specify the ordering of comparing two objects.</li>
</ol>

<h4><span class="font-code">Comparable&lt;T&gt;</span> Interface</h4>
<p>A <code>java.lang.Comparable&lt;T&gt;</code> interface specifies how two objects are to be compared for ordering. It defines one <code>abstract</code> method:</p>

<pre class="color-syntax">
<span class="color-comment">// Interface java.lang.<span class="color-new">Comparable&lt;T&gt;</span></span>
abstract int <span class="color-new">compareTo</span>(T <em>o</em>)  <span class="color-comment">// Returns a negative integer, zero, or a positive integer 
                             //  if this object is less than, equal to, or greater than the given object</span></pre>

<p>This ordering is referred to as the class's <em>natural ordering</em>.</p>



<p>It is strongly recommended that <code>compareTo()</code> be consistent with <code>equals()</code> and <code>hashCode()</code> (inherited from <code>java.lang.Object</code>):</p>

<ol>
<li>If <code>compareTo()</code> returns a zero, <code>equals()</code> should return <code>true</code>.</li>
<li>If <code>equals()</code> returns <code>true</code>, <code>hashCode()</code> shall produce the same <code>int</code>.</li>
</ol>

<p>All the eight primitive wrapper classes (<code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code> and <code>Boolean</code>) implement <code>Comparable&lt;T&gt;</code> interface, with the <code>compareTo()</code> uses the numerical order.</p>
<p>The <code>String</code> class also implements <code>Comparable&lt;String&gt;</code> interface, which compares two strings lexicographically based on the Unicode value of each character in the strings. The uppercase letters are smaller than the lowercase counterparts.</p>

<h5>Example 1: Searching/Sorting <span class="font-code">String</span> and Primitive Wrapper Types, which implement <span class="font-code">Comparable&lt;T&gt;</span></h5>

<p>The utility class <code>java.util.Arrays</code> and <code>java.util.Collections</code> provide many <code>static</code> method for the various algorithms such as sorting and searching. In this example, we use the <code>Arrays.sort()</code> and <code>Collections.sort()</code> methods to sort an array of <code>String</code>s and a <code>List</code> of <code>Integer</code>s, based on their <code>Comparable&lt;T&gt;</code>'s <code>compareTo()</code> method.</p>


<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td>
<pre>
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class <strong>StringPrimitiveComparableTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Sort/search an &quot;array&quot; of Strings using Arrays.sort() and Arrays.binarySearch()</span>
      <span class="color-comment">//   using ordering specified in compareTo()</span>
      String[] strArray = {&quot;Hello&quot;, &quot;hello&quot;, &quot;Hi&quot;, &quot;HI&quot;, &quot;Hello&quot;};  <span class="color-comment">// has duplicate elements</span>

      <span class="color-new">Arrays.sort</span>(strArray);  <span class="color-comment">// sort in place and mutable</span>
      System.out.println(<span class="color-new">Arrays.toString</span>(strArray));  <span class="color-comment">//<span class="color-output">[HI, Hello, Hello, Hi, hello]</span></span>

      <span class="color-comment">// The array must be sorted for binarySearch()</span>
      System.out.println(<span class="color-new">Arrays.binarySearch</span>(strArray, &quot;Hello&quot;)); <span class="color-comment">//<span class="color-output">2</span></span>
      System.out.println(<span class="color-new">Arrays.binarySearch</span>(strArray, &quot;HELLO&quot;)); <span class="color-comment">//<span class="color-output">-1</span> (insertion at index 0)</span>

      <span class="color-comment">// Sort/search a List&lt;Integer&gt; using Collections.sort() and Collections.binarySearch()</span>
      List&lt;Integer&gt; lst = new ArrayList&lt;&gt;();
      lst.add(22);  <span class="color-comment">// int auto-box to Integer</span>
      lst.add(11);
      lst.add(44);
      lst.add(11);  <span class="color-comment">// duplicate element</span>
      Collections.sort(lst);    <span class="color-comment">// sort in place and mutable</span>
      System.out.println(lst);  <span class="color-comment">//<span class="color-output">[11, 11, 22, 44]</span></span>
      System.out.println(Collections.binarySearch(lst, 22)); <span class="color-comment">//<span class="color-output">2</span></span>
      System.out.println(Collections.binarySearch(lst, 35)); <span class="color-comment">//<span class="color-output">-4</span> (insertion at index 3)</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Example 2: Custom Implementation of <span class="font-code">Comparable&lt;T&gt;</span></h5>

<p>Let's create a subclass of <code>Person</code> (see &quot;<code>Person.java</code>&quot; above), called ComparablePerson which implements <code>Comparable&lt;Person&gt;</code> interface, and try out the <code>Collections.sort()</code> and <code>Collections.binarySearch()</code> methods.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11</pre>
</td>
<td>
<pre>
public class <strong>ComparablePerson extends Person implements Comparable&lt;Person&gt;</strong> {
   public ComparablePerson(String name, int age) {   <span class="color-comment">// constructor</span>
      super(name, age);
   }

   <span class="color-comment">// Order by the name strings, case insensitive</span>
   @Override
   public <span class="color-new">int compareTo(Person p)</span> {
      return this.getName().<span class="color-new">compareToIgnoreCase</span>(p.getName());  <span class="color-comment">// via String's compareToIgnoreCase()</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>&nbsp;</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
public class <strong>ComparablePersonTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">List&lt;ComparablePerson&gt;</span> pLst = new ArrayList&lt;&gt;();
      pLst.add(new ComparablePerson(&quot;Peter&quot;, 21));
      pLst.add(new ComparablePerson(&quot;Paul&quot;, 18));
      pLst.add(new ComparablePerson(&quot;John&quot;, 60));
      System.out.println(pLst);  <span class="color-comment">//<span class="color-output">[Peter(21), Paul(18), John(60)]</span></span>

      <span class="color-comment">// Use compareTo() for ordering</span>
      <span class="color-new">Collections.sort</span>(pLst);    <span class="color-comment">// sort in place, mutable</span>
      System.out.println(pLst);  <span class="color-comment">//<span class="color-output">[John(60), Paul(18), Peter(21)]</span></span>

      <span class="color-comment">// Use compareTo() too</span>
      System.out.println(<span class="color-new">Collections.binarySearch</span>(pLst, new ComparablePerson(&quot;PAUL&quot;, 18)));  <span class="color-comment">//<span class="color-output">1</span></span>
      System.out.println(<span class="color-new">Collections.binarySearch</span>(pLst, new ComparablePerson(&quot;PAUL&quot;, 16)));  <span class="color-comment">//<span class="color-output">1</span></span>
      System.out.println(<span class="color-new">Collections.binarySearch</span>(pLst, new ComparablePerson(&quot;Kelly&quot;, 18))); <span class="color-comment">//<span class="color-output">-2</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4><span class="font-code">Comparator&lt;T&gt;</span> Interface</h4>

<p>Besides the <code>java.lang.Comparable&lt;T&gt;</code> for the <em>natural ordering</em>, you can pass a <code>java.util.Comparator&lt;T&gt;</code> object into the sorting methods (<code>Collections.sort()</code> or <code>Arrays.sort()</code>) to provide precise control over the ordering. The <code>Comparator&lt;T&gt;</code> will override the <code>Comparable&lt;T&gt;</code>, if available.</p>

<p>The <code>Comparator&lt;T&gt;</code> interface declares one <code>abstract</code> method (known as Functional Interface in JDK 8):</p>
<pre class="color-syntax">
<span class="color-comment">// java.util.<span class="color-new">Comparator&lt;T&gt;</span></span>
abstract int <span class="color-new">compare</span>(T <em>o1</em>, T <em>o2</em>)  <span class="color-comment">// Returns a negative integer, zero, or a positive integer as the 
                                  //  first argument is less than, equal to, or greater than the second.</span></pre>

<p>Take note that you need to construct an instance of <code>Comparator&lt;T&gt;</code>, and invoke <code>compare()</code> to compare <code>o1</code> and <code>o2</code>. [In the earlier <code>Comparable&lt;T&gt;</code>, the method is called <code>compareTo()</code> and it takes only one argument, i.e., this object compare to the given object.]</p>

<h5>Example 3: Using Customized <span class="font-code">Comparator&lt;T&gt;</span> for <span class="font-code">String</span> and <span class="font-code">Integer</span></h5>

<p>In this example, instead of using the natural <code>Comparable&lt;T&gt;</code>, we define our customized <code>Comparator&lt;T&gt;</code> for <code>String</code>s and <code>Integer</code>s. We can do this via any of the following ways:</p>
<ol>
<li>A named inner class</li>
<li>An anonymous inner class</li>
<li>Lambda Expressions (JDK 8)</li>
</ol>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

public class <strong>StringPrimitiveComparatorTest</strong> {
   <span class="color-comment">// Define an &quot;named inner class&quot; implements Comparator&lt;String&gt;</span>
   <span class="color-comment">//   to order strings in case-insensitive manner</span>
   public static <span class="color-new">class StringComparator implements Comparator&lt;String&gt;</span> {
      @Override
      public int <span class="color-new">compare</span>(String s1, String s2) {
         return s1.compareToIgnoreCase(s2);
      }
   }

   public static void main(String[] args) {
      <span class="color-comment">// Use a customized Comparator for Strings</span>
      Comparator&lt;String&gt; strComp = new StringComparator();

      <span class="color-comment">// Sort and search an &quot;array&quot; of Strings</span>
      String[] array = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;HI&quot;, &quot;hello&quot;, &quot;Hello&quot;};  <span class="color-comment">// with duplicate</span>
      <span class="color-new">Arrays.sort(array, strComp)</span>;
      System.out.println(Arrays.toString(array));  <span class="color-comment">//<span class="color-output">[Hello, hello, Hello, Hi, HI]</span></span>
      System.out.println(Arrays.binarySearch(array, &quot;Hello&quot;, strComp)); <span class="color-comment">//<span class="color-output">2</span></span>
      System.out.println(Arrays.binarySearch(array, &quot;HELLO&quot;, strComp)); <span class="color-comment">//<span class="color-output">2</span> (case-insensitive)</span>

      <span class="color-comment">// Use an &quot;anonymous inner class&quot; to implement Comparator&lt;Integer&gt;</span>
      Comparator&lt;Integer&gt; intComp = <span class="color-new">new Comparator&lt;Integer&gt;() {
         @Override
         public int compare(Integer i1, Integer i2) {
            return i1%10 - i2%10;
         }
      }</span>;

      <span class="color-comment">// Sort and search a &quot;List&quot; of Integers</span>
      List&lt;Integer&gt; lst = new ArrayList&lt;Integer&gt;();
      lst.add(42);  <span class="color-comment">// int auto-box Integer</span>
      lst.add(21);
      lst.add(34);
      lst.add(13);
      <span class="color-new">Collections.sort(lst, intComp)</span>;
      System.out.println(lst);  <span class="color-comment">//<span class="color-output">[21, 42, 13, 34]</span></span>
      System.out.println(Collections.binarySearch(lst, 22, intComp)); <span class="color-comment">//<span class="color-output">1</span></span>
      System.out.println(Collections.binarySearch(lst, 35, intComp)); <span class="color-comment">//<span class="color-output">-5</span> (insertion at index 4)</span>
   }
}</pre>

<p>Try: Modify the <code>Comparator</code> to sort in A, a ,B, b, C, c ... (uppercase letter before the lowercase).</p>

<p>Notes: You can use Lambda Expressions (JDK 8) to shorten this code, as follows:</p>

<pre class="color-example">
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class <strong>StringPrimitiveComparatorJ8Test</strong> {  <span class="color-comment">// JDK 8</span>
   public static void main(String[] args) {
      <span class="color-comment">// Use a customized Comparator for Strings</span>
      <span class="color-new">Comparator&lt;String&gt; strComp = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);</span>
         <span class="color-comment">// The lambda expression create an instance of an anonymous inner class implements
         //   Comparator&lt;String&gt; with the body of the single-abstract-method compare()</span>

      <span class="color-comment">// Sort and search an &quot;array&quot; of Strings</span>
      String[] array = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;HI&quot;, &quot;hello&quot;, &quot;Hello&quot;};  <span class="color-comment">// with duplicate</span>
      Arrays.sort(array, strComp);
      System.out.println(Arrays.toString(array));  <span class="color-comment">//[Hello, hello, Hello, Hi, HI]</span>
      System.out.println(Arrays.binarySearch(array, &quot;Hello&quot;, strComp)); <span class="color-comment">//2</span>
      System.out.println(Arrays.binarySearch(array, &quot;HELLO&quot;, strComp)); <span class="color-comment">//2 (case-insensitive)</span>

      <span class="color-comment">// Use a customized Comparator for Integers</span>
      <span class="color-new">Comparator&lt;Integer&gt; intComp = (i1, i2) -&gt; i1%10 - i2%10;</span>

      <span class="color-comment">// Sort and search a &quot;List&quot; of Integers</span>
      List&lt;Integer&gt; lst = new ArrayList&lt;Integer&gt;();
      lst.add(42);  <span class="color-comment">// int auto-box Integer</span>
      lst.add(21);
      lst.add(34);
      lst.add(13);
      Collections.sort(lst, intComp);
      System.out.println(lst);  <span class="color-comment">//[21, 42, 13, 34]</span>
      System.out.println(Collections.binarySearch(lst, 22, intComp)); <span class="color-comment">//1</span>
      System.out.println(Collections.binarySearch(lst, 35, intComp)); <span class="color-comment">//-5 (insertion at index 4)</span>
   }
}</pre>

<p>More example at &quot;<a href="JDK8_Lambda.html#ComparatorLambda">Example: Comparator Lambda</a>&quot;.</p>

<h5>Example 4: Using Customized <span class="font-code">Comparator&lt;Person&gt;</span> for <span class="font-code">Person</span> Objects</h5>

<p><span class="line-heading"><span class="font-code">Person.java</span></span>: See above</p>
<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Collections;
public class <strong>ComparatorPersonTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pLst = new ArrayList&lt;&gt;();
      pLst.add(new Person(&quot;Peter&quot;, 21));
      pLst.add(new Person(&quot;Paul&quot;, 18));
      pLst.add(new Person(&quot;John&quot;, 60));
      System.out.println(pLst);  <span class="color-comment">//<span class="color-output">[Peter(21), Paul(18), John(60)]</span></span>

      <span class="color-comment">// Using an anonymous inner class</span>
      <span class="color-new">Comparator&lt;Person&gt; comp = new Comparator&lt;&gt;() {
         @Override
         public int compare(Person p1, Person p2) {
            return p1.getName().compareToIgnoreCase(p2.getName());
         }
      };</span>

      <span class="color-comment">// Use compareTo() for ordering</span>
      <span class="color-new">Collections.sort</span>(pLst, comp);
      System.out.println(pLst);  <span class="color-comment">//<span class="color-output">[John(60), Paul(18), Peter(21)]</span></span>

      <span class="color-comment">// Use compareTo() too</span>
      System.out.println(<span class="color-new">Collections.binarySearch</span>(pLst, new Person(&quot;PAUL&quot;, 18), comp));  <span class="color-comment">//1</span>
      System.out.println(<span class="color-new">Collections.binarySearch</span>(pLst, new Person(&quot;PAUL&quot;, 16), comp));  <span class="color-comment">//1</span>
      System.out.println(<span class="color-new">Collections.binarySearch</span>(pLst, new Person(&quot;Kelly&quot;, 18), comp)); <span class="color-comment">//-2</span>

      <span class="color-comment">// Using JDK 8 Lambda Expression to create an instance of anonymous inner class</span>
      <span class="color-comment">//   implements Comparator&lt;Person&gt;</span>
      pLst.add(new Person(&quot;Janes&quot;, 30));
      System.out.println(pLst);  <span class="color-comment">//<span class="color-output">[John(60), Paul(18), Peter(21), Janes(30)]</span></span>
      <span class="color-new">Collections.sort</span>(pLst,
            <span class="color-new">(p1, p2) -&gt; p1.getName().toLowerCase().compareTo(p2.getName().toLowerCase())</span>);
      System.out.println(pLst);  <span class="color-comment">//<span class="color-output">[Janes(30), John(60), Paul(18), Peter(21)]</span></span>
   }
}</pre>

<h3><span class="font-code">Set&lt;E&gt;</span> Interfaces, Implementations and Algorithms</h3>

<p>The <code>Set&lt;E&gt;</code> interface models a mathematical set, where no duplicate elements are allowed (e.g., playing cards). It may contain a single <code>null</code> element.</p>

<img class="image-center" src="images/Collection_SetImplementation.png" alt="Set Implementation"/>

<p>The <code>Set&lt;E&gt;</code> interface declares the following abstract methods. The insertion, deletion and inspection methods returns <code>false</code> if the operation fails, instead of throwing an exception.</p>

<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Set&lt;E&gt;</span></span>
abstract boolean <span class="color-new">add</span>(E <em>o</em>)           <span class="color-comment">// adds the specified element if it is not already present</span>
abstract boolean <span class="color-new">remove</span>(Object <em>o</em>)   <span class="color-comment">// removes the specified element if it is present</span>
abstract boolean <span class="color-new">contains</span>(Object <em>o</em>) <span class="color-comment">// returns true if it contains o</span>
 
<span class="color-comment">// Set operations</span>
abstract boolean <span class="color-new">addAll</span>(Collection&lt;? extends E&gt; <em>c</em>) <span class="color-comment">// Set union</span>
abstract boolean <span class="color-new">retainAll</span>(Collection&lt;?&gt; <em>c</em>)        <span class="color-comment">// Set intersection</span>
</pre>
 
<p>The implementations of <code>Set&lt;E&gt;</code> interface include:</p>
<ul>
<li><code>HashSet&lt;E&gt;</code>:  Stores the elements in a hash table (hashed via the <code>hashcode()</code>). <code>HashSet</code> is <em>the best all-round implementation</em> for <code>Set</code>.</li>
<li><code>LinkedHashSet&lt;E&gt;</code>:  Stores the elements in a linked-list hash table for better efficiency in insertion and deletion. The element are hashed via the <code>hashCode()</code> and arranged in the linked list according to the insertion-order.</li>
<li><code>TreeSet&lt;E&gt;</code>:  Also implements sub-interfaces <code>NavigableSet</code> and <code>SortedSet</code>. Stores the elements in a red-black tree data structure, which are sorted and navigable. Efficient in search, add and remove operations (in <code>O(log(n))</code>).</li>
</ul>

<h4><span class="font-code">HashSet&lt;E&gt;</span> By Example</h4>

<p>Let's write a <code>Book</code> class, and create a <code>Set</code> of <code>Book</code> objects.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td>
<td>
<pre>
public class <strong>Book</strong> {
   private int id;
   private String title;
 
   public Book(int id, String title) {  <span class="color-comment">// constructor</span>
      this.id = id;
      this.title = title;
   }
 
   @Override
   public String toString() {  <span class="color-comment">// describe itself</span>
      return id + &quot;: &quot; + title;
   }
 
   <span class="color-comment">// Two books are equal if they have the same id</span>
   @Override
   public boolean equals(Object o) {
      return o != null &amp;&amp; o instanceof Book &amp;&amp; this.id == ((Book)o).id;
   }
 
   <span class="color-comment">// To be consistent with equals(). Two objects which are equal have the same hash code.</span>
   @Override
   public int hashCode() {
      return id;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>We need to provide an <code>equals()</code> method, so that the <code>Set</code> implementation can test for equality and duplication. In this example, we choose the <code>id</code> as the distinguishing feature. We override <code>equals()</code> to return <code>true</code> if two books have the same <code>id</code>. We also override the <code>hashCode()</code> to be consistent with <code>equals()</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre>
</td>
<td>
<pre>
import java.util.HashSet;
import java.util.Set;
public class <strong>HashSetTest</strong> {
   public static void main(String[] args) {
      Book book1 = new Book(1, &quot;Java for Dummies&quot;);
      Book book1Dup = new Book(1, &quot;Java for the Dummies&quot;); <span class="color-comment">// same id as above</span>
      Book book2 = new Book(2, &quot;Java for more Dummies&quot;);
      Book book3 = new Book(3, &quot;more Java for more Dummies&quot;);
 
      Set&lt;Book&gt; set1 = new HashSet&lt;Book&gt;();
      set1.add(book1);
      set1.add(book1Dup); <span class="color-comment">// duplicate id, not added</span>
      set1.add(book1);    <span class="color-comment">// added twice, not added</span>
      set1.add(book3);
      set1.add(null);     <span class="color-comment">// Set can contain a null</span>
      set1.add(null);     <span class="color-comment">// but no duplicate</span>
      set1.add(book2);
      System.out.println(set1);
<span class="color-comment">      //<span class="color-output">[null, 1: Java for Dummies, 2: Java for more Dummies, 3: more Java for more Dummies]</span></span>
 
      set1.remove(book1);
      set1.remove(book3);
      System.out.println(set1); <span class="color-comment">//</span><span class="color-output">[null, 2: Java for more Dummies]</span>
 
      Set&lt;Book&gt; set2 = new HashSet&lt;Book&gt;();
      set2.add(book3);
      System.out.println(set2); <span class="color-comment">//</span><span class="color-output">[3: more Java for more Dummies]</span>

      set2.addAll(set1);        <span class="color-comment">// &quot;union&quot; with set1</span>
      System.out.println(set2); <span class="color-comment">//</span><span class="color-output">[null, 2: Java for more Dummies, 3: more Java for more Dummies]</span>
 
      set2.remove(null);
      System.out.println(set2); <span class="color-comment">//</span><span class="color-output">[2: Java for more Dummies, 3: more Java for more Dummies]</span>

      set2.retainAll(set1);     <span class="color-comment">// &quot;intersection&quot; with set1</span>
      System.out.println(set2); <span class="color-comment">//</span><span class="color-output">[2: Java for more Dummies]</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<ul>
<li>A <code>Set</code> cannot hold duplicate element. The elements are check for duplication via the overridden <code>equal()</code>.</li>
<li>A <code>Set</code> can hold a <code>null</code> value as its element (but no duplicate too).</li>
<li>The <code>addAll()</code> and <code>retainAll()</code> perform <em>set union</em> and <em>set intersection</em> operations, respectively.</li>
</ul>

<p>Take note that the arrangement of the elements is arbitrary, and does not correspond to the order of <code>add()</code>.</p>

<h4><span class="font-code">LinkedHashSet&lt;E&gt;</span> By Example</h4>

<p>Unlike <code>HashSet</code>, <code>LinkedHashSet</code> builds a link-list over the hash table for better efficiency in insertion and deletion (in the expense of more complex structure). It maintains its elements in the insertion-order (i.e., order of <code>add()</code>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
import java.util.LinkedHashSet;
import java.util.Set;
public class <strong>LinkedHashSetTest</strong> {
   public static void main(String[] args) {
      Book book1 = new Book(1, &quot;Java for Dummies&quot;);
      Book book1Dup = new Book(1, &quot;Java for the Dummies&quot;); <span class="color-comment">// same id as above</span>
      Book book2 = new Book(2, &quot;Java for more Dummies&quot;);
      Book book3 = new Book(3, &quot;more Java for more Dummies&quot;);
 
      Set&lt;Book&gt; set = new LinkedHashSet&lt;Book&gt;();
      set.add(book1);
      set.add(book1Dup); <span class="color-comment">// duplicate id, not added</span>
      set.add(book1);    <span class="color-comment">// added twice, not added</span>
      set.add(book3);
      set.add(null);     <span class="color-comment">// Set can contain a null</span>
      set.add(null);     <span class="color-comment">// but no duplicate</span>
      set.add(book2);
      System.out.println(set);
     <span class="color-comment"> //</span><span class="color-output">[1: Java for Dummies, 3: more Java for more Dummies, null, 2: Java for more Dummies]</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The output clearly shows that the set is ordered according to the order of <code>add()</code>.</p>

<h4><span class="font-code">SortedSet&lt;E&gt;</span> and <span class="font-code">NavigableSet&lt;E&gt;</span> Interfaces</h4>

<p>Elements in a <code>SortedSet&lt;E&gt;</code> are sorted during <code>add()</code>, either using the natural ordering in the <code>Comparable&lt;T&gt;</code>, or given a <code>Comparator&lt;T&gt;</code> object. Read &quot;<a href="J5c_Collection.html#ordering">Ordering, Sorting and Searching</a>&quot; for details on <code>Comparable&lt;T&gt;</code> and <code>Comparator&lt;T&gt;</code>.</p>

<p>The <code>NavigableSet&lt;E&gt;</code> is a sub-interface of <code>SortedSet&lt;E&gt;</code>, which declares these additional navigation methods:</p>

<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">NavigableSet&lt;E&gt;</span></span>
abstract Iterator&lt;E&gt; <span class="color-new">iterator</span>()            <span class="color-comment">// Returns an iterator in ascending order.</span>
abstract Iterator&lt;E&gt; <span class="color-new">descendingIterator</span>()  <span class="color-comment">// Returns an iterator in descending order.
</span><span class="color-comment">
// Per-Element operation</span>
abstract E <span class="color-new">floor</span>(E <em>e</em>)    <span class="color-comment">// Returns the greatest element less than or equal to the given element, 
                         //   or null if there is no such element.</span>
abstract E <span class="color-new">ceiling</span>(E <em>e</em>)  <span class="color-comment">// Returns the least element greater than or equal to the given element, or null
</span>abstract E <span class="color-new">lower</span>(E <em>e</em>)    <span class="color-comment">// Returns the greatest element strictly less than the given element, or null
</span>abstract E <span class="color-new">higher</span>(E <em>e</em>)   <span class="color-comment">// Returns the least element strictly greater than the given element, or null
</span> 
<span class="color-comment">// Subset operation</span>
abstract SortedSet&lt;E&gt; <span class="color-new">headSet</span>(E <em>toElement</em>)   <span class="color-comment">// Returns a view whose elements are strictly less than toElement.</span>
abstract SortedSet&lt;E&gt; <span class="color-new">tailSet</span>(E <em>fromElement</em>) <span class="color-comment">// Returns a view whose elements are greater than or equal to fromElement.</span>
abstract SortedSet&lt;E&gt; <span class="color-new">subSet</span>(E <em>fromElement</em>, E <em>toElement</em>)  
         <span class="color-comment">// Returns a view whose elements range from fromElement (inclusive) to toElement (exclusive)</span></pre>

<h4><span class="font-code">TreeSet&lt;E&gt;</span> by Example</h4>
<p><code>TreeSet&lt;E&gt;</code> is an implementation to <code>NavigableSet&lt;E&gt;</code> and <code>SortedSet&lt;E&gt;</code>.</p>


<h5 id="sortedset_example">Example - <span class="font-code">TreeSet</span> with <span class="font-code">Comparable&lt;E&gt;</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
public class <strong>AddressBookEntry implements Comparable&lt;AddressBookEntry&gt;</strong> {
   private String name, address, phone;
 
   public AddressBookEntry(String name) {  <span class="color-comment">// constructor, ignore address and phone</span>
      this.name = name;
   }
 
   @Override
   public String toString() {  <span class="color-comment">// describe itself</span>
      return name;
   }
 
   @Override
   public int compareTo(AddressBookEntry other) {  <span class="color-comment">// Interface Comparable&lt;T&gt;</span>
      return this.name.compareToIgnoreCase(other.name);
   }
 
   @Override
   public boolean equals(Object o) {
      return o != null &amp;&amp; o instanceof AddressBookEntry &amp;&amp; this.name.equalsIgnoreCase(((AddressBookEntry)o).name);
   }
 
   <span class="color-comment">// Two objects which are equals() shall have the same hash code</span>
   @Override
   public int hashCode() {
      return name.toLowerCase().hashCode();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This <code>AddressBookEntry</code> class implements <code>Comparable</code>, in order to be used in <code>TreeSet</code>. It overrides <code>compareTo()</code> to compare the <code>name</code> in a case insensitive manner. It also overrides <code>equals()</code> and <code>hashCode()</code>, so as they are consistent with the <code>compareTo()</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
import java.util.TreeSet;
 
public class <strong>TreeSetComparableTest</strong> {
   public static void main(String[] args) {
      AddressBookEntry addr1 = new AddressBookEntry(&quot;peter&quot;);
      AddressBookEntry addr2 = new AddressBookEntry(&quot;PAUL&quot;);
      AddressBookEntry addr3 = new AddressBookEntry(&quot;Patrick&quot;);
 
      TreeSet&lt;AddressBookEntry&gt; set = new TreeSet&lt;&gt;();
      set.add(addr1);
      set.add(addr2);
      set.add(addr3);
      System.out.println(set); <span class="color-comment">//</span><span class="color-output">[Patrick, PAUL, peter]</span>
 
      System.out.println(set.floor(addr2));   <span class="color-comment">//<span class="color-output">PAUL</span></span>
      System.out.println(set.lower(addr2));   <span class="color-comment">//</span><span class="color-output">Patrick</span>
      System.out.println(set.headSet(addr2)); <span class="color-comment">//</span><span class="color-output">[Patrick]</span>
      System.out.println(set.tailSet(addr2)); <span class="color-comment">//</span><span class="color-output">[PAUL, peter]</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Observe that the <code>AddressBookEntry</code> objects are sorted and stored in the order depicted by the <code>Comparable&lt;T&gt;</code><code></code> during <code>add()</code> operation.</p>


<h5 id="treeset_example">Example - <span class="font-code">TreeSet</span> with <span class="font-code">Comparator&lt;T&gt;</span></h5>

<p>Let's rewrite the previous example to use a <code>Comparator</code> object instead of <code>Comparable</code>. We shall set the <code>Comparator</code> to order in descending order of <code>name</code> for illustration.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12</pre>
</td>
<td>
<pre>
public class <strong>PhoneBookEntry</strong> {
   public String name, address, phone;
 
   public PhoneBookEntry(String name) {  <span class="color-comment">// constructor, ignore address and phone</span>
      this.name = name;
   }
 
   @Override
   public String toString() {
      return name;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The <code>PhoneBookEntry</code> class does not implement <code>Comparator</code>. You cannot <code>add()</code> a <code>PhoneBookEntry</code> object into a  <code>TreeSet()</code> as in the above example. Instead, we define a <code>Comparator</code> class, and use an instance of <code>Comparator</code> to construct a <code>TreeSet</code>.</p>

<p>The <code>Comparator</code> orders the <code>PhoneBookEntry</code> objects in descending <code>name</code> and case insensitive.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
import java.util.Set;
import java.util.TreeSet;
import java.util.Comparator;
 
public class <strong>TreeSetComparatorTest</strong> {
   <span class="color-comment">// Using a named inner class to implement Comparator&lt;T&gt;</span>
   public static class PhoneBookComparator implements Comparator&lt;PhoneBookEntry&gt; {
      @Override
      public int compare(PhoneBookEntry p1, PhoneBookEntry p2) {
         return p2.name.compareToIgnoreCase(p1.name);  <span class="color-comment">// descending name</span>
      }
   }
 
   public static void main(String[] args) {
      PhoneBookEntry addr1 = new PhoneBookEntry(&quot;peter&quot;);
      PhoneBookEntry addr2 = new PhoneBookEntry(&quot;PAUL&quot;);
      PhoneBookEntry addr3 = new PhoneBookEntry(&quot;Patrick&quot;);
 
      Comparator&lt;PhoneBookEntry&gt; comp = new PhoneBookComparator();
      TreeSet&lt;PhoneBookEntry&gt; set = new TreeSet&lt;PhoneBookEntry&gt;(comp);
      set.add(addr1);
      set.add(addr2);
      set.add(addr3);
      System.out.println(set);    <span class="color-comment">//</span><span class="color-output">[peter, PAUL, Patrick]</span>
 
      Set&lt;PhoneBookEntry&gt; newSet = set.descendingSet();  <span class="color-comment">// Reverse the order</span>
      System.out.println(newSet); <span class="color-comment">//</span><span class="color-output">[Patrick, PAUL, peter]</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>
<p>In the test program, we construct a <code>TreeSet</code> with the <code>BookComparator</code>. We also tried the <code>descendingSet()</code> method to obtain a new <code>Set</code> in reverse order.</p>

<h3><span class="font-code">Queue&lt;E&gt;</span> Interfaces, Implementations and Algorithms</h3>
<p>A <em>queue</em> is a collection whose elements are added and removed in a specific order, typically in a first-in-first-out (FIFO) manner. A <em>deque</em> (pronounced &quot;deck&quot;) is a double-ended queue that elements can be inserted and removed at both ends (head and tail) of the queue.</p>

<img class="image-center" src="images/Collection_QueneImplementation.png" alt="queue implementation"/>

<p>Besides basic <code>Collection&lt;E&gt;</code> operations, <code>Queue&lt;E&gt;</code> provide additional insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either <code>null</code> or <code>false</code>, depending on the operations). The latter form of the insert operation is designed specifically for use with capacity-restricted <code>Queue</code> implementations</p>

<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Queue&lt;E&gt;</span>
// Insertion at the end of the queue</span>
abstract boolean <span class="color-new">add</span>(E <em>e</em>)   <span class="color-comment">// throws IllegalStateException if no space is currently available</span>
abstract boolean <span class="color-new">offer</span>(E <em>e</em>) <span class="color-comment">// returns true if the element was added to this queue, else false</span>
 
<span class="color-comment">// Extract element at the head of the queue</span>
abstract E <span class="color-new">remove</span>()         <span class="color-comment">// throws NoSuchElementException if this queue is empty</span>
abstract E <span class="color-new">poll</span>()           <span class="color-comment">// returns the head of this queue, or null if this queue is empty</span>
 
<span class="color-comment">// Inspection (retrieve the element at the head, but does not remove)</span>
abstract E <span class="color-new">element</span>()        <span class="color-comment">// throws NoSuchElementException if this queue is empty</span>
abstract E <span class="color-new">peek</span>()           <span class="color-comment">// returns the head of this queue, or null if this queue is empty</span></pre>

<p><code>Deque&lt;E&gt;</code> declares additional methods to operate on both ends (head and tail) of the queue.</p>
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Deque&lt;E&gt;</span>
// Insertion</span>
abstract void <span class="color-new">addFirst</span>(E <em>e</em>)
abstract void <span class="color-new">addLast</span>(E <em>e</em>)
abstract boolean <span class="color-new">offerFirst</span>(E <em>e</em>)
abstract boolean <span class="color-new">offerLast</span>(E <em>e</em>)
 
<span class="color-comment">// Retrieve and Remove</span>
abstract E <span class="color-new">removeFirst</span>()
abstract E <span class="color-new">removeLast</span>()
abstract E <span class="color-new">pollFirst</span>()
abstract E <span class="color-new">pollLast</span>()
 
<span class="color-comment">// Retrieve but does not remove</span>
abstract E <span class="color-new">getFirst</span>()
abstract E <span class="color-new">getLast</span>()
abstract E <span class="color-new">peekFirst</span>()
abstract E <span class="color-new">peekLast</span>()</pre>

<p>A <code>Deque</code> can be used as FIFO queue (via methods <code>add(e)</code>, <code>remove()</code>, <code>element()</code>, <code>offer(e)</code>, <code>poll()</code>, <code>peek()</code>) or LIFO queue (via methods <code>push(e)</code>, <code>pop()</code>, <code>peek()</code>).</p>

<p>The <code>Queue&lt;E&gt;</code> and <code>Deque&lt;E&gt;</code> implementations include:</p>

<ul>
<li><code>PriorityQueue&lt;E&gt;</code>: A queue where the elements are ordered based on an ordering you specify, instead of FIFO.</li>

<li><code>ArrayDeque&lt;E&gt;</code>: A queue and deque implemented as a dynamic array, similar to <code>ArrayList&lt;E&gt;</code>.</li>

<li><code>LinkedList&lt;E&gt;</code>: The <code>LinkedList&lt;E&gt;</code> also implements the <code>Queue&lt;E&gt;</code> and <code>Deque&lt;E&gt;</code> interfaces, in additional to <code>List&lt;E&gt;</code> interface, providing a queue or deque that is implemented as a double- linked list data structure.</li>
</ul>

<p>The basic operations of <code>Queue&lt;E&gt;</code> include adding an element, polling the queue to retrieve the next element, or peeking at the queue to see if there is an element available in the queue. The <code>Deque&lt;E&gt;</code> operations are similar except element can be added, polled, or peeked at both ends of the deque.</p>

<p>[TODO] Example</p>

<h3><span class="font-code">Map&lt;K,V&gt;</span> Interfaces, Implementations and Algorithms</h3>

<p>A map is a collection of key-value pairs (e.g., name-address, name-phone, isbn-title, word-count). Each key maps to one and only value. Duplicate keys are not allowed, but duplicate values are allowed. Maps are similar to linear arrays, except that an array uses an integer key to index and access its elements; whereas a map uses any arbitrary key (such as <code>String</code>s or any objects).</p>

<img class="image-center" src="images/Collection_MapImplementation.png" alt="map implementation"/>

<p>The implementations of <code>Map&lt;K,V&gt;</code> interface include:</p>
<ul>
<li><code>HashMap&lt;K,V&gt;</code>:  Hash table implementation of the <code>Map&lt;K,V&gt;</code> interface.  The <em>best all-around implementation</em>. Methods in <code>HashMap</code> is not synchronized.</li>
<li><code>TreeMap&lt;K,V&gt;</code>:  Red-black tree implementation of the <code>SortedMap&lt;K,V&gt;</code> interface.</li>
<li><code>LinkedHashMap&lt;K,V&gt;</code>:  Hash table with link-list to facilitate insertion and deletion.</li>
<li><code>Hashtable&lt;K,V&gt;</code>:  Retrofitted legacy (JDK 1.0) implementations.  A synchronized hash table implementation of the <code>Map&lt;K,V&gt;</code> interface that does not allow <code>null</code> key or values, with legacy methods.</li>
</ul>


<h5>Basic Operations</h5>
<p>The <code>Map&lt;K,V&gt;</code> interface declares the following <code>abstract</code> methods for basic operations:</p>
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.<span class="color-new">Map&lt;K,V&gt;</span></span>
abstract int <span class="color-new">size</span>()             <span class="color-comment">// Returns the number of key-value pairs</span>
abstract boolean isEmpty()      <span class="color-comment">// Returns true if this map contain no key-value pair</span>
abstract V <span class="color-new">get</span>(Object <em>key</em>)      <span class="color-comment">// Returns the value of the specified key</span>
abstract V <span class="color-new">put</span>(K <em>key</em>, V <em>value</em>)  <span class="color-comment">// Associates the specified value with the specified key</span>
abstract boolean <span class="color-new">containsKey</span>(Object <em>key</em>)     <span class="color-comment">// Returns true if this map has specified key</span>
abstract boolean <span class="color-new">containsValue</span>(Object <em>value</em>) <span class="color-comment">// Returns true if this map has specified value</span>
abstract void <span class="color-new">clear</span>()              <span class="color-comment">// Removes all key-value pairs</span>
abstract void V <span class="color-new">remove</span>(object key) <span class="color-comment">// Removes the specified key</span></pre>

<h5>Collection Views</h5>

<p>The <code>map&lt;K,V&gt;</code> provides these method to allow a map to be viewed as a <code>Collection</code>:</p>

<pre class="color-syntax">
<span class="color-comment">// java.util.<span class="color-new">Map(K,V)</span></span>
abstract Set&lt;K&gt; <span class="color-new">keySet</span>()         <span class="color-comment">// Returns a set view of the keys</span>
abstract Collection&lt;V&gt; <span class="color-new">values</span>()  <span class="color-comment">// Returns a collection view of the values</span>
abstract Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="color-new">entrySet</span>()  <span class="color-comment">// Returns a set view of the key-value</span></pre>

<p>The nested class <code>Map.Entry&lt;K,V&gt;</code> contains these methods:</p>
<pre class="color-syntax">
<span class="color-comment">// Nested Class <span class="color-new">Map.Entry&lt;K,V&gt;</span></span>
K <span class="color-new">getKey</span>()     <span class="color-comment">// Returns the key of this map entry</span>
V <span class="color-new">getValue</span>()   <span class="color-comment">// Returns the value of this map entry</span>
V <span class="color-new">setValue</span>()   <span class="color-comment">// Replaces the value of this map entry</span></pre>


<p>The <code>Map</code> does not have <code>List</code>-like iterator.  The <code>Collection</code> views provides the  means to iterate over a map.</p>

<h5>Example 1: Iterating through a <span class="font-code">Map</span> using <span class="font-code">.entrySet()</span> and <span class="font-code">.keySet()</span></h5>

<pre class="color-example">
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;

public class <strong>MapViewTest</strong> {
   public static void main(String[] args) {
      Map&lt;String, Double&gt; map = new HashMap&lt;&gt;();
      map.put(&quot;espresso&quot;, 1.1);
      map.put(&quot;latte&quot;, 2.2);
      map.put(&quot;cappuccino&quot;, 3.3);
      System.out.println(map);  <span class="color-comment">//<span class="color-output">{espresso=1.1, cappuccino=3.3, latte=2.2}</span></span>

      <span class="color-comment">// Using .entrySet() which returns a Set&lt;Map.Entry&gt; to iterate through the map</span>
      for (Map.Entry&lt;String, Double&gt; e : map<span class="color-new">.entrySet()</span>) {
         e.setValue(e.getValue() + 10.0);  <span class="color-comment">// modify value</span>
         System.out.println(e<span class="color-new">.getKey()</span> + &quot;:&quot; + e<span class="color-new">.getValue()</span>);
      }
      <span class="color-comment">//<span class="color-output">espresso:11.1</span></span>
      <span class="color-comment">//<span class="color-output">cappuccino:13.3</span></span>
      <span class="color-comment">//<span class="color-output">latte:12.2</span></span>

      <span class="color-comment">// Using for-each loop on .keySet() which returns a Set to iterate through the map</span>
      <span class="color-comment">// .keySet() returns a Set of keys</span>
      System.out.println(map.keySet());  <span class="color-comment">//<span class="color-output">[espresso, cappuccino, latte]</span></span>
      for (String key : map<span class="color-new">.keySet()</span>) {
         System.out.println(key + &quot;=&quot; + map.get(key));
      }
      <span class="color-comment">//<span class="color-output">espresso=11.1</span></span>
      <span class="color-comment">//<span class="color-output">cappuccino=13.3</span></span>
      <span class="color-comment">//<span class="color-output">latte=12.2</span></span>

      <span class="color-comment">// Using Iterator on .keySet() to iterate through the map</span>
      Iterator&lt;String&gt; iter = map.keySet().iterator();
      while (iter.hasNext()) {
         String key = iter.next();
         System.out.println(key + &quot;:&quot; + map.get(key));
      }
      <span class="color-comment">//<span class="color-output">espresso:11.1</span></span>
      <span class="color-comment">//<span class="color-output">cappuccino:13.3</span></span>
      <span class="color-comment">//<span class="color-output">latte:12.2</span></span>

      <span class="color-comment">// .values() returns a Collection of values</span>
      System.out.println(map<span class="color-new">.values()</span>);  <span class="color-comment">//<span class="color-output">[21.1, 23.3, 22.2]</span></span>
   }
}</pre>

<h5>Example 2: Word Count using <span class="font-code">HashMap&lt;String, Integer&gt;</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">// Counts the frequency of each of the words in a file given in the command-line,</span>
<span class="color-comment">// and saves in a map of {word, freq}.</span>
import java.util.Map;
import java.util.HashMap;
import java.util.Scanner;
import java.io.File;
 
public class <strong>WordCount</strong> {
   public static void main(String[] args) throws Exception {
      Scanner in = new Scanner(new File(args[0]));
 
      Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
      while (in.hasNext()) {
         String word = in.next();
         int freq = (map.get(word) == null) ? 1 : map.get(word) + 1;   <span class="color-comment">// type-safe</span>
         map.put(word, freq);      <span class="color-comment">// auto-box int to Integer and upcast, type-check</span>
      }
      System.out.println(map);
   }
}</pre>
</td>
</tr>
</tbody>
</table>



<h3 id="algorithms">Utilities Class <span class="font-code">java.util.Arrays</span></h3>
<p>The Collection Framework provides two utility classes: <code>java.util.Arrays</code> and <code>java.util.Collections</code>, which provide some useful algorithms, such as sort, shuffle, reverse, and search, on arrays and Collections.</p>

<p>Array is a reference type in Java. It can hold primitives, as well as objects. On the other hand, a <code>Collection</code> holds only object.</p>

<h4>Array Sorting/Searching: <span class="font-code">Arrays.sort()</span> and <span class="font-code">Arrays.binarySearch()</span></h4>

<h5>Sorting of Primitive and <span class="font-code">Object</span> Arrays</h5>

<p>There is a pair of <code>sort()</code> methods for each of the primitive types (except <code>boolean</code>) and <code>Object</code>.</p>
<p>For example, for <code>int[]</code>:</p>

<pre class="color-syntax">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Arrays</span></span>
<span class="color-comment">// Sorting of primitive arrays (except boolean[])</span>
static <span class="color-new">sort</span>(int[] a) -&gt; void
static <span class="color-new">sort</span>(int[] a, int fromIdx, int toIdx) -&gt; void
<span class="color-comment">// Similar methods for byte[], short[], long[], float[], double[] and char[]</span>

<span class="color-comment">// Sorting of Object[]</span>
static <span class="color-new">sort</span>(Object[] a) -&gt; void
static <span class="color-new">sort</span>(Object[] a, int fromIdx, int toIdx) -&gt; void
</pre>
<p>Similar <code>sort()</code> methods are available for primitive arrays <code>byte[]</code>, <code>short[]</code>, <code>long[]</code>, <code>float[]</code>, <code>double[]</code>, <code>char[]</code> (except <code>boolean[]</code>), and <code>Object[]</code>. For <code>Object[]</code>, the objects must implement <code>Comparable&lt;T&gt;</code> interface so that the ordering can be determined via the <code>compareTo()</code> method.</p>
 
<h5>Sorting for Generic Arrays</h5>
<p>A pair of methods is also defined for generic, to be sorted based on the given <code>Comparator</code> (instead of <code>Comparable</code>).</p>

<pre class="color-syntax">
static <span class="color-new">sort</span>(T[] a, Comparator&lt;Ts&gt; c) -&gt; void
static <span class="color-new">sort</span>(T[] a, int fromIdx, int toIdx, Comparator&lt;? super T&gt; c) -&gt; void</pre>

<p>Note:<code> </code>Suppose that you wish to sort an array of <code>Integer</code> (where <code>T</code> is <code>Integer</code>), you could use a <code>Comparator&lt;Integer&gt;</code>. You can also use <code>Comparator&lt;Number&gt;</code> or <code>Comparator&lt;Object&gt;</code>, as <code>Object</code> and <code>Number</code> are superclass of <code>Integer</code>.</p>

<h5>Searching of Primitive, <span class="font-code">Object</span> and Generic Arrays</h5>

<p>Similarly, there is a pair of searching method for each of the primitive arrays (except <code>boolean[]</code>) and <code>Object</code>. The arrays must be sorted before you can apply the <code>binarySearch()</code> method.</p>

<pre class="color-syntax">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Arrays</span></span>
static <span class="color-new">binarySearch</span>(int[] a, int key) -&gt; int
static <span class="color-new">binarySearch</span>(int[] a, int fromIdx, int toIdx, int key) -&gt; int
<span class="color-comment">// Similar methods for byte[], short[], long[], float[], double[] and char[]</span>
 
<span class="color-comment">// Searching object[], which implements Comparable</span>
static <span class="color-new">binarySearch</span>(Object[] a, Object key) -&gt; int
static <span class="color-new">binarySearch</span>(Object[] a, int fromIdx, int toIdx, Object key) -&gt; int

<span class="color-comment">// Searching generic array, order by the given Comparator</span>
static <span class="color-new">binarySearch</span>(T[] a, T key, Comparator&lt;? super T&gt; c) -&gt; int
static <span class="color-new">binarySearch</span>(T[] a, T key, int fromIdx, int toIdx, Comparator&lt;? super T&gt; c) -&gt; int</pre>

<h5>Examples</h5>
<p>See &quot;<a href="J5c_Collection.html#ordering"><code>List</code> Ordering/Searching/Sorting</a>&quot;.</p>

<h4>Equality Comparison: <span class="font-code">Arrays.equals()</span></h4>

<pre class="color-syntax">
static <span class="color-new">equals</span>(int[] a, int[] b) -&gt; boolean
<span class="color-comment">// Similar methods for byte[], short[], long[], float[], double[], char[], boolean[] and Object[]</span></pre>

<h4>Copying: <span class="font-code">Arrays.copyOf()</span> and <span class="font-code">Arrays.copyOfRange()</span></h4>

<pre class="color-syntax">
static <span class="color-new">copyOf</span>(int[] src, int length) -&gt; int[]
  <span class="color-comment">// Copies the given array, truncating or padding with zeros (if necessary) so the copy has the specified length</span>
static <span class="color-new">copyOfRange</span>(int[] src, int fromIdx, int toIdx) -&gt; int[]
<span class="color-comment">// Similar methods for byte[], short[], long[], float[], double[], char[] and boolean[]</span>

static <span class="color-new">copyOf</span>(T[] src, int length) -&gt; T[]
static <span class="color-new">copyOfRange</span>(T[] src, int fromIdx, int toIdx) -&gt; T[]
static <span class="color-new">copyOf</span>(U[] src, int length, Class&lt;? extends T[]&gt; newType) -&gt; T[]
static <span class="color-new">copyOfRange</span>(U[] src, int fromIdx, int toIdx, Class&lt;? extends T[]&gt; newType) -&gt; T[]</pre>
    
<h4>Filling: <span class="font-code">Arrays.fill()</span></h4>
<pre class="color-syntax">
static <span class="color-new">fill</span>(int[] a, int value) -&gt; void
static <span class="color-new">fill</span>(int[] a, int fromIdx, int toIdx, int value) -&gt; void
<span class="color-comment">// Similar methods for byte[], short[], long[], float[], double[], char[] and boolean[] and Object[]</span></pre>

<h4>Description: <span class="font-code">Arrays.toString()</span></h4>
<pre class="color-syntax">
<span class="color-comment">// Returns a string representation of the contents of the specified array.</span>
static <span class="color-new">toString</span>(int[] a) -&gt; String
<span class="color-comment">// Similar methods for byte[], short[], long[], float[], double[], char[] and boolean[] and Object[]</span></pre>

<h4>Converting to <span class="font-code">List</span>: <span class="font-code">Arrays.asList()</span></h4>

<pre class="color-syntax">
<span class="color-comment">// Returns a fixed-size list backed by the specified array.
// Change to the list write-thru to the array.</span>
static <span class="color-new">asList</span>(T[] a) -&gt; List&lt;T&gt;</pre>
<h3>Utilities Class <span class="font-code">java.util.Collections</span></h3>

<p>The Collection Framework provides two utility classes: <code>java.util.Arrays</code> and <code>java.util.Collections</code>, which provide some useful algorithms, such as sort, shuffle, reverse, and search, on arrays and Collections. Take note that the interface is called <code>Collection</code>, while the utility class is called <code>Collections</code> with a <code>'s'</code><code></code>.</p>

<h4><span class="font-code">List</span> Searching/Sorting: <span class="font-code">Collations.sort()/binarySearch()</span></h4>

<pre class="color-syntax">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Collections</span>
// Sorts the specified list into ascending order. The objects shall implement Comparable. </span>
static <span class="color-new">sort</span>(List&lt;T&gt; list) -&gt; void
<span class="color-comment">// Sorts the specified list according to the order induced by the specified comparator.</span>
static <span class="color-new">sort</span>(List&lt;T&gt; list, Comparator&lt;? super T&gt; <em>c</em>) -&gt; void

static <span class="color-new">binarySearch</span>(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) -&gt; int
static <span class="color-new">binarySearch</span>(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) -&gt; int</pre>
<p>See &quot;<a href="J5c_Collection.html#ordering"><code>List</code> Algorithms</a>&quot;.</p>


<h4>Maximum and Minimum: <span class="font-code">Collections.max()|min()</span></h4>

<pre class="color-syntax">
<span class="color-comment">// Returns the maximum/minimum element of the given collection, according to the natural ordering of its elements.</span>
static <span class="color-new">max</span>(Collection&lt;? extends T&gt; c) -&gt; T
static <span class="color-new">min</span>(Collection&lt;? extends T&gt; c) -&gt; T
 
<span class="color-comment">// Returns the maximum/minimum element of the given collection, according to the order induced by the specified comparator.</span>
static <span class="color-new">max</span>(Collection&lt;? extends T&gt; c, Comparator&lt;? super T&gt; comp) -&gt; T
static <span class="color-new">min</span>(Collection&lt;? extends T&gt; c, Comparator&lt;? super T&gt; comp) -&gt; T</pre>

<h4 id="synchronized_collection">Synchronized Wrapper: <span class="font-code">Collections.synchronizedXxx()</span></h4>

<p>Most of the <code>Collection</code> implementations such as <code>ArrayList</code>, <code>HashSet</code> and  <code>HashMap</code> are NOT <em>synchronized</em> for multi-threading, except the legacy <code>Vector</code> and <code>HashTable</code>, which are retrofitted to conform to the Collection Framework and synchronized. Instead of using the synchronized <code>Vector</code> and <code>HastTable</code>, you can create a synchronized <code>Collection</code>, <code>List</code>, <code>Set</code>, <code>SortedSet</code>, <code>Map</code> and <code>SortedMap</code>, via the <code>static</code> <code>Collections.synchronizedXxx()</code> methods:</p>

<pre class="color-syntax">
<span class="color-comment">// Class java.util.<span class="color-new">Collections</span></span>
<span class="color-comment">// Returns a synchronized (thread-safe) collection backed by the specified collection.</span>
static <span class="color-new">synchronizedCollection</span>(Collection&lt;T&gt; c) -&gt; Collection&lt;T&gt;
static <span class="color-new">synchronizedList</span>(List&lt;T&gt; list) -&gt; List&lt;T&gt;
static <span class="color-new">synchronizedSet</span>(Set&lt;T&gt; set) -&gt; Set&lt;T&gt;
static <span class="color-new">synchronizedSortedSet</span>(SortedSet&lt;T&gt; set) -&gt; SortedSet&lt;T&gt;
static <span class="color-new">synchronizedMap</span>(Map&lt;K,V&gt; map) -&gt; Map&lt;K,V&gt;
static <span class="color-new">synchronizedSortedMap</span>(SortedMap&lt;K,V&gt; map) -&gt; SortedMap&lt;K,V&gt;</pre>

<p>According to the JDK API specification, &quot;to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list, and that user manually synchronize on the returned list when iterating over it&quot;. For example,</p>
<pre class="color-example">
<strong>List lst = Collections.synchronizedList(new ArrayList());</strong>
   ......
<strong>synchronized(lst) {</strong>  <span class="color-comment">// must be enclosed in a synchronized block</span>
   Iterator iter = lst.iterator(); 
   while (iter.hasNext())
     iter.next();
     ......
<strong>}</strong></pre>

<h4>Unmodifiable Wrappers: <span class="font-code">Collections.unmodifiableXxx()</span></h4>

<p>Unmodifiable wrappers prevent modification of the collection by intercepting all the operations that would modify the collection and throwing an <code>UnsupportedOperationException</code>.</p>

<p>The <code>Collections</code> class provides six <code>static</code> methods to wrap the interfaces <code>Collection</code>, <code>List</code>, <code>Set</code>, <code>SortedSet</code>, <code>Map</code> and <code>SortedMap</code>.</p>

<pre class="color-syntax">
<span class="color-comment">// Class java.util.<span class="color-new">Collections</span></span>
static <span class="color-new">unmodifiableCollection</span>(Collection&lt;? extends T&gt; c) -&gt; Collection&lt;T&gt;
static <span class="color-new">unmodifiableList</span>(List&lt;? extends T&gt; list) -&gt; List&lt;T&gt;
static <span class="color-new">unmodifiableSet</span>(Set&lt;? extends T&gt; s) -&gt; Set&lt;T&gt;
static <span class="color-new">unmodifiableSortedSet</span>(SortedSet&lt;? extends T&gt; s) -&gt; SortedSet&lt;T&gt;
static <span class="color-new">unmodifiableMap</span>(Map&lt;? extends K, ? extends V&gt; m) -&gt; Map&lt;K,V&gt;
static <span class="color-new">unmodifiableSortedMap</span>(SortedMap&lt;K, ? extends V&gt; m) -&gt; SortedMap&lt;K,V&gt;</pre>
<h3>Utility Class <span class="font-code">java.util.Objects</span> (JDK 7)</h3>

<p>Note: By JDK convention, <code>Object</code> is a regular class modeling objects, and <code>Objects</code> is an utility class containing <code>static</code> methods for <code>Object</code>.</p>
<p>The utility class <code>java.util.Objects</code> contains <code>static</code> methods for operating on <code>Object</code>s (such as comparing two objects and computing hash code), and checking certain conditions (such as checking for <code>null</code>, checking if indexes are out of bounds) before operations.</p>

<pre class="color-syntax">
<span class="color-comment">// java.util.<span class="color-new">Objects</span></span>
static <span class="color-new">compare</span>(T a, T b, Comparator&lt;T&gt; c) -&gt; int
static <span class="color-new">equals</span>(Object a, Object b) -&gt; boolean
static <span class="color-new">deepEquals</span>(Object a, Object b) -&gt; boolean
static <span class="color-new">hashCode</span>(Object o) -&gt; int
static <span class="color-new">hash</span>(Object... values) -&gt; int
static <span class="color-new">toString</span>(Object o) -&gt; String
static <span class="color-new">toString</span>(Object o, String nullDefault) -&gt; String

<span class="color-comment">// Check index bound</span>
static <span class="color-new">checkIndex</span>(int idx, int length) -&gt; int
static <span class="color-new">checkFromToIndex</span>(int fromIdx, int toIdx, int length) -&gt; int
static <span class="color-new">checkFromIndexSize</span>(int fromIdx, int size, int length) -&gt; int

<span class="color-comment">// Check null</span>
static <span class="color-new">isNull</span>(Object o) -&gt; boolean
static <span class="color-new">nonNull</span>(Object o) -&gt; boolean
static <span class="color-new">requireNonNull</span>(T obj) -&gt; T
static <span class="color-new">requireNonNull</span>(T obj, String errmsg) -&gt; T
static <span class="color-new">requireNonNull</span>(T obj, Supplier&lt;String&gt; msgSupplier) -&gt; T
static <span class="color-new">requireNonNullElse</span>(T obj, T defaultObj) -&gt; T
static <span class="color-new">requireNonNullElseGet</span>(T obj, Supplier&lt;T&gt; supplier) -&gt; T</pre>

<p>Examples [TODO]</p>


<a class="references" href="../howto/References.html#java">LINK TO JAVA REFERENCES &amp; RESOURCES</a>

<p class="references">More References</p>
<ol>
<li>Java Online Tutorial on &quot;Generics&quot; @ <a href="http://docs.oracle.com/javase/tutorial/extra/generics/index.html">http://docs.oracle.com/javase/tutorial/extra/generics/index.html</a>.</li>
<li>Java Online Tutorial on &quot;Collections&quot; @ <a href="http://docs.oracle.com/javase/tutorial/collections/index.html">http://docs.oracle.com/javase/tutorial/collections/index.html</a>.</li>

</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 13.0.1<br />
Last modified: February, 2020</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->

</body>
</html>
