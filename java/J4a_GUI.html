<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>GUI Programming -  Java Programming Tutorial</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="J4a_GUI.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Programming Graphical User Interface (GUI)</h2>
</div>

<div id="content-main">

<h3>Introduction</h3>
<p>So far, we have covered the basic programming constructs (such as variables, data types, decision, loop, array and method) and introduced the important concept of Object-Oriented Programming (OOP).  As discussed, OOP permits higher level of abstraction than  traditional Procedural-Oriented Languages (such as C).  You can create high-level abstract data types called <em>classes</em> to mimic real-life things.  These classes are self-contained and are <em>reusable</em>.</p>

<p>In this article, I shall show you how you can <em>reuse</em> the graphics classes provided in JDK for constructing your own Graphical User Interface (GUI) applications. Writing your own graphics classes (and re-inventing the wheels) is mission impossible! These  graphics classes, developed by expert programmers, are highly complex and  involve many advanced <em>design patterns</em>.Â   However, re-using them are not so difficult, if you follow the API  documentation, samples and templates provided.</p>
<p>I shall assume that you have a good grasp of OOP, including composition, inheritance, polymorphism, abstract class and interface; otherwise, read the earlier articles. I will describe another important OO concept called <em>nested class</em> (or <em>inner class</em>) in this article.</p>

<p>There are current three sets of Java APIs for graphics programming: AWT (<span class="underline">A</span>bstract <span class="underline">W</span>indowing <span class="underline">T</span>oolkit), Swing and JavaFX.</p>
<ol>
<li>AWT API was introduced in JDK 1.0.  Most of the AWT UI components have become obsolete and should be replaced by newer Swing UI components.</li>
<li>Swing API, a much more comprehensive set of graphics libraries that enhances the AWT, was introduced as part of Java Foundation Classes (JFC) after the release of JDK 1.1. JFC consists of Swing, Java2D, Accessibility, Internationalization, and Pluggable Look-and-Feel Support APIs. JFC has been integrated into core Java since JDK 1.2.</li>
<li>The latest JavaFX, which was integrated into JDK 8, was meant to replace Swing.  JavaFX was moved out from the JDK in JDK 11, but still available as a separate module.</li>
</ol>

<p>Other than AWT/Swing/JavaFX graphics APIs provided in JDK, other organizations/vendors have also provided graphics APIs that work with Java, such as Eclipse's Standard Widget Toolkit (SWT) (used in Eclipse), Google Web Toolkit (GWT) (used in Android), 3D Graphics API such as Java  bindings for OpenGL (JOGL), Java3D, and etc. Furthermore, developers have moved to use  technologies such as HTML5 as the basis of webapps.</p>

<p>You need to refer to the &quot;JDK API documentation&quot; for the AWT/Swing APIs (under module <code>java.desktop</code>) while reading this chapter. The best online reference for Graphics programming is the &quot;Swing Tutorial&quot; @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>. For advanced 2D graphics programming, read &quot;Java 2D Tutorial&quot; @ <a href="http://docs.oracle.com/javase/tutorial/2d/index.html">http://docs.oracle.com/javase/tutorial/2d/index.html</a>. For 3D graphics, read my 3D articles.</p>

<h3>Programming GUI with AWT</h3>
<p>I shall start with the AWT  before moving into Swing to give you a complete picture of Java Graphics.</p>

<h4>AWT Packages</h4>

<p>AWT is huge! It consists of 12 packages of 370 classes (Swing is even bigger, with 18 packages of 737 classes as of JDK 8). Fortunately, only 2 packages - <code>java.awt</code> and <code>java.awt.event</code> - are commonly-used.</p>

<ol>
<li>The <code>java.awt</code> package contains the <em>core</em> AWT graphics classes:
  <ul>
<li>GUI Component classes, such as <code>Button</code>, <code>TextField</code>, and <code>Label</code>.</li>
<li>GUI Container classes, such as <code>Frame</code> and <code>Panel</code>.</li>
<li>Layout managers, such as <code>FlowLayout</code>, <code>BorderLayout</code> and <code>GridLayout</code>.</li>
<li>Custom graphics classes, such as <code>Graphics</code>, <code>Color</code> and <code>Font</code>.</li>
</ul>
</li>
<li>The <code>java.awt.event</code> package supports event handling:
  <ul>
<li>Event classes, such as <code>ActionEvent</code>, <code>MouseEvent</code>, <code>KeyEvent</code> and <code>WindowEvent</code>,</li>
<li>Event Listener Interfaces, such as <code>ActionListener</code>, <code>MouseListener</code>,<code> MouseMotionListener</code>, <code>KeyListener</code> and <code>WindowListener</code>,</li>
<li>Event Listener Adapter classes, such as <code>MouseAdapter</code>, <code>KeyAdapter</code>, and <code>WindowAdapter</code>.</li>
</ul>

</li>
</ol>

<p>AWT provides a <em>platform-independent</em> and <em>device-independent</em> interface to develop graphic programs that runs on all platforms, including Windows, macOS, and Unixes.</p>

<h4>AWT Containers and Components</h4>

<img src="images/AWT_ContainerComponent.png" alt="AWT_ContainerComponent.png" />

<p>There are two groups of GUI elements:</p>
<ol>
<li><em>Component</em> (<em>Widget</em>, <em>Control</em>): Components are elementary GUI entities, such as <code>Button</code>, <code>Label</code>, and <code>TextField</code>. They are also called <em>widgets</em>, <em>controls</em> in other graphics systems.</li>
<li><em>Container</em>: Containers, such as <code>Frame</code> and  <code>Panel</code>, are used to <em>hold components in a specific layout</em> (such as <code>FlowLayout</code> or <code>GridLayout</code>). A container can also hold sub-containers.</li> 
</ol>

<p>In the above figure, there are three containers: a <code>Frame</code> and two <code>Panel</code>s. A <code>Frame</code> is the <em>top-level container</em> of an AWT program. A <code>Frame</code> has a title bar (containing an icon, a title,  and the minimize/maximize/close buttons), an optional menu bar and the content display area. A <code>Panel</code> is a<em> rectangular area</em>  used to group related GUI components in a certain layout. In the above figure, the top-level <code>Frame</code> contains two  <code>Panel</code>s. There are five components: a <code>Label</code> (providing description), a <code>TextField</code> (for users to enter text), and three <code>Button</code>s (for user to trigger certain programmed actions).</p>

<p>In a GUI program, a component must be kept (or added) in a  container. 
 You need to identify a container to hold the components. Every container has a method called <code>add(Component c)</code>. A <code>container</code> (say <code>aContainer</code>) can invoke <code>aContainer.add(aComponent)</code> to add <code>aComponent</code> into itself. For example,</p>

<pre class="color-example">
Panel pnl = new Panel();  <span class="color-comment">        // Panel is a container</span>
Button btn = new Button(&quot;Press&quot;); <span class="color-comment">// Button is a component</span>
pnl.add(btn);                     <span class="color-comment">// The Panel container adds a Button component</span></pre>

<p>GUI components are also called <em>controls</em> (e.g., Microsoft ActiveX Control), <em>widgets</em> (e.g., Eclipse's Standard Widget Toolkit, Google Web Toolkit), which allow users to interact with (or control) the application.</p>


<h4>AWT <span class="font-code">Container</span> Classes</h4>

<h5>Top-Level Containers: <span class="font-code">Frame</span>, <span class="font-code">Dialog</span> and <span class="font-code">Applet</span></h5> 
<p>Each GUI program has a <em>top-level container</em>. The commonly-used top-level containers in AWT are <code>Frame</code>, <code>Dialog</code> and <code>Applet</code>:</p>

<ul>
<li>
<img class="image-float-right" src="images/AWT_Frame.png" alt="AWT_Frame.png" />

A  <code>Frame</code> provides the &quot;main window&quot; for your GUI application. It has a title bar (containing an icon, a title, the minimize, maximize/restore-down and close buttons), an optional menu bar, and the content display area.

To write a GUI program, we typically start with a subclass extending from <code>java.awt.Frame</code> to inherit the main window as follows:
<pre class="color-example float-clear">
<span class="color-new">import java.awt.Frame;</span>  <span class="color-comment">// Using Frame class in package java.awt</span>

<span class="color-comment">// A GUI program is written as a subclass of Frame - the top-level container
// This subclass inherits all properties from Frame, e.g., title, icon, buttons, content-pane</span>
public class <strong>MyGUIProgram</strong> <span class="color-new">extends Frame</span> {

   <span class="color-comment">// private variables</span>
   ......
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public MyGUIProgram() { ...... }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the constructor (to setup the GUI) by allocating an instance</span>
      new MyGUIProgram();
   }
}</pre>
</li>


<li>
<img class="image-float-right" src="images/AWT_Dialog.gif" alt="AWT_Dialog.gif" />

An AWT <code>Dialog</code> is a <em>&quot;pop-up window</em>&quot; used for interacting with the users. A <code>Dialog</code> has a title-bar (containing an icon, a title and a close button) and a content display area, as illustrated.

</li>

<li>An AWT <code>Applet</code> (in package <code>java.applet</code>) is the top-level container for an applet, which is a Java program running inside a browser. Applet is no longer supported in most of the browsers.</li>
</ul>

<h5>Secondary Containers: <span class="font-code">Panel</span> and <span class="font-code">ScrollPane</span></h5>
<p>Secondary containers are placed inside a top-level container or another secondary container. AWT  provides these secondary containers:</p>

<ul>
<li><code>Panel</code>: a rectangular box used to <em>layout</em> a set of related GUI components in pattern such as grid or flow.</li>

<li><code>ScrollPane</code>: provides automatic horizontal and/or vertical scrolling for a single child component.</li>
<li>others.</li>
</ul>

<h5>Hierarchy of the AWT <span class="font-code">Container</span> Classes</h5>
<p>The hierarchy of the AWT <code>Container</code> classes is as follows:</p>

<img class="image-center" src="images/AWT_ContainerClassDiagram1.png" alt="AWT_ContainerClassDiagram1.png" />

<p>As illustrated, a <code>Container</code> has a <code>LayoutManager</code> to layout the components in a certain pattern, e.g., flow, grid.</p>

<h4>AWT <span class="font-code">Component</span> Classes</h4>

<p>AWT provides many ready-made  and reusable GUI components in package <code>java.awt</code>.  The frequently-used are: <code>Button</code>, <code>TextField</code>, <code>Label</code>, <code>Checkbox</code>, <code>CheckboxGroup</code> (radio buttons), <code>List</code>, and <code></code><code>Choice</code>, as illustrated below.</p>
<img class="image-center" src="images/AWT_Components.png" alt="AWT_Components.png" />

<h5>AWT GUI Component: <span class="font-code">java.awt.Label</span></h5>
<img class="image-float-right" src="images/AWT_Label.png" alt="AWT_Label.png" />

<p>A <code>java.awt.Label</code> provides a descriptive text string. Take note that <code>System.out.println()</code> prints to the system console, NOT to the graphics screen. You could use  a <code>Label</code> to label another component (such as text field) to provide a text description.</p>

<p> Check the JDK API specification for <code>java.awt.Label</code>.</p>

<p class="float-clear"><span class="underline">Constructors</span></p>
<pre class="color-syntax">
public Label(String <em>strLabel</em>, int <em>alignment</em>); <span class="color-comment">// Construct a Label with the given text String, of the text alignment</span>
public Label(String <em>strLabel</em>);                <span class="color-comment">// Construct a Label with the given text String</span>
public Label();                               <span class="color-comment">// Construct an initially empty Label</span></pre>

<p>The <code>Label</code> class has three constructors:</p>
<ol>
<li>The first constructor constructs a <code>Label</code> object with the given text string in the given alignment.  Note that three <code>static</code> constants <code>Label.LEFT</code>, <code>Label.RIGHT</code>, and <code>Label.CENTER</code> are defined in the class for you to specify the alignment (rather than asking you to memorize arbitrary integer values).</li>
<li>The second constructor constructs a <code>Label</code> object with the given text string in default of left-aligned.</li>
<li>The third constructor constructs a <code>Label</code> object with an initially empty string. You could set the label text via the <code>setText()</code> method later.</li>
</ol>

<p><span class="underline">Constants (<code>final static</code> fields)</span></p>
<pre class="color-syntax">
public static final LEFT;    <span class="color-comment">// Label.LEFT</span>
public static final RIGHT;   <span class="color-comment">// Label.RIGHT</span>
public static final CENTER;  <span class="color-comment">// Label.CENTER</span></pre>

<p>These three constants are defined for specifying the alignment of the <code>Label</code>'s text, as used in the above constructor.</p>

<p><span class="underline">Public Methods</span></p>
<pre class="color-syntax">
<span class="color-comment">// Examples</span>
public String getText();
public void setText(String <em>strLabel</em>);
public int getAlignment();
public void setAlignment(int <em>alignment</em>);  <span class="color-comment">// Label.LEFT, Label.RIGHT, Label.CENTER</span></pre>

<p>The <code>getText()</code> and <code>setText()</code> methods can be used to read and modify the <code>Label</code>'s text.  Similarly, the <code>getAlignment()</code> and <code>setAlignment()</code> methods can be used to retrieve and modify the alignment of the text.</p>

<h5>Constructing a Component and Adding the Component into a Container</h5>

<p>Three steps are necessary to create and place a GUI component:</p>
<ol>
<li>Declare  the component with an <em>identifier</em> (<em>name</em>);</li>
<li>Construct the component by invoking an appropriate constructor via the <code>new</code> operator;</li>
<li>Identify the container (such as <code>Frame</code> or <code>Panel</code>) designed to hold this component. The container can then add this component onto itself via <code><em>aContainer</em>.add(<em>aComponent</em>)</code> method. Every container has a <code>add(Component)</code> method. Take note that it is the container that actively and explicitly adds a component onto itself, NOT the other way.</li>
</ol>

<p class="underline">Example</p>
<pre class="color-example">
Label lblInput;                     <span class="color-comment">// Declare an Label instance called lblInput</span>
lblInput = new Label(&quot;Enter ID&quot;);   <span class="color-comment">// Construct by invoking a constructor via the new operator</span>
add(lblInput);                      <span class="color-comment">// this.add(lblInput) - &quot;this&quot; is typically a subclass of Frame</span>
lblInput.setText(&quot;Enter password&quot;); <span class="color-comment">// Modify the Label's text string</span>
lblInput.getText();                 <span class="color-comment">// Retrieve the Label's text string</span><span class="color-comment"></span></pre>

<h5>An Anonymous <span class="font-code">Label</span> Instance</h5>

<p>You can create a <code>Label</code> without specifying an identifier, called <em>anonymous instance</em>.  In the case, the Java compiler will assign an <em>anonymous identifier</em> for the allocated object.  You will not be able to reference an anonymous instance in your program after it is created.  This is usually alright for a <code>Label</code> instance as there is often no need to reference a <code>Label</code> after it is constructed.</p>

<p class="underline">Example</p>
<pre class="color-example">
<span class="color-comment">// Allocate an anonymous Label instance.
// &quot;this&quot; container adds the instance.
// You CANNOT reference an anonymous instance to carry out further operations.</span>
add(new Label(&quot;Enter Name: &quot;, Label.RIGHT));
 
<span class="color-comment">// Same as</span>
Label xxx = new Label(&quot;Enter Name: &quot;, Label.RIGHT)); <span class="color-comment">// xxx assigned by compiler</span>
add(xxx);</pre>

<h5>AWT GUI Component: <span class="font-code">java.awt.Button</span></h5>
<img class="image-float-right" src="images/AWT_Button.png" alt="AWT_Button.png" />

<p>A <code>java.awt.Button</code> is a GUI component that triggers a certain programmed <em>action</em> upon clicking.</p>

<p class="float-clear"><span class="underline">Constructors</span></p> 

<pre class="color-syntax">
public Button(String <em>btnLabel</em>);
   <span class="color-comment">// Construct a Button with the given label</span>
public Button();
   <span class="color-comment">// Construct a Button with empty label</span></pre>

<p>The <code>Button</code> class has two constructors.  The first constructor creates a <code>Button</code> object with the given label painted over the button.  The second constructor creates a <code>Button</code> object with no label.</p>

<p><span class="underline">Public Methods</span></p>
<pre class="color-syntax">
public String getLabel();
   <span class="color-comment">// Get the label of this Button instance</span>
public void setLabel(String <em>btnLabel</em>);
   <span class="color-comment">// Set the label of this Button instance</span>
public void setEnable(boolean <em>enable</em>);   <span class="color-comment">
   // Enable or disable this Button. Disabled Button cannot be clicked.</span></pre>

<p>The <code>getLabel()</code> and <code>setLabel()</code> methods can be used to read the current label and modify the label of a button, respectively.</p>
<p>Note: The latest Swing's <code>JButton</code> replaces <code>getLabel()/setLabel()</code> with <code>getText()/setText()</code> to be consistent with all the  components. We will describe Swing later.</p>

<p><span class="underline">Event</span></p>
<p>Clicking a button fires a so-called <code>ActionEvent</code> and triggers a certain programmed action.  I will explain event-handling later.</p>

<p><span class="underline">Example</span></p>
<pre class="color-example">
Button btnColor = new Button(&quot;Red&quot;); <span class="color-comment">// Declare and allocate a Button instance called btnColor</span>
add(btnColor);                       <span class="color-comment">// &quot;this&quot; Container adds the Button</span>
...
btnColor.setLabel(&quot;Green&quot;);          <span class="color-comment">// Change the button's label</span>
btnColor.getLabel();                 <span class="color-comment">// Read the button's label</span></pre>

<h5>AWT GUI Component: <span class="font-code">java.awt.TextField</span></h5>
<img class="image-float-right" src="images/AWT_TextField.png" alt="AWT_TextField.png" />

<p>A <code>java.awt.TextField</code> is single-line text box for users to enter texts.  (There is a multiple-line text box called <code>TextArea</code>.) Hitting the &quot;ENTER&quot; key on a <code>TextField</code> object fires an <code>ActionEvent</code>.</p>

<p class="float-clear"><span class="underline">Constructors</span></p>
<pre class="color-syntax">
public TextField(String <em>initialText</em>, int <em>columns</em>);
   <span class="color-comment">// Construct a TextField instance with the given initial text string with the number of columns.</span>
public TextField(String <em>initialText</em>);
   <span class="color-comment">// Construct a TextField instance with the given initial text string.</span>
public TextField(int <em>columns</em>);
   <span class="color-comment">// Construct a TextField instance with the number of columns.</span></pre>

<p><span class="underline">Public Methods</span></p>
<pre class="color-syntax">
public String getText();
   <span class="color-comment">// Get the current text on this TextField instance</span>
public void setText(String <em>strText</em>);
   <span class="color-comment">// Set the display text on this TextField instance</span>
public void setEditable(boolean <em>editable</em>);
   <span class="color-comment">// Set this TextField to editable (read/write) or non-editable (read-only)</span></pre>

<p><span class="underline">Event</span></p>
<p>Hitting the &quot;ENTER&quot; key on a <code>TextField</code> fires a <code>ActionEvent</code>, and triggers a certain programmed action.</p>

<p><span class="underline">Example</span></p>
<pre class="color-example">
TextField tfInput = new TextField(30); <span class="color-comment">// Declare and allocate an TextField instance called tfInput</span>
add(tfInput);                          <span class="color-comment">// &quot;this&quot; Container adds the TextField</span>
TextField tfResult = new TextField();  <span class="color-comment">// Declare and allocate an TextField instance called tfResult</span>
tfResult.setEditable(false) ;          <span class="color-comment">// Set to read-only</span>
add(tfResult);                         <span class="color-comment">// &quot;this&quot; Container adds the TextField</span>
......
<span class="color-comment">// Read an int from TextField &quot;tfInput&quot;, square it, and display on &quot;tfResult&quot;.
// getText() returns a String, need to convert to int</span>
int number = Integer.parseInt(tfInput.getText());
number *= number;
<span class="color-comment">// setText() requires a String, need to convert the int number to String.</span>
tfResult.setText(number + &quot;&quot;);
</pre>

<p>Take note that <code>getText()/SetText()</code> operates on <code>String</code>. You can convert a <code>String</code> to a primitive, such as <code>int</code> or <code>double</code> via <code>static </code>method <code>Integer.parseInt()</code> or <code>Double.parseDouble()</code>. To convert a primitive to a <code>String</code>, simply concatenate the primitive with an empty <code>String</code>.</p>

<h4>Example 1: <span class="font-code">AWTCounter</span></h4>

<img class="image-float-right" src="images/AWT_Counter.png" alt="AWT_Counter.png" />

<p>Let's assemble a few components together into a simple GUI counter program, as illustrated.  It has a top-level container <code>Frame</code>, which contains three  components - a <code>Label</code> &quot;Counter&quot;, a non-editable <code>TextField</code> to display the current count, and a &quot;Count&quot; <code>Button</code>.  The <code>TextField</code> shall display count of <code>0</code> initially.  </p>
<p>Each time you click the button, the counter's value increases by 1.</p>
	
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68</pre>
</td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT container and component classes</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT event classes and listener interfaces</span>

<span class="color-comment">// An AWT program inherits from the top-level container java.awt.Frame</span>
public class <strong>AWTCounter</strong> extends Frame {
   private Label lblCount;    <span class="color-comment">// Declare a Label component</span>
   private TextField tfCount; <span class="color-comment">// Declare a TextField component</span>
   private Button btnCount;   <span class="color-comment">// Declare a Button component</span>
   private int count = 0;     <span class="color-comment">// Counter's value</span>

   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTCounter () {
      setLayout(new FlowLayout());
         <span class="color-comment">// &quot;super&quot; Frame, which is a Container, sets its layout to FlowLayout to arrange</span>
         <span class="color-comment">// the components from left-to-right, and flow to next row from top-to-bottom.</span>

      lblCount = new Label(&quot;Counter&quot;);  <span class="color-comment">// construct the Label component</span>
      add(lblCount);                    <span class="color-comment">// &quot;super&quot; Frame container adds Label component</span>

      tfCount = new TextField(count + &quot;&quot;, 10); <span class="color-comment">// construct the TextField component with initial text</span>
      tfCount.setEditable(false);       <span class="color-comment">// set to read-only</span>
      add(tfCount);                     <span class="color-comment">// &quot;super&quot; Frame container adds TextField component</span>

      btnCount = new Button(&quot;Count&quot;);   <span class="color-comment">// construct the Button component</span>
      add(btnCount);                    <span class="color-comment">// &quot;super&quot; Frame container adds Button component</span>

      btnCount.addActionListener(new BtnCountListener());  <span class="color-comment">// anonymous instance</span>
      <span class="color-comment">// same as</span>
      //BtnCountListener listener = new BtnCountListener();
      //btnCount.addActionListener(listener);
         <span class="color-comment">// &quot;btnCount&quot; is the source object that fires an ActionEvent when clicked.</span>
         <span class="color-comment">// The source object adds an instance of BtnCountListener as an ActionEvent listener,</span>
         <span class="color-comment">//   which provides an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Clicking &quot;Count&quot; button calls back actionPerformed().</span>

      setTitle(&quot;AWT Counter&quot;);  <span class="color-comment">// &quot;super&quot; Frame sets its title</span>
      setSize(300, 100);        <span class="color-comment">// &quot;super&quot; Frame sets its initial window size</span>

      <span class="color-comment">// For inspecting the Container/Components objects</span>
      <span class="color-comment">// System.out.println(this);</span>
      <span class="color-comment">// System.out.println(lblCount);</span>
      <span class="color-comment">// System.out.println(tfCount);</span>
      <span class="color-comment">// System.out.println(btnCount);</span>
      setVisible(true);         <span class="color-comment">// &quot;super&quot; Frame shows</span>
      <span class="color-comment">// System.out.println(this);</span>
      <span class="color-comment">// System.out.println(lblCount);</span>
      <span class="color-comment">// System.out.println(tfCount);</span>
      <span class="color-comment">// System.out.println(btnCount);</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the constructor to setup the GUI, by allocating an instance</span>
      AWTCounter app = new AWTCounter();
         <span class="color-comment">// or simply &quot;new AWTCounter();&quot; for an anonymous instance</span>
   }

   <span class="color-comment">// Define an inner class to handle the &quot;Count&quot; button-click</span>
   private class BtnCountListener implements ActionListener {
      <span class="color-comment">// ActionEvent handler - Called back upon button-click.</span>
      @Override
      public void actionPerformed(ActionEvent evt) {
         ++count; <span class="color-comment">// Increase the counter value</span>
         <span class="color-comment">// Display the counter value on the TextField tfCount</span>
         tfCount.setText(count + &quot;&quot;); <span class="color-comment">// Convert int to String</span>
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>
	

<p>To exit this program, you have to close the CMD-shell (or press &quot;control-c&quot; on the CMD console); or push the &quot;red&quot; close button in Eclipse's Application Console.  This is because we have yet to write the handler for the <code>Frame</code>'s close button.  We shall do that in the later example.</p>

<p class="line-heading">Dissecting the <span class="font-code">AWTCounter.java</span></p>
<ul>
<li>The <code>import</code> statements (Lines 1-2) are needed, as AWT container and component classes, such as <code>Frame</code>, <code>Button</code>, <code>TextField</code>, and <code>Label,</code> are kept in the <code>java.awt</code> package; while AWT events and event-listener interfaces, such as <code>ActionEvent</code> and <code>ActionListener</code>  are kept in the <code>java.awt.event</code> package.</li>
<li>A GUI program needs a top-level container, and is often written as a subclass of <code>Frame</code> (Line 5). In other words, this class <code>AWTCounter</code> <em>is a</em> <code>Frame</code>, and inherits all the attributes and behaviors of a <code>Frame</code>, such as the title bar and content pane.</li>
<li>Lines 11 to 47 define a constructor, which is  used to setup the GUI components and event handlers.</li>
<li>In Line 13, the <code>setLayout()</code> (inherited from the superclass <code>Frame</code>) is used to set the layout of the container. <code>FlowLayout</code> is used which arranges the components in left-to-right and flows into next row in a top-to-bottom manner.</li>
<li>A <code>Label</code>, <code>TextField</code> (non-editable), and <code>Button</code> are constructed. We invoke the <code>add()</code> method (inherited from the superclass <code>Frame</code>) to add these components into container<code></code>.</li>
<li>In Line 36-37, we invoke the <code>setSize()</code> and the <code>setTitle()</code> (inherited from the superclass <code>Frame</code>) to set the initial size and the title of the <code>Frame</code>. The <code>setVisible(true)</code> method (Line 42) is then invoked to show the display.</li>
<li>Line 27 (or Line 29-30) is used to setup the callback event-handler, which will be discussed in length later. In brief,  whenever the button is clicked, the <code>actionPerformed()</code> will be called. In the <code>actionPerformed()</code> (Lines 61-66), the counter value increases by 1 and displayed on the <code>TextField</code>.</li>
<li>In the entry<code> main()</code> method (Lines 52-56), an instance of <code>AWTCounter</code> is constructed. The constructor is executed to initialize the GUI components and setup the event-handlers. The GUI program then waits for the user action.</li>
</ul>

<h5>Inspecting Container/Components via <span class="font-code">toString()</span></h5>
<p>It is interesting to inspect the GUI objects via the <code>toString()</code>, to gain an insight to these classes. (Alternatively, use a graphic debugger in Eclipse/NetBeans or study the JDK source code.) For example, if we insert the following code before and after the <code>setVisible()</code>:</p>
<pre class="color-example">
System.out.println(this);
<span class="color-comment">//<span class="color-output">AWTCounter[frame0,93,0,300x100,<span class="color-new">invalid</span>,<span class="color-new">hidden</span>,layout=java.awt.FlowLayout,title=AWT Counter,resizable,normal]</span>
   // name (assigned by compiler) is "frame0"; top-left (x,y) at (93,0); width/height is 300x100 (via setSize());</span>
System.out.println(lblCount);
<span class="color-comment">//<span class="color-output">java.awt.Label[label0,0,0,0x0,<span class="color-new">invalid</span>,align=left,text=Counter]</span>
   // name is &quot;Label0&quot;; align is &quot;Label.LEFT&quot; (default); text is &quot;Counter&quot; (assigned in constructor)</span>
System.out.println(tfCount);
<span class="color-comment">//j<span class="color-output">ava.awt.TextField[textfield0,0,0,0x0,<span class="color-new">invalid</span>,text=0,selection=0-0]</span>
   // name is &quot;Textfield0&quot;; text is &quot;0&quot; (assigned in constructor)</span>
System.out.println(btnCount);
<span class="color-comment">//<span class="color-output">java.awt.Button[button0,0,0,0x0,<span class="color-new">invalid</span>,label=Count]</span>
   // name is &quot;button0&quot;; label text is &quot;Count&quot; (assigned in constructor)</span>

<span class="color-comment"></span><span class="color-new">setVisible(true);</span>  <span class="color-comment">// &quot;super&quot; Frame shows</span>

System.out.println(this);
<span class="color-comment">//<span class="color-output">AWTCounter[frame0,93,0,300x100,<span class="color-new">invalid</span>,layout=java.awt.FlowLayout,title=AWT Counter,resizable,normal]</span></span>
System.out.println(lblCount);
<span class="color-comment">//<span class="color-output">java.awt.Label[label0,31,35,57x23,align=left,text=Counter]</span></span>
System.out.println(tfCount);
<span class="color-comment">//<span class="color-output">java.awt.TextField[textfield0,93,35,124x23,text=0,selection=0-0]</span></span>
System.out.println(btnCount);
<span class="color-comment">//<span class="color-output">java.awt.Button[button0,222,35,46x23,label=Count]</span></span></pre>


<h4>Example 2: <span class="font-code">AWTAccumulator</span></h4>

<img class="image-float-right" src="images/AWT_Accumulator.png" alt="AWT_Accumulator.png" />

<p>In this example, the top-level container is again the typical <code>java.awt.Frame</code>. It contains 4 components: a <code>Label</code> &quot;Enter an Integer&quot;, a <code>TextField</code> for accepting user input, another <code>Label</code> &quot;The Accumulated Sum is&quot;, and another non-editable <code>TextField</code> for displaying the sum. The components are arranged in <code>GridLayout</code> of 2 rows 2 columns.</p>

<p>The program shall accumulate the number entered into the <em>input</em> <code>TextField</code> and display the sum in the <em>output</em> <code>TextField</code>.</p>
	
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre>
</td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT container and component classes</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT event classes and listener interfaces</span>

<span class="color-comment">// An AWT GUI program inherits (customized) from the top-level container</span>
<span class="color-comment">//   java.awt.Frame</span>
public class <strong>AWTAccumulator</strong> extends Frame {
   <span class="color-comment">//private Label lblInput;   // Declare input Label (to use anonymous)</span>
   <span class="color-comment">//private Label lblOutput;  // Declare output Label (to use anonymous)</span>
   private TextField tfInput;  <span class="color-comment">// Declare input TextField</span>
   private TextField tfOutput; <span class="color-comment">// Declare output TextField</span>
   private int sum = 0;        <span class="color-comment">// Accumulated sum, init to 0</span>

   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTAccumulator() {
      setLayout(new GridLayout(2, 2));
         <span class="color-comment">// &quot;super&quot; Frame (Container) sets layout to GridLayout of 2 rows 2 columns.</span>

      add(new Label(&quot;Enter an Integer: &quot;));  <span class="color-comment">// &quot;super&quot; Frame adds an anonymous Label</span>

      tfInput = new TextField(10); <span class="color-comment">// Construct TextField</span>
      add(tfInput);                <span class="color-comment">// &quot;super&quot; Frame adds TextField</span>

      tfInput.addActionListener(new TFInputListener());  <span class="color-comment">// anonymous instance</span>
         <span class="color-comment">// &quot;tfInput&quot; is the source object that fires an ActionEvent upon entered.</span>
         <span class="color-comment">// The source add an anonymous instance of TFInputListener as an ActionEvent</span>
         <span class="color-comment">//   listener, which provides an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Hitting &quot;enter&quot; on tfInput invokes actionPerformed().</span>

      add(new Label(&quot;The Accumulated Sum is: &quot;));  <span class="color-comment">// &quot;super&quot; Frame adds an anonymous Label</span>

      tfOutput = new TextField(10); <span class="color-comment">// allocate TextField</span>
      tfOutput.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfOutput);                <span class="color-comment">// &quot;super&quot; Frame adds TextField</span>

      setTitle(&quot;AWT Accumulator&quot;);  <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(350, 120);  <span class="color-comment">// &quot;super&quot; Frame sets initial window size</span>
      setVisible(true);   <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the constructor to setup the GUI, by allocating an anonymous instance</span>
      new AWTAccumulator();
   }

   <span class="color-comment">// Define an inner class to handle the input TextField.</span>
   <span class="color-comment">// An ActionEvent listener must implement ActionListener interface.</span>
   private class TFInputListener implements ActionListener {
      <span class="color-comment">// ActionEvent handler - Called back upon hitting &quot;enter&quot; key on TextField</span>
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Get the String entered into the TextField tfInput, convert to int</span>
         int numberIn = Integer.parseInt(tfInput.getText());
         sum += numberIn;      <span class="color-comment">// Accumulate numbers entered into sum</span>
         tfInput.setText(&quot;&quot;);  <span class="color-comment">// Clear input TextField</span>
         tfOutput.setText(sum + &quot;&quot;); <span class="color-comment">// Display sum on the output TextField</span>
                                     <span class="color-comment">// convert int to String</span>
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="line-heading">Dissecting the <span class="font-code">AWTAccumulator.java</span></p>

<ol>
<li>An AWT GUI program extends from <code>java.awt.Frame</code> (Line 6) - the top-level window container.</li>
<li>In the constructor (Line 14), we constructs 4 components - 2 anonymous <code>java.awt.Label</code>s and 2 <code>java.awt.TextField</code>s. The <code>Frame</code> adds the components, in <code>GridLayout</code>.</li>
<li><code>tfInput</code> (<code>TextField</code>) is the source object, which fires an <code>ActionEvent</code> upon hitting the Enter key. <code>tfInput</code> adds an anonymous instance of <code>TFInputListener</code> as an <code>ActionEvent</code> handler (Line 23). The listener class needs to implement <code>ActionListener</code> interface and provides implementation to method <code>actionPerformed()</code>. Whenever an user hits Enter on the <code>tfInput</code> (<code>TextField</code>), the <code>actionPerformed()</code> will be called back.</li>
</ol>


<h3 id="awt_event_handling">AWT Event-Handling</h3>
<p>Java adopts the so-called &quot;Event-Driven&quot; (or &quot;Event-Delegation&quot;) programming model for  event-handling, similar to most of the visual programming languages like Visual Basic.  </p>
<p>In event-driven programming, a piece of event-handling codes is executed (or <em>called back</em> by the graphics subsystem) when an event was fired in response to an user input (such as clicking a mouse button or hitting the ENTER key in a text field).</p>

<h5>Callback Methods</h5>
<p>In the above examples, the method <code>actionPerformed()</code> is known as a <em>callback</em> method. In other words, you never invoke <code>actionPerformed()</code> in your codes explicitly. The <code>actionPerformed()</code> is <em>called back</em> by the graphics subsystem under certain circumstances in response to certain user actions.</p>

<h5>JavaScript can attach a Callback method to an Event Directly</h5>
<p>In some languages, you can directly attach a method (or function) to an event (such as mouse-click). For example, the following JavaScript code (called <code>JSCounter.html</code>) implement a counter similar to the <code>AWTCounter</code>, with a text label, text field and button:</p>
<img class="image-center" src="images/JSCounter.png" alt="JSCounter.png" />
<pre class="color-example">
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;JavaScript Counter&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
  Count: &lt;input id=&quot;tfCount&quot; type=&quot;text&quot; value=&quot;0&quot;&gt;
  &lt;input id=&quot;btnCount&quot; <span class="color-new">type=&quot;button&quot;</span> value=&quot;Hello&quot;
     <span class="color-new">onclick=myBtnOnClick() onmouseover=myBtnMouseOver() </span>&gt;
  &lt;/form&gt;
&lt;script&gt;
<span class="color-new">function myBtnOnClick() { tfCount.value++; }
function myBtnMouseOver() { btnCount.value = &quot;Count Up&quot;; }
function myBtnMouseOut() { btnCount.value = &quot;Click Me&quot;; }
btnCount.onmouseout = myBtnMouseOut;</span>  <span class="color-comment">// assign a function to a variable</span>
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>In Java, we CANNOT attach a method to a source object directly, as method is not a first-class object in Java. For example, a Java method cannot accept methods as its arguments and it cannot return a method; you cannot assign a method to a variable, etc. (JavaScript and C language CAN!).</p>
	
<h5>Source, Event and Listener Objects</h5>
<p>The AWT's event-handling classes are kept in package <code>java.awt.event</code>.</p>

<p>Three kinds of objects are involved in the event-handling: a <em>source</em>, <em>listener</em>(s) and an <em>event</em> object.</p>

<p>The <em>source</em> object (such as <code>Button</code> and <code>Textfield</code>) interacts with the user. Upon triggered, the source object creates an <em>event</em> object to capture the action (e.g., mouse-click x and y, texts entered, etc).  This <em>event</em> object will be messaged to all the <em>registered listener</em> object(s), and an appropriate event-handler method of the listener(s) is called-back to provide the response. In other words, <em>triggering a source fires an event to all its listener(s)</em>, <em>and invoke an appropriate event handler of the listener(s)</em>.</p>
<p> To express interest for a certain source's event, the listener(s) must be registered with the source. In other words, the listener(s) &quot;subscribes&quot; to a source's event, and the source &quot;publishes&quot; the event to all its subscribers upon activation. This is known as <em>subscribe-publish</em> or <em>observable-observer</em> design pattern.</p>

<img class="image-center" src="images/AWT_EventHandling.png" alt="AWT_EventHandling.png" />

<p>The sequence of steps is illustrated above:</p>
<ol>
<li><em>The source object registers its listener(s)</em> for a certain type of <em>event</em>.
<p>A source fires an event when triggered. For example, clicking a <code>Button</code> fires an <code>ActionEvent</code>, clicking a mouse button fires <code>MouseEvent</code>, typing a key fires <code>KeyEvent</code>, and etc.</p>
  <p>How the source and listener understand each other?  The answer is via an agreed-upon interface. For example, if a source is capable of firing an event called <code>XxxEvent</code> (e.g., <code>ActionEvent</code>). Firstly, we need to declare an interface called <code>XxxListener</code> (e.g., <code>ActionListener</code>) containing the names of  the handler methods (recall that an <code>interface</code> contains only <code>abstract</code> methods without implementation). For example, the <code>ActionListener</code> interface is declared as follows:</p>
<pre class="color-example">
<span class="color-comment">// An ActionListener interface, which declares the signature of the handlers</span>
public <strong>interface ActionListener</strong> {
   public void <strong>actionPerformed</strong>(ActionEvent evt);  
}</pre>

<p>Secondly, all <code>XxxEvent</code> listeners must implement the <code>XxxListener</code> interface. That is, the listeners must provide their own implementations (i.e., programmed responses) to all the <code>abstract</code> methods declared in the <code>XxxListener</code> interface. In this way, the listener(s) can response to these events appropriately. For example,</p>

<pre class="color-example">
<span class="color-comment">// An example of MouseListener,  which provides implementation to the event handler methods</span>
class MyActionListener <strong>implement ActionListener</strong> {
   @Override
   public void <strong>actionPerformed</strong>(ActionEvent evt)  { 
      System.out.println(&quot;ActionEvent detected!&quot;); 
   }
}</pre>

<p>Thirdly, in the source, we need to maintain a list of <code>XxxEvent</code> listener object(s), and define two methods: <code>addXxxListener()</code> and <code>removeXxxListener()</code> to add and remove a <code>XxxEvent</code> listener from this list. For the <code>ActionEvent</code>, the signature of the methods are:</p>

<pre class="color-example">
public void addActionListener(ActionListener lis);
public void removeActionListener(ActionListener lis);</pre>

<p>Take note that the <code>addXxxListener()</code> takes a <code>XxxListener</code> object as its sole parameter. In other words, it can only add objects of the type <code>XxxListener</code>, and its sub-type. Since <code>XxxListener</code> is an <code>interface</code>, you cannot create instance of <code>XxxListener</code>, but need to create instance of a subclass implementing the <code>XxxListener</code> <code>interface</code>.</p>
<p>In summary, we identify the source, the event-listener interface,  and the listener object. The listener must implement the event-listener interface. The source object then registers listener object via the <code>addXxxListener(XxxListener lis)</code> method.</p>
</li>

<li>The source is  triggered by a user.</li>
<li>The source create a  <code>XxxEvent</code> object, which encapsulates the necessary information about the activation. For example, the <code>(x, y)</code> position of the mouse pointer, the text entered, etc.</li>

<li>Finally, for each of the <code>XxxEvent</code> listeners in the listener list, the source invokes the appropriate handler on the listener(s), which provides the programmed response.</li></ol>

<p>In summary, <em>triggering a source fires an event to all its registered listeners, and invoke an appropriate handler of the listener</em>.</p>

<h4>Revisit Example 1 <span class="font-code">AWTCounter</span>: <span class="font-code">ActionEvent</span> and <span class="font-code">ActionListener</span> Interface</h4>

<p>Clicking a <code>Button</code> (or hitting the &quot;Enter&quot; key on a <code>TextField</code>) fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s). An <code>ActionEvent</code> listener must implement the <code>ActionListener</code> interface, which declares one <code>abstract</code> method called <code>actionPerformed()</code> as follow:</p>

<pre class="color-syntax">
public interface ActionListener {
   public void <strong>actionPerformed</strong>(ActionEvent evt);
      <span class="color-comment">// Called back upon button-click (on Button), enter-key pressed (on TextField)</span>
}</pre>

<p>Here are the event-handling steps:</p>
<ul>
<li>We identify <code>btnCount</code> (of <code>Button</code>) as the <em>source</em> object.</li>
<li>Clicking <code>Button</code> fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s).</li>

<li>The listener(s) is required to implement <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> method to provide the response. In Line 56-65, we write an inner class called <code>BtnCountListener</code>, which override the <code>actionPerformed()</code> to increment and display the count. An <em>inner class</em> is a class defined inside an outer class, and it can access the private entities of the outer class. We will elaborate on the inner class in the next section.</li>

<li>The source object registers listener via the <code>addActionListener()</code>.  In this example, the <em>source</em> <code>btnCount</code> (<code>Button</code>) adds an instance of <code>BtnCountListener</code> as a <em>listener</em> via:

<pre class="color-example">
BtnCountListener listener = new BtnCountListener();
btnCount.addActionListener(listener);</pre>

<p>Note that <code>addActionListener()</code> takes an argument of the type <code>ActionListener</code>. <code>BtnCountListener</code>, which implements <code>ActionListener</code> interface (i.e., a subclass of <code>ActionListener</code>), is upcasted and passed to the <code>addActionListener()</code> method.</p>
</li>

<li>Upon button-click, the <code>btnCount</code> creates an <code>ActionEvent</code> object, and calls back the <code>actionPerformed(ActionEvent)</code> method of all its registered listener(s) with the <code>ActionEvent</code> object created:

  <pre class="color-example">
ActionEvent evt = new ActionEvent( ...... );<em>
listener</em>.actionPerformed(evt);   <span class="color-comment">// for all its listener(s)</span></pre>
</li>
</ul>

<p>The sequence diagram is as follows:</p>
<img class="image-center" src="images/AWT_ActionListener.png" alt="AWT_ActionListener.png" />
<img class="image-center" src="images/AWT_EventSeqDiagram.png" alt="AWT_EventSeqDiagram.png" />

<h4>Revisit Example 2 <span class="font-code">AWTAccumulator</span>: <span class="font-code">ActionEvent</span> and <span class="font-code">ActionListener</span> Interface</h4>

<p>In this example,</p>
<ol>
<li>We identify the <code>tfInput</code> (of <code>TextField</code>) as the source object.</li>
<li>Hitting the &quot;Enter&quot; key on a <code>TextField</code> fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s).</li>
<li>In Line 46-59, we define an <em>inner class</em> called <code>TFInputListener</code> as the <code>ActionEvent</code> listener.The <code>ActionEvent</code> listener is required to implement the <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> method to provide the programmed response upon activation.</li>
<li>The source object <code>tfInput</code> (of <code>TextField</code>) registers an anonymous instance of <code>TFInputListener</code> as its <code>ActionEvent</code> listener via the <code>tfInput.addActionListener(new TFInputListener())</code> (Line 23).</li>

</ol>

<h4>Example 3: <span class="font-code">WindowEvent</span> and <span class="font-code">WindowListener</span> Interface</h4>

<img class="image-float-right" src="images/AWT_WindowEventDemo.png" alt="AWT_WindowEventDemo.png" />

<p>A <code>WindowEvent</code> is fired (to all its <code>WindowEvent</code> listeners) when a window (e.g., <code>Frame</code>) has been opened/closed, activated/deactivated, iconified/deiconified via the 3 buttons at the top-right corner or other means. The source of  <code>WindowEvent</code> shall be a top-level window-container such as <code>Frame</code>.</p>

<p>A <code>WindowEvent</code> listener must implement <code>WindowListener</code> interface, which declares 7 <code>abstract</code> event-handling methods, as follows. Among them, the <code>windowClosing()</code>, which is called back upon clicking the window-close button, is the most commonly-used.</p>

<pre class="color-syntax float-clear">
public void <strong>windowClosing</strong>(WindowEvent evt)
   <span class="color-comment">// Called-back when the user attempts to close the window by clicking the window close button.
   // This is the most-frequently used handler.</span>
public void windowOpened(WindowEvent evt)
   <span class="color-comment">// Called-back the first time a window is made visible.</span>
public void windowClosed(WindowEvent evt)
   <span class="color-comment">// Called-back when a window has been closed as the result of calling dispose on the window.</span>
public void windowActivated(WindowEvent evt)
   <span class="color-comment">// Called-back when the Window is set to be the active Window.</span>
public void windowDeactivated(WindowEvent evt)
   <span class="color-comment">// Called-back when a Window is no longer the active Window.</span>
public void windowIconified(WindowEvent evt)
   <span class="color-comment">// Called-back when a window is changed from a normal to a minimized state.</span>
public void windowDeiconified(WindowEvent evt)
   <span class="color-comment">// Called-back when a window is changed from a minimized to a normal state.</span>
</pre>

<p>The following program added support for &quot;close-window button&quot; to &quot;<span class="color-new">Example 1: AWTCounter</span>&quot;.</p>
	
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70</pre>
</td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT containers and components</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT events classes and listener interfaces</span>

<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>WindowEventDemo</strong> extends Frame {

   private TextField tfCount;  <span class="color-comment">// Declare a TextField component</span>
   private Button btnCount;    <span class="color-comment">// Declare a Button component</span>
   private int count = 0;      <span class="color-comment">// Counter's value</span>

   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; Frame sets to FlowLayout</span>

      add(new Label(&quot;Counter&quot;));   <span class="color-comment">// &quot;super&quot; Frame adds an anonymous Label</span>

      tfCount = new TextField(&quot;0&quot;, 10); <span class="color-comment">// Construct the TextField</span>
      tfCount.setEditable(false);       <span class="color-comment">// read-only</span>
      add(tfCount);                     <span class="color-comment">// &quot;super&quot; Frame adds TextField</span>

      btnCount = new Button(&quot;Count&quot;);  <span class="color-comment">// Construct the Button</span>
      add(btnCount);                   <span class="color-comment">// &quot;super&quot; Frame adds Button</span>

      btnCount.addActionListener(new BtnCountListener());
        <span class="color-comment">// btnCount (source object) fires ActionEvent upon clicking</span>
        <span class="color-comment">// btnCount adds an anonymous instance of BtnCountListener</span>
        <span class="color-comment">//   as an ActionEvent listener</span>

      <span class="color-new">addWindowListener(new MyWindowListener());</span>
        <span class="color-comment">// &quot;super&quot; Frame (source object) fires WindowEvent.</span>
        <span class="color-comment">// &quot;super&quot; Frame adds an anonymous instance of MyWindowListener</span>
        <span class="color-comment">//   as a WindowEvent listener.</span>

      setTitle(&quot;WindowEvent Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(300, 100);            <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new WindowEventDemo();  <span class="color-comment">// Let the construct do the job</span>
   }

   <span class="color-comment">// Define an inner class to handle ActionEvent of btnCount</span>
   private class BtnCountListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         ++count;
         tfCount.setText(count + &quot;&quot;);
      }
   }

   <span class="color-comment">// Define an inner class to handle WindowEvent of this Frame</span>
   <span class="color-new">private class MyWindowListener implements WindowListener {
      <span class="color-comment">// Called back upon clicking close-window button</span>
      @Override
      public void windowClosing(WindowEvent evt) {
         System.exit(0);  <span class="color-comment">// Terminate the program</span>
      }

      <span class="color-comment">// Not Used, BUT need to provide an empty body to compile.</span>
      @Override public void windowOpened(WindowEvent evt) { }
      @Override public void windowClosed(WindowEvent evt) { }
      <span class="color-comment">// For Debugging</span>
      @Override public void windowIconified(WindowEvent evt) { System.out.println(&quot;Window Iconified&quot;); }
      @Override public void windowDeiconified(WindowEvent evt) { System.out.println(&quot;Window Deiconified&quot;); }
      @Override public void windowActivated(WindowEvent evt) { System.out.println(&quot;Window Activated&quot;); }
      @Override public void windowDeactivated(WindowEvent evt) { System.out.println(&quot;Window Deactivated&quot;); }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>


<p>In this example, we shall modify the earlier <code>AWTCounter</code> example to handle the <code>WindowEvent</code>. Recall that pushing the &quot;close-window&quot; button on the <code>AWTCounter</code> has no effect, as it did not handle the <code>WindowEvent</code> of <code>windowClosing()</code>. We included the <code>WindowEvent</code> handling codes in this example.</p>

<ol>
<li>We identify the <code>super</code> <code>Frame</code> as the source object.</li>
<li>The <code>Frame</code> fires the <code>WindowEvent</code> to all its registered <code>WindowEvent</code> listener(s).</li>
<li>In Line 53-69, we define an inner class called <code>MyWindowListener</code> as the <code>WindowEvent</code> listener. It is required to implement the <code>WindowListener</code> interface, which declares 7 abstract methods: <code>windowOpened()</code>, <code>windowClosed()</code>, <code>windowClosing()</code>, <code>windowActivated()</code>, <code>windowDeactivated()</code>, <code>windowIconified()</code> and <code>windowDeiconified()</code>.</li>
<li>We register an anonymous instance of <code>MyWindowListener</code> as the <code>WindowEvent</code> listener to the source <code>Frame</code> via method <code>addWindowListener(new MyWindowListener())</code>.</li>
<li>We override the <code>windowClosing()</code> handler to terminate the program using <code>System.exit(0)</code>. We ignore the other 6 handlers, but required to provide an empty body for compilation.</li>
</ol>

<p>The sequence diagram is as follow:</p>
<img class="image-center" src="images/AWT_WindowEventSeqDiagram.png" alt="AWT_WindowEventSeqDiagram.png" />

<h4 id="MouseEventDemo">Example 4: <span class="font-code">MouseEvent</span> and <span class="font-code">MouseListener</span> Interface</h4>
<p>A <code>MouseEvent</code> is fired when you press, release, or click (press followed by release) a mouse-button (left or right button) at the source object; or position the mouse-pointer at (enter) and away (exit) from the source object.</p>

<p>A <code>MouseEvent</code> listener must implement the <code>MouseListener</code> interface, which declares the following five <code>abstract</code> methods:</p>
<pre class="color-syntax">
public void <strong>mouseClicked</strong>(MouseEvent evt)
   <span class="color-comment">// Called-back when the mouse-button has been clicked (pressed followed by released) on the source.</span>
public void <strong>mousePressed</strong>(MouseEvent evt)
public void <strong>mouseReleased</strong>(MouseEvent evt)
   <span class="color-comment">// Called-back when a mouse-button has been pressed/released on the source.
   // A mouse-click invokes mousePressed(), mouseReleased() and mouseClicked().</span>
public void <strong>mouseEntered</strong>(MouseEvent evt)
public void <strong>mouseExited</strong>(MouseEvent evt) 
   <span class="color-comment">// Called-back when the mouse-pointer has entered/exited the source.</span></pre>

<img class="image-center" src="images/AWT_MouseEventDemo.png" alt="AWT_MouseEventDemo.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;

public class <strong>MouseEventDemo</strong> extends Frame {
   private TextField tfMouseX; <span class="color-comment">// to display mouse-click-x</span>
   private TextField tfMouseY; <span class="color-comment">// to display mouse-click-y</span>

   <span class="color-comment">// Constructor - Setup the UI components and event handlers</span>
   public MouseEventDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; frame sets its layout to FlowLayout</span>

      <span class="color-comment">// Label (anonymous)</span>
      add(new Label(&quot;X-Click: &quot;)); <span class="color-comment">// &quot;super&quot; frame adds Label component</span>

      <span class="color-comment">// TextField</span>
      tfMouseX = new TextField(10); <span class="color-comment">// 10 columns</span>
      tfMouseX.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfMouseX);                <span class="color-comment">// &quot;super&quot; frame adds TextField component</span>

      <span class="color-comment">// Label (anonymous)</span>
      add(new Label(&quot;Y-Click: &quot;)); <span class="color-comment">// &quot;super&quot; frame adds Label component</span>

      <span class="color-comment">// TextField</span>
      tfMouseY = new TextField(10);
      tfMouseY.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfMouseY);                <span class="color-comment">// &quot;super&quot; frame adds TextField component</span>

      <span class="color-new">addMouseListener(new MyMouseListener());</span>
          <span class="color-comment">// &quot;super&quot; frame (source) fires the MouseEvent.</span>
          <span class="color-comment">// &quot;super&quot; frame adds an anonymous instance of MyMouseListener</span>
          <span class="color-comment">//   as a MouseEvent listener.</span>

      setTitle(&quot;MouseEvent Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(350, 100);           <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);            <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }

   public static void main(String[] args) {
      new MouseEventDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }

   <span class="color-comment">// Define an inner class to handle MouseEvent</span>
   <span class="color-new">private class MyMouseListener implements MouseListener {
      <span class="color-comment">// Called back upon mouse clicked</span>
      @Override
      public void mouseClicked(MouseEvent evt) {
         tfMouseX.setText(evt.getX() + &quot;&quot;);
         tfMouseY.setText(evt.getY() + &quot;&quot;);
      }

      <span class="color-comment">// Not used - need to provide an empty body to compile.</span>
      @Override public void mousePressed(MouseEvent evt) { }
      @Override public void mouseReleased(MouseEvent evt) { }
      @Override public void mouseEntered(MouseEvent evt) { }
      @Override public void mouseExited(MouseEvent evt) { }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example, we setup a GUI with 4 components (two anonymous <code>Label</code>s and two non-editable <code>TextField</code>s) inside a top-level container <code>Frame</code>, arranged in <code>FlowLayout</code>.</p>

<p>To demonstrate the <code>MouseEvent</code>:</p>
<ol>
<li>We identity <code>super</code> <code>Frame</code> as the source object.</li>
<li>The <code>Frame</code>  fires a <code>MouseEvent</code> to all its <code>MouseEvent</code> listener(s) when you click/press/release a mouse-button or enter/exit with the mouse-pointer.</li>
<li>In Line 42-56, we define an inner class called <code>MyMouseListener</code> as the <code>MouseEvent</code> listener. It is required to implement the <code>MouseListener</code> interface, which declares 5 abstract methods: <code>mouseClicked()</code>, <code>mousePressed()</code>, <code>mouseReleased()</code>, <code>mouseEntered()</code>, and <code>mouseExit()</code>. We override the <code>mouseClicked()</code> to display the (x, y) coordinates of the mouse click on the two displayed <code>TextField</code>s. We ignore all the other handlers (for simplicity - but you need to provide an empty body for compilation).</li>
<li>We register an anonymous instance of <code>MyMouseListener</code> as the <code>MouseEvent</code> listener to <code>super</code> <code>Frame</code> (source) via the method <code>addMouseListener(new MyMouseListener())</code>.</li>
</ol>

<p><span class="line-heading">Try:</span> Include a <code>WindowListener</code> to handle the close-window button.</p>

<h4 id="MouseMotionDemo">Example 5: <span class="font-code">MouseEvent</span> and <span class="font-code">MouseMotionListener</span> Interface</h4>

<p>A <code>MouseEvent</code> is also fired when you move and drag the mouse pointer at the source object. But you need to use <code>MouseMotionListener</code> to handle the mouse-move and mouse-drag. The <code>MouseMotionListener</code> interface declares the following two abstract methods:</p>
<pre class="color-syntax">
public void <strong>mouseDragged</strong>(MouseEvent e)
   <span class="color-comment">// Called-back when a mouse-button is pressed on the source component and then dragged.</span>
public void <strong>mouseMoved</strong>(MouseEvent e)
   <span class="color-comment">// Called-back when the mouse-pointer has been moved onto the source component but no buttons have been pushed.</span></pre>

<img class="image-center" src="images/AWT_MouseMotionDemo.png" alt="AWT_MouseMotionDemo.png" />
	
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;

<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class <strong>MouseMotionDemo</strong> extends Frame {

   <span class="color-comment">// To display the (x, y) of the mouse-clicked</span>
   private TextField tfMouseClickX;
   private TextField tfMouseClickY;
   <span class="color-comment">// To display the (x, y) of the current mouse-pointer position</span>
   private TextField tfMousePositionX;
   private TextField tfMousePositionY;

   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public MouseMotionDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; frame sets to FlowLayout</span>

      add(new Label(&quot;X-Click: &quot;));
      tfMouseClickX = new TextField(10);
      tfMouseClickX.setEditable(false);
      add(tfMouseClickX);
      add(new Label(&quot;Y-Click: &quot;));
      tfMouseClickY = new TextField(10);
      tfMouseClickY.setEditable(false);
      add(tfMouseClickY);

      add(new Label(&quot;X-Position: &quot;));
      tfMousePositionX = new TextField(10);
      tfMousePositionX.setEditable(false);
      add(tfMousePositionX);
      add(new Label(&quot;Y-Position: &quot;));
      tfMousePositionY = new TextField(10);
      tfMousePositionY.setEditable(false);
      add(tfMousePositionY);

      <span class="color-new">MyMouseListener listener = new MyMouseListener();
      addMouseListener(listener);
      addMouseMotionListener(listener);</span>
        <span class="color-comment">// &quot;super&quot; frame (source) fires MouseEvent.</span>
        <span class="color-comment">// &quot;super&quot; frame adds an instance of MyMouseListener</span>
        <span class="color-comment">//   as MouseListener and MouseMotionListener.</span>

      setTitle(&quot;MouseMotion Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(400, 120);            <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new MouseMotionDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }

   <span class="color-comment">// Define an inner class as both the MouseListener and MouseMotionListener
   // A Java class can extend one superclass but implement many interfaces</span>
   <span class="color-new">private class MyMouseListener implements MouseListener, MouseMotionListener {
      <span class="color-comment">/* MouseListener handlers */</span>
      <span class="color-comment">// Called back when a mouse-button has been clicked</span>
      @Override
      public void mouseClicked(MouseEvent evt) {
         tfMouseClickX.setText(evt.getX() + &quot;&quot;);
         tfMouseClickY.setText(evt.getY() + &quot;&quot;);
      }

      <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
      @Override public void mousePressed(MouseEvent evt) { }
      @Override public void mouseReleased(MouseEvent evt) { }
      @Override public void mouseEntered(MouseEvent evt) { }
      @Override public void mouseExited(MouseEvent evt) { }

      <span class="color-comment">/* MouseMotionEvent handlers */</span>
      <span class="color-comment">// Called back when the mouse-pointer has been moved</span>
      @Override
      public void mouseMoved(MouseEvent evt) {
         tfMousePositionX.setText(evt.getX() + &quot;&quot;);
         tfMousePositionY.setText(evt.getY() + &quot;&quot;);
      }

      <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
      @Override public void mouseDragged(MouseEvent evt) { }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example, we shall illustrate both the <code>MouseListener</code> and <code>MouseMotionListener</code>.</p>

<ol>
<li>We identify the <code>super</code> <code>Frame</code> as the source, which fires the <code>MouseEvent</code> to its registered <code>MouseListener</code> and <code>MouseMotionListener</code><code></code>.</li>
<li>In Line 53-80, we define an inner class called <code>MyMouseListener</code> as both the <code>MouseListener</code> and <code>MouseMotionListener</code>.</li>
<li>We register an instance of <code>MyMouseListener</code> as the<code> </code>listener to <code>super</code> <code>Frame</code> via method <code>addMouseListener()</code> and <code>addMouseMotionListener()</code>.</li>
<li>The <code>MouseMotionListener</code> needs to implement 2 abstract methods: <code>mouseMoved()</code> and <code>mouseDragged()</code> declared in the <code>MouseMotionListener</code> interface.</li>
<li>We override the <code>mouseMoved()</code> to display the (x, y) position of the mouse pointer. We ignore the <code>MouseDragged()</code> handler by providing an empty body for compilation.</li>
</ol>

<p><span class="line-heading">Try:</span> Include a <code>WindowListener</code> to handle the close-window button.</p>

<h4 id="KeyEventDemo">Example 6: <span class="font-code">KeyEvent</span> and <span class="font-code">KeyListener</span> Interface</h4>

<p>A <code>KeyEvent</code> is fired when you pressed, released, and typed (pressed followed by released) a key on the source object. A <code>KeyEvent</code> listener must implement <code>KeyListener</code> interface, which declares three abstract methods:</p>

<pre class="color-syntax">
public void <strong>keyTyped</strong>(KeyEvent e)
   <span class="color-comment">// Called-back when a key has been typed (pressed and released).</span>
public void <strong>keyPressed</strong>(KeyEvent e)
public void <strong>keyReleased</strong>(KeyEvent e)
   <span class="color-comment">// Called-back when a key has been pressed or released.</span></pre>

<img class="image-center" src="images/AWT_KeyEventDemo.png" alt="AWT_KeyEventDemo.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;

<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class <strong>KeyEventDemo</strong> extends Frame {

   private TextField tfInput;  <span class="color-comment">// Single-line TextField to receive tfInput key</span>
   private TextArea taDisplay; <span class="color-comment">// Multi-line TextArea to taDisplay result</span>

   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public KeyEventDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; frame sets to FlowLayout</span>

      add(new Label(&quot;Enter Text: &quot;));
      tfInput = new TextField(10);
      add(tfInput);
      taDisplay = new TextArea(5, 40); <span class="color-comment">// 5 rows, 40 columns</span>
      add(taDisplay);

      <span class="color-new">tfInput.addKeyListener(new MyKeyListener());</span>
         <span class="color-comment">// tfInput TextField (source) fires KeyEvent.</span>
         <span class="color-comment">// tfInput adds an anonymous instance of MyKeyListener</span>
         <span class="color-comment">//   as a KeyEvent listener.</span>

      setTitle(&quot;KeyEvent Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(400, 200);         <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);          <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new KeyEventDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }

   <span class="color-comment">// Define an inner class to handle KeyEvent</span>
   <span class="color-new">private class MyKeyListener implements KeyListener {
      <span class="color-comment">// Called back when a key has been typed (pressed and released)</span>
      @Override
      public void keyTyped(KeyEvent evt) {
         taDisplay.append(&quot;You have typed &quot; + evt.getKeyChar() + &quot;\n&quot;);
      }

      <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
      @Override public void keyPressed(KeyEvent evt) { }
      @Override public void keyReleased(KeyEvent evt) { }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example:</p>

<ol>
<li>We identify the <code>tfInput</code> (of <code>TextField</code>) as the source object.</li>
<li>The source fires a <code>KeyEvent</code> when you press/release/type a key to all its <code>KeyEvent</code> listener(s).</li>
<li>In Line 35-46, we define an inner class called <code>MyKeyListener</code> as the <code>KeyEvent</code> listener.</li>
<li>We register an anonymous instance of <code>MyKeyListener</code> as the <code>KeyEvent</code> listener to the source <code>TextField</code> via method <code>input.addKeyListener()</code>.</li>
<li>The <code>KeyEvent</code> listener needs to implement the <code>KeyListener</code> interface, which declares 3 abstract methods: <code>keyTyped()</code>, <code>keyPressed()</code>, <code>keyReleased()</code>.</li>
<li>We override the <code>keyTyped()</code> to display key typed on the display <code>TextArea</code>. We ignore the <code>keyPressed()</code> and <code>keyReleased()</code>.</li>
</ol>

<h3 id="innerclass">Nested (Inner) Classes</h3>
<h4>Without Inner classes</h4>
<p>In our <code>AWTCounter</code> example, suppose we would like to write an external ordinary class (say <code>MyExternalBtnListener</code>) as our <code>ActionEvent</code> listener. This class shall implement <code>ActionListener</code> interface and override the <code>actionPerformed()</code> method. An example is as follows:</p>
	
<pre class="color-example">
import java.awt.*;        <span class="color-comment">// Using AWT container and component classes</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT event classes and listener interfaces</span>

<span class="color-comment">// An AWT program inherits from the top-level container java.awt.Frame</span>
public class <strong>AWTCounterExternal</strong> extends Frame {
   private Label lblCount;    <span class="color-comment">// Declare a Label component</span>
   private TextField tfCount; <span class="color-comment">// Declare a TextField component</span>
   private Button btnCount;   <span class="color-comment">// Declare a Button component</span>
   private int count = 0;     <span class="color-comment">// Counter's value</span>

   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTCounterExternal () {
      setLayout(new FlowLayout());
         <span class="color-comment">// &quot;super&quot; Frame, which is a Container, sets its layout to FlowLayout to arrange</span>
         <span class="color-comment">// the components from left-to-right, and flow to next row from top-to-bottom.</span>

      lblCount = new Label(&quot;Counter&quot;);  <span class="color-comment">// construct the Label component</span>
      add(lblCount);                    <span class="color-comment">// &quot;super&quot; Frame container adds Label component</span>

      tfCount = new TextField(count + &quot;&quot;, 10); <span class="color-comment">// construct the TextField component with initial text</span>
      tfCount.setEditable(false);       <span class="color-comment">// set to read-only</span>
      add(tfCount);                     <span class="color-comment">// &quot;super&quot; Frame container adds TextField component</span>

      btnCount = new Button(&quot;Count&quot;);   <span class="color-comment">// construct the Button component</span>
      add(btnCount);                    <span class="color-comment">// &quot;super&quot; Frame container adds Button component</span>

      MyExternalBtnListener listener = new MyExternalBtnListener();
      btnCount.addActionListener(listener);
         <span class="color-comment">// &quot;btnCount&quot; is the source object that fires an ActionEvent when clicked.</span>
         <span class="color-comment">// The source add an instance of MyExternalBtnListener as an ActionEvent listener,
         //   which provides an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Clicking &quot;btnCount&quot; invokes actionPerformed().</span>

      setTitle(&quot;AWT Counter&quot;);  <span class="color-comment">// &quot;super&quot; Frame sets its title</span>
      setSize(250, 100);        <span class="color-comment">// &quot;super&quot; Frame sets its initial window size</span>

      <span class="color-comment">// For inspecting the Container/Components objects</span>
      <span class="color-comment">// System.out.println(this);</span>
      <span class="color-comment">// System.out.println(lblCount);</span>
      <span class="color-comment">// System.out.println(tfCount);</span>
      <span class="color-comment">// System.out.println(btnCount);</span>
      setVisible(true);         <span class="color-comment">// &quot;super&quot; Frame shows</span>
      <span class="color-comment">// System.out.println(this);</span>
      <span class="color-comment">// System.out.println(lblCount);</span>
      <span class="color-comment">// System.out.println(tfCount);</span>
      <span class="color-comment">// System.out.println(btnCount);</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the constructor to setup the GUI, by allocating an instance</span>
      AWTCounterExternal app = new AWTCounterExternal();
         <span class="color-comment">// or simply &quot;new AWTCounter();&quot; for an anonymous instance</span>
   }
}

<span class="color-comment">// We write an external class as the Button's ActionEvent listener.</span>
<span class="color-comment">// This class must implement ActionListener interface and override</span>
<span class="color-comment">// the actionPerformed() method.</span>
<span class="color-new">class MyExternalBtnListener implements ActionListener {</span>
   <span class="color-comment">// ActionEvent handler - Called back upon button-click.</span>
   <span class="color-new">@Override
   public void actionPerformed(ActionEvent evt) {
      System.out.println(&quot;You clicked the button!&quot;);</span>

     <span class="color-comment">// Cannot access variables count and tfCount!!!</span>
     <span class="color-comment">//</span> ++count; <span class="color-comment">// Increase the counter value</span>
     <span class="color-comment">//</span> tfCount.setText(count + &quot;&quot;); <span class="color-comment">// Convert int to String</span>
   <span class="color-new">}
}</span></pre>

<p>Can you see the problem? This external class cannot access the variables such as <code>count</code> and <code>tfCount</code> in the <code>AWTCounterExternal</code> class.  We can fix this problem, but the solution is messy. An easy solution is to use an inner class instead of an ordinary external class (to be explained in the following sections).</p>

<h4>What are Inner classes?</h4>

<p>A <em>nested class</em> (or commonly called <em>inner class</em>) is <em>a class defined inside another class</em> - introduced in JDK 1.1.  As an illustration, two nested classes <code>MyNestedClass1</code> and <code>MyNestedClass2</code> are defined <em>inside</em> the definition of an outer class called <code>MyOuterClass</code>.</p>

<pre class="color-example">
public <span class="color-new">class</span> MyOuterClass {   <span class="color-comment">// outer class defined here</span>
   ......
   private <span class="color-new">class</span> MyNestedClass1 { ...... }  <span class="color-comment">// an nested class defined inside the outer class</span>
   public static <span class="color-new">class</span> MyNestedClass2 { ...... }  <span class="color-comment">// an &quot;static&quot; nested class defined inside the outer class</span>
   ......
}</pre>

<p>A nested class has these properties:</p>

<ol>
<li>A nested class is a proper class. That is, it could contain constructors, member variables and member methods. You can create an instance of a nested class via the <code>new</code> operator and constructor.</li>
<li>A nested class is a <em>member</em> of the outer class, just like any member variables and methods defined inside a class.</li>

<li>Most importantly, a nested class can access the <code>private</code> members (variables/methods) of the enclosing outer class, as it is at the <em>same level</em> as these <code>private</code> members. This is the property that makes inner class useful.</li>
<li>A nested class can have <code>private</code>, <code>public</code>, <code>protected</code>, or the <em>default</em> access, just like any member variables and methods defined inside a class. A <code>private</code> inner class is only accessible by the enclosing outer class, and is not accessible by any other classes.  [An top-level outer class cannot be declared <code>private</code>, as no one can use a <code>private</code> outer class.]</li>
<li>A nested class can also be declared <code>static</code>, <code>final</code> or <code>abstract</code>, just like any ordinary class.</li>

<li>A nested class is NOT a <em>subclass</em> of the outer class.  That is, the nested class does not inherit the variables and methods of the outer class.  It is an <em>ordinary</em> self-contained class. [Nonetheless, you could declare it as a subclass of the outer class, via keyword &quot;<code>extends <em>OuterClassName</em></code>&quot;, in the nested class's definition.]</li>
</ol>

<p>The usages of nested class are:</p>
<ol>
<li>To control visibilities (of the member variables and methods) between inner/outer class.  The nested class, being defined inside an outer class, can access <code>private</code> members of the outer class.</li>
<li>To place a piece of class definition codes <em>closer</em> to where it is going to be used, to make the program clearer and easier to understand.</li>
<li>For namespace management.</li>
</ol>

<h4>Example 7: A Named Inner Class as Event Listener (Revisit Example 1 <span class="font-code">AWTCounter</span>)</h4>

<p>A nested class is useful if you need a <em>small</em> class which relies on the enclosing outer class for its private variables and methods.  It is ideal in an event-driven environment for implementing event handlers.  This is because the event handling methods (in a listener) often require access to the private variables (e.g., a private <code>TextField</code>) of the outer class.</p>

<p>In this example (revisit Example 1 <code>AWTCounter</code>), we define an inner class called <code>BtnCountListener</code>, and create an  instance of <code>BtnCountListener</code> as the <code>ActionEvent</code> listener for the <code>btnCount</code>. The <code>BtnCountListener</code> needs to implement the <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> handler. <code>BtnCountListener</code> needs to be defined as an inner class, as it needs to access private variables (<code>count</code> and <code>tfCount</code>) of the outer class.</p>

<table class="table-program">
  <col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class <strong>AWTCounter</strong> extends Frame {
 
   <span class="color-comment">// The event-handler actionPerformed() needs to access these &quot;private&quot; variables</span>
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter() {
      setLayout(new FlowLayout());  <span class="color-comment">// &quot;super&quot; Frame sets to FlowLayout</span>
      add(new Label(&quot;Counter&quot;));    <span class="color-comment">// An anonymous instance of Label</span>
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);   <span class="color-comment">// read-only</span>
      add(tfCount);                 <span class="color-comment">// &quot;super&quot; Frame adds tfCount</span>
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);                <span class="color-comment">// &quot;super&quot; Frame adds btnCount</span>
 
      <span class="color-comment">// Construct an anonymous instance of BtnCountListener (a named inner class).</span>
      <span class="color-comment">// btnCount adds this instance as a ActionListener.</span>
      <span class="color-new">btnCount.addActionListener(new BtnCountListener());</span>
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter(); <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnCountListener is a &quot;named inner class&quot; used as ActionListener.
    * This inner class can access private variables of the outer class.
    */</span>
   <span class="color-new">private class <strong>BtnCountListener</strong> implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         ++count;
         tfCount.setText(count + &quot;&quot;);
      }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>An inner class named <code>BtnCountListener</code> is used as the <code>ActionListener</code>.</li>
<li>An anonymous instance of the <code>BtnCountListener</code> inner class is constructed. The <code>btnCount</code> source object adds this instance as a listener, as follows:
  <pre class="color-example">
btnCount.addActionListener(new BtnCountListener());
</pre>
</li>

<li>The inner class can access the <code>private</code> variable <code>tfCount</code> and <code>count</code> of the outer class.</li>
<li>The inner class is compiled into <code>AWTCount$BtnCountListener.class</code>, in the format of <code><em>OuterClassName$InnerClassName</em>.class</code>.</li>
</ul>

<h5>(Advanced) Using an Ordinary (Outer) Class as Listener</h5>
<p>Try moving the <code>BtnCountListener</code> class outside, and define it as an ordinary class. You would need to pass a reference of the <code>AWTCounter</code> into the constructor of <code>BtnCountListener</code>, and use this reference to access variables <code>tfCount</code> and <code>count</code>, through <code>public</code> getters or granting them to <code>public</code> access.</p>
<pre class="color-example">
<span class="color-comment">// An ordinary outer class used as ActionListener for the Button</span>
public class BtnCountListener implements ActionListener {
   <span class="color-comment">// private variable</span>
   AWTCounter frame;

   <span class="color-comment">// The constructor takes the AWT Frame as its argument</span>
   public BtnCountListener(AWTCounter frame) {
      this.frame = frame;
   }
   
   <span class="color-comment">// The event handler can access the private variables thru &quot;frame&quot;</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      frame.count++;
      frame.tfCount.setText(frame.count + &quot;&quot;);
   }
}</pre>

<p>This code is messy! Inner class provides a much cleaner solution!</p>

<h4>Example 8: An Anonymous Inner Class as Event Listener</h4>

<p>Instead of using a <em>named inner class</em> (called <code>BtnCountListener</code> in the previous example), we shall use an inner class without a name, known as <em>anonymous inner class</em> as the <code>ActionListener</code> in this example.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class <strong>AWTCounterAnonymousInnerClass</strong> extends Frame {
 
   <span class="color-comment">// The event-handler actionPerformed() needs to access these private variables</span>
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounterAnonymousInnerClass () {
      setLayout(new FlowLayout());  <span class="color-comment">// &quot;super&quot; Frame sets to FlowLayout</span>
      add(new Label(&quot;Counter&quot;));    <span class="color-comment">// An anonymous instance of Label</span>
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);   <span class="color-comment">// read-only</span>
      add(tfCount);                 <span class="color-comment">// &quot;super&quot; Frame adds tfCount</span>
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);                <span class="color-comment">// &quot;super&quot; Frame adds btnCount</span>
 
      <span class="color-comment">// Construct an anonymous instance of an anonymous class.</span>
      <span class="color-comment">// btnCount adds this instance as a ActionListener.</span>
      btnCount.addActionListener(<span class="color-new">new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      }</span>);
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounterAnonymousInnerClass(); <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>The anonymous inner class is given a name generated by the compiler, and compiled into <code><em>OuterClassName</em>$<em>n</em>.class</code>, where <em><code>n</code></em> is a running number of the inner classes of this outer class.</li>

<li>An anonymous instance of an anonymous inner class is constructed, and passed as the argument of the <code>addActionListener()</code> method as follows:
  
  <pre class="color-example">
btnCount.addActionListener(<span class="color-new">new ActionListener() {
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }
}</span>);</pre>
  
  <p>The above codes is equivalent to and compiled as:</p>
  <pre class="color-example">
private class <em><strong>N</strong></em> implements ActionListener {  <span class="color-comment">// <em>N</em> is a running number of the inner classes created</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }
}
btnCount.addActionListener(new <em><strong>N</strong></em>());

<span class="color-comment">// Or</span>
<em><strong>N</strong></em> <strong><em>n</em></strong> = new <em><strong>N</strong></em>()
btnCount.addActionListener(<strong><em>n</em></strong>);</pre></li>

<li>From JDK 8, you can write the event handler using &quot;Lambda Expression&quot; in a one-liner as follows:
  <pre class="color-example">
btnCount.addActionListener(<span class="color-new">evt -&gt; tfCount.setText(++count + "")</span>);</pre>
</li>
</ul>

<h5>Properties of Anonymous Inner Class</h5>
<ol>
<li>The anonymous inner class is define inside a method, instead of a member of the outer class (class member). It is <em>local</em> to the method and cannot be marked with access modifier (such as <code>public</code>, <code>private</code>) or <code>static</code>, just like any local variable of a method.</li>

<li>An anonymous inner class must always extend a superclass or implement an interface. The keyword &quot;<code>extends</code>&quot; or &quot;<code>implements</code>&quot; is NOT required in its declaration. An anonymous inner class must implement all the abstract methods in the superclass or in the interface.</li>
<li>An anonymous inner class always uses the default (no-arg) constructor from its superclass to create an instance. If an anonymous inner class implements an interface, it uses the <code>java.lang.Object()</code>.</li>
<li>An anonymous inner class is compiled into a class named <code>OuterClassName$<em>n</em>.class</code>, where <code><em>n</em></code> is a running number of inner classes within the outer class.</li>
<li>An instance of an anonymous inner class is constructed via this syntax:
<pre class="color-syntax">
new <em>SuperClassName</em>/<em>InterfaceName</em>() {  <span class="color-comment">// extends superclass or implements interface
                                      // invoke the default no-arg constructor or Object[]</span>
  <span class="color-comment">// Implement abstract methods in superclass/interface
  // More methods if necessary
  ......</span>
}</pre>

<p>The created instance can be assigned to a variable or used as an argument of a method.</p>
</li>
</ol>

<h4>Example 9: An Anonymous Inner Class for Each Source</h4>

<img class="image-float-right" src="images/AWT_Counter3Buttons.png" alt="AWT_Counter3Buttons.png" />
<p>Let's modify our <code>AWTCounter</code> example to include 3 buttons for counting up, counting down, and reset the count, respectively. We shall attach an anonymous inner class as the listener to each of buttons.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>AWTCounter3ButtonsAnonymousIC</strong> extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3ButtonsAnonymousIC() {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));   <span class="color-comment">// an anonymous instance of Label</span>
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfCount);                <span class="color-comment">// &quot;super&quot; Frame adds tfCount</span>
 
      btnCountUp = new Button(&quot;Count Up&quot;);
      add(btnCountUp);
      <span class="color-comment">// Construct an anonymous instance of an anonymous inner class.</span>
      <span class="color-comment">// The source Button adds the anonymous instance as ActionEvent listener</span>
      <span class="color-new">btnCountUp.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });</span>
 
      btnCountDown = new Button(&quot;Count Down&quot;);
      add(btnCountDown);
      <span class="color-new">btnCountDown.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            count--;
            tfCount.setText(count + &quot;&quot;);
         }
      });</span>
 
      btnReset = new Button(&quot;Reset&quot;);
      add(btnReset);
      <span class="color-new">btnReset.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            count = 0;
            tfCount.setText(&quot;0&quot;);
         }
      });</span>
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3ButtonsAnonymousIC();  <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>

<ol>
<li>Each of the <code>Button</code>s uses one anonymous instance of an anonymous inner class as its <code>ActionEvent</code> listener.</li>
</ol>

<h4>Example 10: Using the Same Listener Instance for All the Buttons</h4>

<p>If you use the same instance as the listener for all the 3 buttons, you need to determine which button has fired the event. It is because all the 3 buttons trigger the same event-handler method.</p>

<h5>Using <span class="font-code">ActionEvent</span>'s <span class="font-code">getActionCommand()</span></h5>

<p>In the following example, we use the same instance of a &quot;named&quot; inner class as the listener for all the 3 buttons. The listener needs to determine which button has fired the event. This can be accomplished via the <code>ActionEvent</code>'s <code>getActionCommand()</code> method, which returns the button's label.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>AWTCounter3Buttons1Listener</strong> extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3Buttons1Listener () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      <span class="color-comment">// Construct Buttons</span>
      btnCountUp = new Button(&quot;Count Up&quot;);
      add(btnCountUp);
      btnCountDown = new Button(&quot;Count Down&quot;);
      add(btnCountDown);
      btnReset = new Button(&quot;Reset&quot;);
      add(btnReset);
 
      <span class="color-comment">// Allocate an instance of the &quot;named&quot; inner class BtnListener.</span>
      <span class="color-new">AllButtonsListener listener = new AllButtonsListener();</span>
      <span class="color-comment">// Use the same listener instance for all the 3 Buttons.</span>
      <span class="color-new">btnCountUp.addActionListener(listener);
      btnCountDown.addActionListener(listener);
      btnReset.addActionListener(listener);</span>
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3Buttons1Listener();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * AllButtonsListener is an named inner class used as ActionEvent listener for all the Buttons.
    */</span>
   <span class="color-new">private class AllButtonsListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Need to determine which button fired the event.</span>
         <span class="color-comment">// the getActionCommand() returns the Button's label</span>
         String btnLabel = evt.getActionCommand();
         if (btnLabel.equals(&quot;Count Up&quot;)) {
            ++count;
         } else if (btnLabel.equals(&quot;Count Down&quot;)) {
            --count;
         } else {
            count = 0;
         }
         tfCount.setText(count + &quot;&quot;);
      }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Using <span class="font-code">getSource()</span> of <span class="font-code">EventObject</span></h5>
<p>Besides the <code>getActionCommand()</code>, which is only available for <code>ActionEvent</code>, you can use the <code>getSource()</code> method, which is available to all event objects, to retrieve a reference to the source object that has fired the event. <code>getSource()</code> returns a <code>java.lang.Object</code>. You may need to downcast it to the proper type of the source object. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
public class <strong>AWTCounter3ButtonsGetSource</strong> extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3ButtonsGetSource () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      <span class="color-comment">// Construct Buttons</span>
      btnCountUp = new Button(&quot;Count Up&quot;);
      add(btnCountUp);
      btnCountDown = new Button(&quot;Count Down&quot;);
      add(btnCountDown);
      btnReset = new Button(&quot;Reset&quot;);
      add(btnReset);
 
      <span class="color-comment">// Allocate an instance of inner class BtnListener.</span>
      <span class="color-new">AllButtonsListener listener = new AllButtonsListener();</span>
      <span class="color-comment">// Use the same listener instance to all the 3 Buttons.</span>
      <span class="color-new">btnCountUp.addActionListener(listener);
      btnCountDown.addActionListener(listener);
      btnReset.addActionListener(listener);</span>
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3ButtonsGetSource();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * AllButtonsListener is a named inner class used as ActionEvent listener for all the Buttons.
    */</span>
   <span class="color-new">private class AllButtonsListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Need to determine which button has fired the event.</span>
         Button source = (Button)evt.getSource();
               <span class="color-comment">// Get a reference of the source that has fired the event.</span>
               <span class="color-comment">// getSource() returns a java.lang.Object. Downcast back to Button.</span>
         if (source == btnCountUp) {
            ++count;
         } else if (source == btnCountDown) {
            --count;
         } else {
            count = 0;
         }
         tfCount.setText(count + &quot;&quot;);
      }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>


<h3>Event Listener's Adapter Classes</h3>

<h4>Example 11: <span class="font-code">WindowAdapter</span> for <span class="font-code">WindowListener</span></h4>

<h5>Using <span class="font-code">WindowListener</span> Interface</h5>

<p>Refer to the <code>WindowEventDemo</code>, a <code>WindowEvent</code> listener is required to implement the <code>WindowListener</code> interface, which declares 7 <code>abstract</code> methods. Although we are only interested in <code>windowClosing()</code>, we need to provide an empty body to the other 6 <code>abstract</code> methods in order to compile the program. This is tedious, e.g., we can rewrite the <code>WindowEventDemo</code> using an inner class implementing <code>ActionListener</code> as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>WindowEventDemoWithInnerClass</strong> extends Frame {
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemoWithInnerClass () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class</span>
      <span class="color-comment">// that implements WindowListener.</span>
      <span class="color-comment">// &quot;super&quot; Frame adds this instance as WindowEvent listener.</span>
      <span class="color-new">addWindowListener(new WindowListener() {
         @Override
         public void windowClosing(WindowEvent evt) {
            System.exit(0);  <span class="color-comment">// terminate the program</span>
         }
         <span class="color-comment">// Need to provide an empty body for compilation</span>
         @Override public void windowOpened(WindowEvent evt) { }
         @Override public void windowClosed(WindowEvent evt) { }
         @Override public void windowIconified(WindowEvent evt) { }
         @Override public void windowDeiconified(WindowEvent evt) { }
         @Override public void windowActivated(WindowEvent evt) { }
         @Override public void windowDeactivated(WindowEvent evt) { }
      });</span>
 
      setTitle(&quot;WindowEvent Demo&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new WindowEventDemoWithInnerClass();   <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Using <span class="font-code">WindowAdapter</span> Superclass</h5>

<p>An <em>adapter</em> class called <code>WindowAdapter</code> is therefore provided, which implements the <code>WindowListener</code> interface and provides default  implementations to all the 7 <code>abstract</code> methods.  You can then derive a subclass from <code>WindowAdapter</code> and override only methods of interest and leave the rest to their default implementation. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>WindowEventDemoAdapter</strong> extends Frame {
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemoAdapter () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class</span>
      <span class="color-comment">// that extends WindowAdapter.</span>
      <span class="color-comment">// &quot;super&quot; Frame adds the instance as WindowEvent listener.</span>
      <span class="color-new">addWindowListener(new WindowAdapter() {
         @Override
         public void windowClosing(WindowEvent evt) {
            System.exit(0);  <span class="color-comment">// Terminate the program</span>
         }
      });</span>
 
      setTitle(&quot;WindowEvent Demo&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">/** The entry main method */</span>
   public static void main(String[] args) {
      new WindowEventDemoAdapter();   <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Clearly, the adapter greatly simplifies the codes.</p>
	

<h4>Other Event-Listener Adapter Classes</h4>
<p>Similarly, adapter classes such as <code>MouseAdapter</code>,<code> MouseMotionAdapter</code>, <code>KeyAdapter</code>, <code>FocusAdapter</code> are available for <code>MouseListener</code>, <code>MouseMotionListener</code>, <code>KeyListener</code>, and <code>FocusListener</code>, respectively.</p>

<p>There is no <code>ActionAdapter</code> for <code>ActionListener</code>, because there is only one <code>abstract</code> method (i.e. <code>actionPerformed()</code>) declared in the <code>ActionListener</code> interface. This method has to be overridden and there is no need for an adapter.</p>
	
	
<h3>[SKIP] The Legacy &quot;<span class="font-code">this</span>&quot; Listener</h3>
<p>If you read some old books, you may find many examples that use &quot;<code>this</code>&quot; object as the event listener.</p>
<p>For example,</p>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67</pre>
</td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT containers and components</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT events classes and listener interfaces</span>

<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>ThisListenerDemo</strong> extends Frame
      <span class="color-new">implements ActionListener, WindowListener</span> {
      <span class="color-comment">// This class acts as listener for ActionEvent and WindowEvent</span>
      <span class="color-comment">// A Java class can extend only one superclass, but it can implement multiple interfaces.</span>

   private TextField tfCount;  <span class="color-comment">// Declare a TextField component</span>
   private Button btnCount;    <span class="color-comment">// Declare a Button component</span>
   private int count = 0;      <span class="color-comment">// Counter's value</span>

   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public ThisListenerDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; Frame sets to FlowLayout</span>

      add(new Label(&quot;Counter&quot;));   <span class="color-comment">// &quot;super&quot; Frame adds an anonymous Label</span>

      tfCount = new TextField(&quot;0&quot;, 10); <span class="color-comment">// Construct the TextField</span>
      tfCount.setEditable(false);       <span class="color-comment">// read-only</span>
      add(tfCount);                     <span class="color-comment">// &quot;super&quot; Frame adds TextField</span>

      btnCount = new Button(&quot;Count&quot;);  <span class="color-comment">// Construct the Button</span>
      add(btnCount);                   <span class="color-comment">// &quot;super&quot; Frame adds Button</span>

      <span class="color-new">btnCount.addActionListener(this);</span>
        <span class="color-comment">// btnCount (source object) fires ActionEvent upon clicking</span>
        <span class="color-comment">// btnCount adds &quot;this&quot; object as an ActionEvent listener</span>

      <span class="color-new">addWindowListener(this);</span>
        <span class="color-comment">// &quot;super&quot; Frame (source object) fires WindowEvent.</span>
        <span class="color-comment">// &quot;super&quot; Frame adds &quot;this&quot; object as a WindowEvent listener.</span>

      setTitle(&quot;WindowEvent Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(250, 100);            <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new ThisListenerDemo();  <span class="color-comment">// Let the construct do the job</span>
   }

   <span class="color-comment">/* ActionEvent handler */</span>
   <span class="color-new">@Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }</span>

   <span class="color-comment">/* WindowEvent handlers */</span>
   <span class="color-comment">// Called back upon clicking close-window button</span>
   <span class="color-new">@Override
   public void windowClosing(WindowEvent evt) {
      System.exit(0);  <span class="color-comment">// Terminate the program</span>
   }</span>

   <span class="color-comment">// Not Used, BUT need to provide an empty body to compile.</span>
   <span class="color-new">@Override public void windowOpened(WindowEvent evt) { }
   @Override public void windowClosed(WindowEvent evt) { }</span>
   <span class="color-comment">// For Debugging</span>
   <span class="color-new">@Override public void windowIconified(WindowEvent evt) { System.out.println(&quot;Window Iconified&quot;); }
   @Override public void windowDeiconified(WindowEvent evt) { System.out.println(&quot;Window Deiconified&quot;); }
   @Override public void windowActivated(WindowEvent evt) { System.out.println(&quot;Window Activated&quot;); }
   @Override public void windowDeactivated(WindowEvent evt) { System.out.println(&quot;Window Deactivated&quot;);</span> }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>There is only ONE class in this code. But this code is much harder to understand and seldom used nowadays. Using inner class is a better solution.</p>


<h3>Layout Managers and Panel</h3>
<p>A container has a so-called <em>layout manager</em> to arrange its components. The layout managers provide a level of abstraction to map your user interface on all windowing
systems, so that the layout can be <em>platform-independent</em>.</p>

<p>AWT provides the following layout managers (in package <code>java.awt</code>): <code>FlowLayout</code>, <code>GridLayout</code>, <code>BorderLayout</code>, <code>GridBagLayout</code>, <code>BoxLayout</code>, <code>CardLayout</code>, and others. Swing added more layout manager in package <code>javax.swing</code>, to be described later.</p>

<h5>Container's <span class="font-code">setLayout()</span> method</h5>
<p>A container has a <code>setLayout()</code> method to set its layout manager:</p>
<pre class="color-syntax">
<span class="color-comment">// java.awt.Container</span>
public void setLayout(LayoutManager mgr)</pre>

<p>To set up the layout of a <code>Container</code> (such as <code>Frame</code>, <code>JFrame</code>, <code>Panel</code>, or  <code>JPanel</code>), you have to:</p>
<ol>
<li>Construct an instance of the chosen layout object, via <code>new</code> and constructor, e.g., <code>new FlowLayout()</code>)</li>
<li>Invoke the <code>setLayout()</code> method of the <code>Container</code>, with the layout object created as the argument;</li>
<li>Place the GUI components into the <code>Container</code> using the <code>add()</code> method in the correct order; or into the correct zones.</li>
</ol>

<p>For example,</p>
<pre class="color-example">
<span class="color-comment">// Allocate a Panel (container)</span>
Panel pnl = new Panel();  
<span class="color-comment">// Allocate a new Layout object. The Panel container sets to this layout.</span>
pnl.setLayout(new FlowLayout());
<span class="color-comment">// The Panel container adds components in the proper order.</span>
pnl.add(new JLabel(&quot;One&quot;));
pnl.add(new JLabel(&quot;Two&quot;));
pnl.add(new JLabel(&quot;Three&quot;));
......</pre>

<h5>Container's <span class="font-code">getLayout()</span> method</h5>
<p>You can get the current layout via <code>Container</code>'s <code>getLayout()</code> method.</p>

<pre class="color-example">
Panel pnl = new Panel();
System.out.println(pnl.getLayout());
      <span class="color-comment">// java.awt.FlowLayout[hgap=5,vgap=5,align=center]</span></pre>
   
<h5>Panel's Initial Layout</h5>

<p><code>Panel</code> (and Swing's <code>JPanel</code>) provides a constructor to set its initial layout manager. It is because a primary function of <code>Panel</code> is to layout a group of component in a particular layout.</p>
<pre class="color-syntax">
public void Panel(LayoutManager <em>layout</em>)  
   <span class="color-comment">// Construct a Panel in the given layout
   // By default, Panel (and JPanel) has FlowLayout</span>
 
<span class="color-comment">// For example, create a Panel in BorderLayout</span>
Panel pnl = new Panel(new BorderLayout());</pre>

<h4><span class="font-code">FlowLayout</span></h4>

<img class="image-float-right" src="images/AWT_FlowLayout.gif" alt="AWT_FlowLayout.gif" />
<p>In the <code>java.awt.FlowLayout</code>, components are arranged from left-to-right inside the container in the order that they are added (via method <code>aContainer.add(aComponent)</code>).  When one row is filled, a new row will be started.  The actual appearance depends on the width of the display window.</p>


<p class="underline float-clear">Constructors</p>
<pre class="color-syntax">
public <strong>FlowLayout</strong>();
public <strong>FlowLayout</strong>(int <em>alignment</em>);
public <strong>FlowLayout</strong>(int <em>alignment</em>, int <em>hgap</em>, int <em>vgap</em>);
<span class="color-comment">  // <em>alignment</em>: FlowLayout.LEFT (or LEADING), FlowLayout.RIGHT (or TRAILING), or FlowLayout.CENTER
  // <em>hgap</em>, <em>vgap</em>: horizontal/vertical gap between the components
  // By default: <em>hgap</em> = 5, <em>vgap </em>= 5, <em>alignment </em>= FlowLayout.CENTER</span>
</pre>
  
<p class="underline">Example</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>AWTFlowLayoutDemo</strong> extends Frame {
   private Button btn1, btn2, btn3, btn4, btn5, btn6;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTFlowLayoutDemo () {
      <span class="color-new">setLayout(new FlowLayout());</span>
        <span class="color-comment"> // &quot;super&quot; Frame sets layout to FlowLayout, which arranges the components</span>
        <span class="color-comment"> // from left-to-right, and flow from top-to-bottom.</span>
 
      <span class="color-new">btn1 = new Button(&quot;Button 1&quot;);
      add(btn1);
      btn2 = new Button(&quot;This is Button 2&quot;);
      add(btn2);
      btn3 = new Button(&quot;3&quot;);
      add(btn3);
      btn4 = new Button(&quot;Another Button 4&quot;);
      add(btn4);
      btn5 = new Button(&quot;Button 5&quot;);
      add(btn5);
      btn6 = new Button(&quot;One More Button 6&quot;);
      add(btn6);</span>
 
      setTitle(&quot;FlowLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(280, 150);          <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTFlowLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4><span class="font-code">GridLayout</span></h4>

<img class="image-float-right" src="images/AWT_GridLayout.gif" alt="AWT_GridLayout.gif" />

<p>In <code>java.awt.GridLayout</code>, components are arranged in a grid (matrix) of rows and columns inside the <code>Container</code>.  Components are added in a left-to-right, top-to-bottom manner in the order they are added (via method <code><em>aContainer</em>.add(<em>aComponent</em>)</code>).</p>


<p class="underline float-clear">Constructors</p>
<pre class="color-syntax">
public <strong>GridLayout</strong>(int <em>rows</em>, int <em>columns</em>);
public <strong>GridLayout</strong>(int <em>rows</em>, int <em>columns</em>, int <em>hgap</em>, int <em>vgap</em>);
      <span class="color-comment">// By default: rows = 1, cols = 0, hgap = 0, vgap = 0</span></pre>

<p class="underline">Example</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>AWTGridLayoutDemo</strong> extends Frame {
   private Button btn1, btn2, btn3, btn4, btn5, btn6;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTGridLayoutDemo () {
      <span class="color-new">setLayout(new GridLayout(3, 2, 3, 3));</span>
        <span class="color-comment"> // &quot;super&quot; Frame sets layout to 3x2 GridLayout, horizontal and vertical gaps of 3 pixels</span>
 
     <span class="color-comment"> // The components are added from left-to-right, top-to-bottom</span>
      <span class="color-new">btn1 = new Button(&quot;Button 1&quot;);
      add(btn1);
      btn2 = new Button(&quot;This is Button 2&quot;);
      add(btn2);
      btn3 = new Button(&quot;3&quot;);
      add(btn3);
      btn4 = new Button(&quot;Another Button 4&quot;);
      add(btn4);
      btn5 = new Button(&quot;Button 5&quot;);
      add(btn5);
      btn6 = new Button(&quot;One More Button 6&quot;);
      add(btn6);</span>
 
      setTitle(&quot;GridLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(280, 150);          <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTGridLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4><span class="font-code">BorderLayout</span></h4>

<img class="image-float-right" src="images/AWT_BorderLayout.gif" alt="AWT_BorderLayout.gif" />

<p>In <code>java.awt.BorderLayout</code>, the container is divided into 5 zones: <code>EAST</code>, <code>WEST</code>, <code>SOUTH</code>, <code>NORTH</code>, and <code>CENTER</code>.  Components are added using method <code><em>aContainer</em>.add(<em>aComponent</em>, <em>zone</em>)</code>, where <code><em>zone</em></code> is either <code>BorderLayout.NORTH</code> (or <code>PAGE_START</code>), <code></code><code>BorderLayout.SOUTH</code> (or <code>PAGE_END</code>), <code>BorderLayout.WEST</code> (or <code>LINE_START</code>), <code>BorderLayout.EAST</code> (or <code>LINE_END</code>), or <code>BorderLayout.CENTER</code>.</p>

<p>You need not place components to all the 5 zones. The <code>NORTH</code> and <code>SOUTH</code> components may be stretched horizontally; the <code>EAST</code> and <code>WEST</code> components may be stretched vertically; the <code>CENTER</code> component may stretch both horizontally and vertically to fill any space left over.</p>

<p class="underline float-clear">Constructors</p>
<pre class="color-syntax">
public <strong>BorderLayout</strong>();
public <strong>BorderLayout</strong>(int <em>hgap</em>, int <em>vgap</em>);
      <span class="color-comment">// By default hgap = 0, vgap = 0</span></pre>

<p class="underline">Example</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>AWTBorderLayoutDemo</strong> extends Frame {
   private Button btnNorth, btnSouth, btnCenter, btnEast, btnWest;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTBorderLayoutDemo () {
      <span class="color-new">setLayout(new BorderLayout(3, 3));</span>
        <span class="color-comment"> // &quot;super&quot; Frame sets layout to BorderLayout,</span>
        <span class="color-comment"> // horizontal and vertical gaps of 3 pixels</span>
 
     <span class="color-comment"> // The components are added to the specified zone</span>
      <span class="color-new">btnNorth = new Button(&quot;NORTH&quot;);
      add(btnNorth, BorderLayout.NORTH);
      btnSouth = new Button(&quot;SOUTH&quot;);
      add(btnSouth, BorderLayout.SOUTH);
      btnCenter = new Button(&quot;CENTER&quot;);
      add(btnCenter, BorderLayout.CENTER);
      btnEast = new Button(&quot;EAST&quot;);
      add(btnEast, BorderLayout.EAST);
      btnWest = new Button(&quot;WEST&quot;);
      add(btnWest, BorderLayout.WEST);</span>
 
      setTitle(&quot;BorderLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(280, 150);            <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTBorderLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Using <span class="font-code">Panel</span>s as Sub-Container to Organize Components</h4>

<img class="image-float-right" src="images/Swing_JPanel.gif" alt="Swing_JPanel.gif" />

<p>An AWT <code>Panel</code>  is a rectangular pane, which can be used as sub-container to organized a group of related components in a specific layout (e.g., <code>FlowLayout</code>, <code>BorderLayout</code>). <code>Panel</code>s are <em>secondary</em> containers, which shall be added into a top-level container (such as <code>Frame</code>), or another <code>Panel</code>.</p>

<p>For example, the following figure shows a <code>Frame</code> in <code>BorderLayout</code> containing two <code>Panels</code> - <code>panelResult</code> in <code>FlowLayout</code>  and <code>panelButtons</code> in <code>GridLayout</code>. <code>panelResult</code> is added to the <code>NORTH</code>, and <code>panelButtons</code> is added to the <code>CENTER</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>AWTPanelDemo</strong> extends Frame {
   private Button[] btnNumbers; <span class="color-comment"> // Array of 10 numeric Buttons</span>
   private Button btnHash, btnStar;
   private TextField tfDisplay;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTPanelDemo () {
     <span class="color-comment"> // Set up display panel</span>
      Panel panelDisplay = new Panel(new FlowLayout());
      tfDisplay = new TextField(&quot;0&quot;, 20);
      panelDisplay.add(tfDisplay);
 
     <span class="color-comment"> // Set up button panel</span>
      Panel panelButtons = new Panel(new GridLayout(4, 3));
      btnNumbers = new Button[10];  <span class="color-comment">// Construct an array of 10 numeric Buttons</span>
      btnNumbers[1] = new Button(&quot;1&quot;);  <span class="color-comment">// Construct Button &quot;1&quot;</span>
      panelButtons.add(btnNumbers[1]);  <span class="color-comment">// The Panel adds this Button</span>
      btnNumbers[2] = new Button(&quot;2&quot;);
      panelButtons.add(btnNumbers[2]);
      btnNumbers[3] = new Button(&quot;3&quot;);
      panelButtons.add(btnNumbers[3]);
      btnNumbers[4] = new Button(&quot;4&quot;);
      panelButtons.add(btnNumbers[4]);
      btnNumbers[5] = new Button(&quot;5&quot;);
      panelButtons.add(btnNumbers[5]);
      btnNumbers[6] = new Button(&quot;6&quot;);
      panelButtons.add(btnNumbers[6]);
      btnNumbers[7] = new Button(&quot;7&quot;);
      panelButtons.add(btnNumbers[7]);
      btnNumbers[8] = new Button(&quot;8&quot;);
      panelButtons.add(btnNumbers[8]);
      btnNumbers[9] = new Button(&quot;9&quot;);
      panelButtons.add(btnNumbers[9]);
        <span class="color-comment">    // You should use a loop for the above statements!!!</span>
      btnStar = new Button(&quot;*&quot;);
      panelButtons.add(btnStar);
      btnNumbers[0] = new Button(&quot;0&quot;);
      panelButtons.add(btnNumbers[0]);
      btnHash = new Button(&quot;#&quot;);
      panelButtons.add(btnHash);
 
      setLayout(new BorderLayout()); <span class="color-comment"> // &quot;super&quot; Frame sets to BorderLayout</span>
      add(panelDisplay, BorderLayout.NORTH);
      add(panelButtons, BorderLayout.CENTER);
 
      setTitle(&quot;BorderLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(200, 200);            <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTPanelDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>GridBagLayout</h4>
<p><span class="line-heading">Reference:</span> Read &quot;How to Use GridBagLayout&quot; @ https://docs.oracle.com/javase/tutorial/uiswing/layout/gridbag.html.</p>

<h4>Example 1</h4>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre>
</td>
<td>
<pre>
import java.awt.*;
import javax.swing.*;

@SuppressWarnings(&quot;serial&quot;)
public class GridBagLayoutExample extends JPanel {
   JButton button1, button2, button3, button4, button5;

   <span class="color-comment">// Constructor</span>
   public GridBagLayoutExample() {
      super.setLayout(new GridBagLayout());  <span class="color-comment">// super JPanel</span>
      GridBagConstraints gbc = new GridBagConstraints();

      <span class="color-comment">// The following constraints are applicable to all components</span>
<span class="color-comment">//    gbc.fill = GridBagConstraints.HORIZONTAL;</span>

      <span class="color-comment">// Define constraints for individual components</span>
      button1 = new JButton(&quot;B1&quot;);
      gbc.gridx = 0;  <span class="color-comment">// column 0 (first column)</span>
      gbc.gridy = 0;  <span class="color-comment">// row 0 (first row)</span>
<span class="color-comment">//    gbc.weightx = 0.5;  // weight for distributing extra x-spaces</span>
      super.add(button1, gbc);  <span class="color-comment">// add and apply constraints</span>

      button2 = new JButton(&quot;B2&quot;);
      gbc.gridx = 1;  <span class="color-comment">// column 1</span>
      gbc.gridy = 0;  <span class="color-comment">// row 0</span>
<span class="color-comment">//    gbc.weightx = 1.0;</span>
      super.add(button2, gbc);

      button3 = new JButton(&quot;B3&quot;);
      gbc.gridx = 2;  <span class="color-comment">// column 2</span>
      gbc.gridy = 0;  <span class="color-comment">// row 0</span>
<span class="color-comment">//    gbc.weightx = 0.5;</span>
      super.add(button3, gbc);

      button4 = new JButton(&quot;Long-Named Button 4&quot;);
      gbc.gridx = 0;  <span class="color-comment">// column 0</span>
      gbc.gridy = 1;  <span class="color-comment">// row 1 (second row)</span>
      gbc.gridwidth = 3;  <span class="color-comment">// span 3 columns</span>
      gbc.ipady = 40;     <span class="color-comment">// internal padding-y</span>
      super.add(button4, gbc);

      button5 = new JButton(&quot;5&quot;);
      gbc.gridx = 1;      <span class="color-comment">// second column</span>
      gbc.gridy = 2;      <span class="color-comment">// third row</span>
      gbc.gridwidth = 2;  <span class="color-comment">// span 2 columns</span>
      gbc.ipady = 0;      <span class="color-comment">// reset to default</span>
      gbc.anchor = GridBagConstraints.PAGE_END; <span class="color-comment">// align at bottom of space</span>
      gbc.insets = new Insets(10, 0, 0, 0);     <span class="color-comment">// top margin</span>
<span class="color-comment">//    gbc.weighty = 1.0;  // request any extra vertical space</span>
      super.add(button5, gbc);
   }

   public static void main(String[] args) {
      javax.swing.SwingUtilities.invokeLater(new Runnable() {
         public void run() {
            JFrame frame = new JFrame(&quot;GridBagLayoutDemo&quot;);
            frame.setContentPane(new GridBagLayoutExample());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(300,300);
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Run the program, the output is in (a), where all components have their natural width and height, placed in center (<code>anchor=CENTER</code>) with extra x and y spaces at the 4 margins. The <code>ipady</code> increases the internal y-padding for button-4 (spans 3 columns). Button 5 (spans second and third columns) has top margin specified by <code>insets</code>, and anchor at the bottom-right corner (<code>anchor=PAGE_END</code>).</p>
<p>Uncomment the <code>gbc.fill = GridBagConstraints.HORIZONTAL</code> (line 14). The output is in (b), where ALL components fill horizontally with equal column width.</p>
<p>Uncomment all <code>weightx</code> (lines 20, 26, 32). The output is in (c). The extra x spaces are distributed according to the <code>weightx</code> of (0.5, 1.0, 0.5).</p>
<p>Uncomment the <code>weighty</code> (line 49). The output is in (d). The extra y spaces are given to row 3, as row 1 and 2 have <code>weighty</code> of 0 and non-participating in the distribution of extra y-spaces.</p>
<img src="images/GridLayoutExample1.png" alt="Grid Layout Example" />

<h4><span class="font-code">BoxLayout</span></h4>
<p>BoxLayout arrange components in a single row or column. It respects components' requests on the minimum sizes.</p>

<p>[TODO] Example and diagram</p>

<h3>Swing</h3>

<h4>Introduction</h4>
<p>Swing is part of the so-called &quot;Java Foundation Classes (JFC)&quot; (have you heard of MFC?), which was introduced in 1997 after the release of JDK 1.1.  JFC was subsequently included as an integral part of JDK since JDK 1.2. JFC consists of:</p>
<ul>
<li>Swing API: for advanced graphical programming.</li>
<li>Accessibility API: provides assistive technology for the disabled.</li>
<li>Java 2D API: for high quality 2D graphics and images.</li>
<li>Pluggable look and feel supports.</li>
<li>Drag-and-drop support between Java and native applications.</li>
</ul>

<p>The goal of Java GUI programming is to allow the programmer to build GUI that looks good on ALL platforms. JDK 1.0's AWT was awkward and non-object-oriented (using many <code>event.getSource()</code>). JDK 1.1's AWT introduced event-delegation (event-driven) model, much clearer and object-oriented. JDK 1.1 also introduced inner class and JavaBeans â a component programming model for visual programming environment (similar to Visual Basic).</p>

<p>Swing appeared after JDK 1.1. It was introduced into JDK 1.1 as part of an add-on JFC (Java Foundation Classes). Swing is a rich set of easy-to-use, easy-to-understand JavaBean GUI components that can be dragged and dropped as &quot;GUI builders&quot; in visual programming environment. Swing is now an integral part of Java since JDK 1.2.</p>

<h4>Swing's Features</h4>
<p>Swing is huge (consists of 18 packages of 737 classes as in JDK 1.8) and has great depth.  Compared with AWT, Swing provides a huge and comprehensive collection of reusable GUI components, as shown in the Figure below (extracted form Swing Tutorial).</p>

<img class="image-center" src="images/Swing_Components.png" alt="Swing_Components.png" />

<p>The main features of Swing are (extracted from the Swing website):</p>
<ol>
  <li>Swing is written in pure Java (except a few classes) and therefore is 100% portable.</li>
<li>Swing components are <em>lightweight</em>. The AWT components are <em>heavyweight</em> (in terms of system resource utilization). Each AWT component has its own opaque native display, and always displays on top of the lightweight components. AWT components rely heavily on the underlying windowing subsystem of the native operating system.  For example, an AWT button ties to an actual button in the underlying native windowing subsystem, and relies on the native windowing subsystem for their rendering and processing.  Swing components (<code>JComponent</code>s) are written in Java.  They are generally not &quot;weight-down&quot; by complex GUI considerations imposed by the underlying windowing subsystem.</li>
<li>Swing components support <em>pluggable look-and-feel</em>.  You can choose between <em>Java look-and-feel</em> and the <em>look-and-feel of the underlying OS</em> (e.g., Windows, UNIX or macOS).  If the later is chosen, a Swing button runs on the Windows looks like a Windows' button and feels like a Window's button.  Similarly, a Swing button runs on the UNIX looks like a UNIX's button and feels like a UNIX's button.<br />
<img src="images/Swing_LaFJava.png" alt="Swing_LaFJava.png" />
<img src="images/Swing_LaFNativeSystem.png" alt="Swing_LaFNativeSystem.png" /><br />
<img src="images/Swing_LaFNimbus.png" alt="Swing_LaFNimbus.png" />
<img src="images/Swing_LaFMotif.png" alt="Swing_LaFMotif.png" />
</li>

<li>Swing supports <em>mouse-less operation</em>, i.e., it can operate entirely using keyboard.</li>
<li>Swing components support &quot;tool-tips&quot;.</li>
<li>Swing components are <em>JavaBeans</em> â a Component-based Model used in Visual Programming (like Visual Basic).  You can drag-and-drop a Swing component into a &quot;design form&quot; using a &quot;GUI builder&quot; and double-click to attach an event handler.</li>
<li>Swing application uses AWT event-handling classes (in package <code>java.awt.event</code>).  Swing added some new classes in package <code>javax.swing.event</code>, but they are not frequently used.</li>
<li>Swing application uses AWT's layout manager (such as <code>FlowLayout</code> and <code>BorderLayout</code> in package <code>java.awt</code>).  It added new layout managers, such as <code>Springs</code>, <code>Struts</code>, and <code>BoxLayout</code> (in package <code>javax.swing</code>).</li>
<li>Swing implements <em>double-buffering</em> and automatic repaint batching for smoother screen repaint.</li>
<li>Swing introduces <code>JLayeredPane</code> and <code>JInternalFrame</code> for creating Multiple Document Interface (MDI) applications.</li>
<li>Swing supports floating toolbars (in <code>JToolBar</code>), splitter control, &quot;undo&quot;.</li>
<li>Others - check the Swing website.</li>
</ol>

<h4>Using Swing API</h4>

<p>If you understood the AWT programming (in particular, container/component and event-handling), switching over to Swing (or any other Graphics packages) is straight-forward.</p>

<h5>Swing's Components</h5>
<p>Compared with the AWT component classes (in package <code>java.awt</code>), Swing component classes (in package <code>javax.swing</code>) begin with a prefix <code>&quot;J&quot;</code>, e.g., <code>JButton</code>, <code>JTextField</code>, <code>JLabel</code>, <code>JPanel</code>, <code>JFrame</code>, or <code>JApplet</code>.</p>

<img class="image-center" src="images/Swing_ClassDiagram.png" alt="Swing_ClassDiagram.png" />

<p>The above figure shows the class hierarchy of the swing GUI classes.  Similar to AWT, there are two groups of classes: <em>container</em>s and <em>component</em>s.  A container is used to hold components.  A container can also hold containers because it is a (subclass of) component.</p>

<p>As a rule, do not mix heavyweight AWT components and lightweight Swing components in the same program, as the heavyweight components will always be painted <em>on top of</em> the lightweight components.</p>

<h5>Swing's Top-Level and Secondary Containers</h5>

<img class="image-float-right" src="images/Swing_ContentPane.png" alt="Swing_ContentPane.png" />

<p>Just like AWT application, a Swing application requires a <em>top-level container</em>.  There are three top-level containers in Swing:</p>
<ol>
<li><code>JFrame</code>:  used for the application's main window (with an icon, a title, minimize/maximize/close buttons, an optional menu-bar, and a content-pane), as illustrated.</li>
<li><code>JDialog</code>:  used for secondary pop-up window (with a title, a close button, and a content-pane).</li>
<li><code>JApplet</code>:  used for the applet's display-area (content-pane) inside a browserâs window.</li>
</ol>

<p>Similarly to AWT, there are <em>secondary containers</em> (such as <code>JPanel</code>) which can be used to group and layout relevant components.</p>

<h5>The Content-Pane of Swing's Top-Level Container</h5>

<p>However, unlike AWT, the <code>JComponents</code> shall not be added onto the top-level container (e.g., <code>JFrame</code>, <code>JApplet</code>) directly because they are lightweight components.  The <code>JComponents</code> must be added onto the so-called <em>content-pane</em> of the top-level container. Content-pane is in fact a <code>java.awt.Container</code> that can be used to group and layout components.</p>
<p>You could:</p>

<ol>
<li>get the content-pane via <code>getContentPane()</code> from a top-level container, and add components onto it. For example,
<pre class="color-example">
public class SwingDemo <strong>extends JFrame</strong> {
   <span class="color-comment">// Constructor</span>
   public SwingDemo() {
      <span class="color-comment">// Get the content-pane of this JFrame, which is a java.awt.Container
      // All operations, such as setLayout() and add() operate on the content-pane</span> 
      Container <strong>cp = getContentPane()</strong>; 
      <strong>cp.setLayout</strong>(new FlowLayout());
      <strong>cp.add</strong>(new JLabel(&quot;Hello, world!&quot;));
      <strong>cp.add</strong>(new JButton(&quot;Button&quot;));
      ......
   }
   .......
}</pre>

</li>
<li>set the content-pane to a <code>JPanel</code> (the main panel created in your application which holds all your GUI components) via <code>JFrame</code>'s <code>setContentPane()</code>.
<pre class="color-example">
public class SwingDemo <strong>extends JFrame</strong> {
   <span class="color-comment">// Constructor</span>
   public SwingDemo() {
      <span class="color-comment">// The &quot;main&quot; JPanel holds all the GUI components</span>
      <strong>JPanel mainPanel</strong> = new JPanel(new FlowLayout());
      mainPanel.add(new JLabel(&quot;Hello, world!&quot;));
      mainPanel.add(new JButton(&quot;Button&quot;));

      <span class="color-comment">// Set the content-pane of this JFrame to the main JPanel</span>
      <strong>setContentPane(mainPanel);</strong>
      ......
   }
   .......
}</pre>
</li>
</ol>

<p>Notes: If a component is added directly into a <code>JFrame</code>, it is added into the content-pane of <code>JFrame</code> instead, i.e.,</p>

<pre class="color-example">
<span class="color-comment">// Suppose that &quot;this&quot; is a JFrame</span>
add(new JLabel(&quot;add to JFrame directly&quot;));
<span class="color-comment">// is executed as</span>
getContentPane().add(new JLabel(&quot;add to JFrame directly&quot;));</pre>

<h5>Event-Handling in Swing</h5>
<p>Swing uses the AWT event-handling classes (in package <code>java.awt.event</code>).  Swing introduces a few new event-handling classes (in package <code>javax.swing.event</code>) but they are not frequently used.</p>

<h5>Writing Swing Applications</h5>

<p>In summary, to write a Swing application, you have:</p>
<ol>
<li>Use the Swing components with prefix <code>&quot;J&quot;</code> in package <code>javax.swing</code>, e.g., <code>JFrame</code>, <code>JButton</code>, <code>JTextField</code>, <code>JLabel</code>, etc.</li>
<li>A top-level container (typically <code>JFrame</code>) is needed.  The <code>JComponents</code> should not be added directly onto the top-level container. They shall be added onto the <em>content-pane</em> of the top-level container.  You can retrieve a reference to the content-pane by invoking method <code>getContentPane()</code> from the top-level container.</li>
<li>Swing applications uses AWT event-handling classes, e.g., <code>ActionEvent/ActionListener</code>, <code>MouseEvent/MouseListener</code>, etc.</li>
<li>Run the constructor in the Event Dispatcher Thread (instead of Main thread) for thread safety, as shown in the following program template.</li>
</ol>

<h4>Swing Program Template</h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT layouts</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;     <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits from top-level container javax.swing.JFrame</span>
public class <strong>SwingTemplate</strong> extends <span class="color-new">JFrame</span> {
 
   <span class="color-comment">// Private instance variables</span>
   <span class="color-comment">// ......</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingTemplate() {
      <span class="color-comment">// Retrieve the top-level content-pane from JFrame</span>
      <span class="color-new">Container cp = getContentPane();</span>
 
      <span class="color-comment">// Content-pane sets layout</span>
      <span class="color-new">cp.</span>setLayout(new ....Layout());
 
      <span class="color-comment">// Allocate the GUI components</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-comment">// Content-pane adds components</span>
      <span class="color-new">cp.</span>add(....);
 
      <span class="color-comment">// Source object adds listener</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-new">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span>
         <span class="color-comment">// Exit the program when the close-window button clicked</span>
      setTitle(&quot;......&quot;);  <span class="color-comment">// &quot;super&quot; JFrame sets title</span>
      setSize(300, 150);   <span class="color-comment">// &quot;super&quot; JFrame sets initial size</span>
      setVisible(true);    <span class="color-comment">// &quot;super&quot; JFrame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread-safety</span>
      <span class="color-new">SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingTemplate();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>I will explain this template in the following Swing example.</p>

<h4>Swing Example 1: <span class="font-code">SwingCounter</span></h4>

<img class="image-float-right" src="images/Swing_Counter.gif" alt="Swing_Counter.gif" />

<p>Let's convert the earlier AWT application example into Swing.  Compare the two source files and note the changes (which are highlighted).  The display is shown below.  Note the differences in <em>look and feel</em> between the AWT GUI components and Swing's.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using AWT layout</span>s
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits from top-level container javax.swing.JFrame</span>
public class <strong>SwingCounter</strong> extends <strong>JFrame</strong> {   <span class="color-comment">// JFrame instead of Frame</span>
   private <strong>JTextField</strong> tfCount;  <span class="color-comment">// Use Swing's JTextField instead of AWT's TextField</span>
   private <strong>JButton</strong> btnCount;    <span class="color-comment">// Using Swing's JButton instead of AWT's Button</span>
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingCounter() {
      <span class="color-comment">// Retrieve the content-pane of the top-level container JFrame</span>
      <span class="color-comment">// All operations done on the content-pane</span>
      <strong>Container cp = getContentPane();</strong>
      <strong>cp.</strong>setLayout(new FlowLayout());   <span class="color-comment">// The content-pane sets its layout</span>
 
      <strong>cp.</strong>add(new <strong>JLabel</strong>(&quot;Counter&quot;));
      tfCount = new <strong>JTextField</strong>(&quot;0&quot;);
      tfCount.setEditable(false);
      <strong>cp.</strong>add(tfCount);
 
      btnCount = new <strong>JButton</strong>(&quot;Count&quot;);
      <strong>cp.</strong>add(btnCount);
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class that</span>
      <span class="color-comment">//  implements ActionListener as ActionEvent listener</span>
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="color-comment">// Exit program if close-window button clicked</span>
      setTitle(&quot;Swing Counter&quot;); <span class="color-comment">// &quot;super&quot; JFrame sets title</span>
      setSize(300, 100);         <span class="color-comment">// &quot;super&quot; JFrame sets initial size</span>
      setVisible(true);          <span class="color-comment">// &quot;super&quot; JFrame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingCounter(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5><span class="font-code">JFrame</span>'s Content-Pane</h5>
<p>The <code>JFrame</code>'s method <code>getContentPane()</code> returns the content-pane (which is a <code>java.awt.Container</code>) of the <code>JFrame</code>. You can then set its layout (the default layout is <code>BorderLayout</code>), and add components into it. For example,</p>

<pre class="color-example">Container cp = getContentPane(); <span class="color-comment">// Get the content-pane of this JFrame</span>
cp.setLayout(new FlowLayout());  <span class="color-comment">// content-pane sets to FlowLayout</span>
cp.add(new JLabel(&quot;Counter&quot;));   <span class="color-comment">// content-pane adds a JLabel component</span>
......
cp.add(tfCount);    <span class="color-comment">// content-pane adds a JTextField component</span>
......
cp.add(btnCount);   <span class="color-comment">// content-pane adds a JButton component</span></pre>

<p>You can also use the <code>JFrame</code>'s <code>setContentPane()</code> method to directly set the content-pane to a <code>JPanel</code> (or a <code>JComponent</code>). For example,</p>

<pre class="color-example">
JPanel displayPanel = new JPanel();
setContentPane(displayPanel);
      <span class="color-comment">// &quot;this&quot; JFrame sets its content-pane to a JPanel directly</span>
.....
 
<span class="color-comment">// The above is different from:</span>
getContentPane().add(displayPanel);
    <span class="color-comment">  // Add a JPanel into the content-pane. Appearance depends on the JFrame's layout.</span></pre>


<h5 class="font-code">JFrame's setDefaultCloseOperation()</h5>
<p>Instead of writing a <code>WindowEvent</code> listener with a <code>windowClosing()</code> handler to process the &quot;close-window&quot; button, <code>JFrame</code> provides a method called <code>setDefaultCloseOperation()</code> to sets the default operation when   the user initiates a &quot;close&quot; on this frame. Typically, we choose the option <code>JFrame.EXIT_ON_CLOSE</code>, which terminates the application via a <code>System.exit()</code>.</p>
<pre class="color-example">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
</pre>

<h5>Running the GUI Construction Codes on the Event-Dispatching Thread</h5>

<p>In the previous examples, we invoke the constructor directly in the entry <code>main()</code> method to setup the GUI components. For example,</p>

<pre class="color-example">
<span class="color-comment">// The entry main method</span>
public static void main(String[] args) {
   <span class="color-comment">// Invoke the constructor (by allocating an instance) to setup the GUI</span>
   new SwingCounter();
}</pre>

<p>The constructor will be executed in the so-called &quot;Main-Program&quot; thread. This may cause multi-threading issues (such as unresponsive user-interface and deadlock).</p>
<p>It is recommended to execute the GUI setup codes in the so-called &quot;Event-Dispatching&quot; thread, instead of &quot;Main-Program&quot; thread, for thread-safe operations. Event-dispatching thread, which processes events, should be used when the codes updates the GUI.</p>
<p> To run the constructor on the event-dispatching thread, invoke <code>static</code> method <code>SwingUtilities.invokeLater()</code> to asynchronously queue the constructor on the event-dispatching thread. The codes will be run after all pending  events have been processed. For example,</p>


<pre class="color-example">public static void main(String[] args) {
   <span class="color-comment">// Run the GUI codes in the Event-dispatching thread for thread-safety</span>
   <span class="color-new">SwingUtilities.invokeLater(new Runnable() {
      @Override
      public void run() {
         new SwingCounter();  <span class="color-comment">// Let the constructor do the job</span>
      }
   });</span>
}</pre>

<p>Note: <code>javax.swing.SwingUtilities.invokeLater()</code> is a cover for <code>java.awt.EventQueue.invokeLater()</code> (which is used in the NetBeans' Visual GUI Builder).</p>

<p>At times, for example in game programming, the <em>constructor</em> or the <code>main()</code> may contains non-GUI codes. Hence, it is a common practice to create a dedicated method called <code>initComponents()</code> (used in NetBeans visual GUI builder) or <code>createAndShowGUI()</code> (used in Swing tutorial) to handle all the GUI codes (and another method called <code>initGame()</code> to handle initialization of the game's objects). This GUI init method shall be run in the event-dispatching thread.</p>

<h5>Warning Message &quot;The serialization class does not declare a static final serialVersionUID field of type long&quot;</h5>

<p>This warning message is triggered because <code>java.awt.Frame</code> (via its superclass <code>java.awt.Component</code>) implements the <code>java.io.Serializable</code> interface. This interface enables the object to be written out to an output stream <em>serially</em> (via method <code>writeObject()</code>); and read back into the program (via method <code>readObject()</code>). The serialization runtime uses a number (called <code>serialVersionUID</code>) to ensure that the object read into the program is compatible with the class definition, and not belonging to another version.</p>

<p>You have these options:</p>
<ol>
<li>Simply ignore this warning message.  If a <code>serializable</code> class does not explicitly declare a <code>serialVersionUID</code>, then the serialization runtime will calculate a default <code>serialVersionUID</code> value for that class based on various aspects of the class.</li>

<li>Add a <code>serialVersionUID</code> (Recommended), e.g.
  <pre class="color-example">
private static final long <strong>serialVersionUID</strong> = 1L;  <span class="color-comment">// version 1</span></pre></li>

<li>Suppress this particular warning via annotation <code>@SuppressWarnings</code> (in package <code>java.lang</code>) (JDK 1.5):
<pre class="color-example">
<strong>@SuppressWarnings(&quot;serial&quot;)</strong>
public class MyFrame extends JFrame { ...... }</pre>
</li>

</ol>



<h4>Swing Example 2: <span class="font-code">SwingAccumulator</span></h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using layouts</span>
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits the top-level container javax.swing.JFrame</span>
public class <strong>SwingAccumulator</strong> extends <strong>JFrame</strong> {
   private <strong>JTextField</strong> tfInput, tfOutput;
   private int sum = 0;    <span class="color-comment">// accumulated sum, init to 0</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingAccumulator() {
      <span class="color-comment">// Retrieve the content-pane of the top-level container JFrame</span>
      <span class="color-comment">// All operations done on the content-pane</span>
      <strong>Container cp = getContentPane();</strong>
      <strong>cp.</strong>setLayout(new GridLayout(2, 2, 5, 5));  <span class="color-comment">// The content-pane sets its layout</span>
 
      cp.add(new <strong>JLabel</strong>(&quot;Enter an Integer: &quot;));
      tfInput = new <strong>JTextField</strong>(10);
      <strong>cp.</strong>add(tfInput);
      <strong>cp.</strong>add(new <strong>JLabel</strong>(&quot;The Accumulated Sum is: &quot;));
      tfOutput = new JTextField(10);
      tfOutput.setEditable(false);  <span class="color-comment">// read-only</span>
      <strong>cp.</strong>add(tfOutput);
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class that</span>
      <span class="color-comment">//  implements ActionListener as ActionEvent listener</span>
      tfInput.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            <span class="color-comment">// Get the String entered into the input TextField, convert to int</span>
            int numberIn = Integer.parseInt(tfInput.getText());
            sum += numberIn;      <span class="color-comment">// accumulate numbers entered into sum</span>
            tfInput.setText(&quot;&quot;);  <span class="color-comment">// clear input TextField</span>
            tfOutput.setText(sum + &quot;&quot;); <span class="color-comment">// display sum on the output TextField</span>
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="color-comment">// Exit program if close-window button clicked</span>
      setTitle(&quot;Swing Accumulator&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(350, 120);  <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);   <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingAccumulator(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h3>Using Visual GUI Builder - NetBeans/Eclipse</h3>

<p>If you have a complicated layout for your GUI application, you should use a GUI Builder, such as NetBeans or Eclipse to layout your GUI components in a drag-and-drop manner, similar to the popular visual languages such as Visual Basic.</p>

<h4>NetBeans</h4>

<p>For using NetBeans GUI Builder, read my &quot;<a href="../howto/NetBeans_HowTo.html#netbeans-swing">Writing Java GUI (AWT/Swing) Application in NetBeans</a>&quot;; or Swing Tutorial's &quot;<a href="http://docs.oracle.com/javase/tutorial/uiswing/learn/index.html">Learning Swing with the NetBeans IDE</a>&quot;.</p>

<h4>Eclipse</h4>

<p>For using Eclipse GUI Builder, read &quot;<a href="../howto/EclipseJava_HowTo.html#GUIBuider">Writing Swing Applications using Eclipse GUI Builder</a>&quot;.</p>

<a class="references" href="../howto/References.html#java">LINK TO JAVA REFERENCES &amp; RESOURCES</a>

<p class="references">MORE REFERENCES &amp; RESOURCES</p>
<ol>
<li>&quot;Creating a GUI With JFC/Swing&quot; (aka &quot;The Swing Tutorial&quot;) @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>.</li>
<li>JFC Demo (under JDK demo &quot;<code>jfc</code>&quot; directory).</li>
<li>Java2D Tutorial @ <a href="http://docs.oracle.com/javase/tutorial/2d/index.html">http://docs.oracle.com/javase/tutorial/2d/index.html</a>.</li>
<li>JOGL (Java Binding on OpenGL)</li>
<li>Java3D</li>
</ol>


</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 15.0.2<br />
Last modified: April 2021</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<a href="https://www3.ntu.edu.sg/f61217a453d065015090cd27fd6fb2c2"> </a></body>
</html>
