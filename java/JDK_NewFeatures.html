<!DOCTYPE html>
<!--
<div id="wrap-outer">
  <header id="header">
  <div id="wrap-inner">
     <aside id="wrap-toc">
        <section id="toc">
     <header id="content-header">
     <main id="content-main">
     <footer id="content-footer">
  <footer id="footer">
-->
<html lang="en">
<head>
<meta charset="utf-8">
<!-- for responsive web design -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- for SEO -->
<meta name="description" content="JDK New Features">
<meta name="keywords" content="JDK new features">
<title>JDK New Language Syntaxes</title>
<!-- ========== @@@@@@ v3 header changes starts here after <title> ========== -->

<!-- My custom CSS -->
<link rel="stylesheet" href="../css/programming_notes_v3.css">
<!-- Prism Syntax Highlighter -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.css" rel="stylesheet">
<!-- favicon -->
<link rel="icon" href="../favicon.ico" type="image/x-icon">
</head>


<body>

<div id="wrap-outer"> <!-- outer container -->

<!-- header filled by JavaScript -->
<header id="header" class="header"><p>&nbsp;</p></header>

<div id="wrap-inner"> <!-- inner container -->

<aside id="wrap-toc">
<h5>Table of Contents <a id="show-toc" href="JDK_NewFeatures.html#show-toc">(Hide)</a></h5>
<section id="toc"></section>  <!-- for showing the "Table of Content" -->
</aside>

	
<!-- ====== @@@ v3 header changes ends b4 "content-header", h1, h2 ======= -->
<header id="content-header">
<h1>JDK New Language Syntaxes (JDK 7 to JDK 21)</h1>
</header>

<main id="content-main">

<h5>References:</h5>
<ol>
<li>&quot;Java Language Updates Release 21&quot; @ <a href="https://docs.oracle.com/en/java/javase/21/language/index.html">https://docs.oracle.com/en/java/javase/<span class="new">21</span>/language/index.html</a> - describes the updated language features from <span class="new">JDK 9 to JDK 21</span>.</li>
</ol>

<h5>Preview Features</h5>
<p>Many of the new features started as <em>preview</em> features, and are standardized in later releases. To compile and run a program with preview features for JDK 21, you need to include the <code>--enable-preview -source 21 </code> flags.  For example,</p>
<pre class="command"><span class="comment">// To compile with preview feature for JDK 21</span>
javac --enable-preview -source 21 HelloPreview.java
<span class="comment">// To run</span>
javac --enable-preview HelloPreview</pre>

<h3>Summary of Language Change from JDK 9</h3>
<ul>
<li>JDK 9 (<a href="https://www.oracle.com/java/technologies/javase/9-relnotes.html">Release Notes</a>):
<ul>
<li><a href="http://openjdk.java.net/projects/jigsaw/spec/" target="_blank">JSR 376</a>: Java Platform Module System

<ul>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank">JEP 261</a>: Module                                          System</li>
<li><a href="http://openjdk.java.net/jeps/200" target="_blank">JEP 200</a>: The                                          Modular JDK</li>
<li><a href="http://openjdk.java.net/jeps/220" target="_blank">JEP 220</a>: Modular                                          Run-Time Images</li>
<li><a href="http://openjdk.java.net/jeps/260" target="_blank">JEP 260</a>:                                          Encapsulate Most Internal APIs</li>
</ul></li>

<li><a href="https://jcp.org/en/jsr/detail?id=334">JSR 334</a>: Small Enhancements to the Java Programming Language<br>
<a href="https://openjdk.java.net/jeps/213" target="_blank">JEP 213</a>: Milling Project Coin
<ul>
<li>try-with-resources for <code>final</code> and effectively <code>final</code> variables</li>
<li><code>@SafeVarargs</code> allowed on <code>private</code> instance methods</li>
<li>Diamond operator &lt;&gt; in anonymous inner classes</li>
<li>Underscore (_) character not a legal name</li>
<li>Support for <code>private</code> <code>interface</code> methods</li>
</ul>
</li>
</ul>
</li>

<li>JDK 10 (<a href="https://www.oracle.com/java/technologies/javase/10-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/286" target="_blank">JEP 286</a>: Local-Variable Type Inference with <code>var</code></li>
</ul>
</li>

<li>JDK 11 (<a href="https://www.oracle.com/java/technologies/javase/11-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/323" target="_blank">JEP 323</a>: Local-Variable Syntax for Lambda Parameters with <code>var</code></li>
</ul>

</li>

<li>JDK 12 (<a href="https://www.oracle.com/java/technologies/javase/12-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/325" target="_blank">JEP 325</a>: Switch Expressions (Preview)</li>
</ul>
</li>

<li>JDK 13 (<a href="https://www.oracle.com/java/technologies/javase/13-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/354" target="_blank">JEP 354</a>: Switch Expressions (Second Preview)</li>
<li><a href="https://openjdk.java.net/jeps/355" target="_blank">JEP 355</a>: Text Blocks (Preview)</li>
</ul>
</li>

<li>JDK 14 (<a href="https://www.oracle.com/java/technologies/javase/14-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/361" target="_blank">JEP 361</a>: Switch Expressions (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/368" target="_blank">JEP 368</a>: Text Blocks (Second Preview)</li>
<li><a href="https://openjdk.java.net/jeps/359" target="_blank">JEP 359</a>: Records (Preview)</li>
<li><a href="https://openjdk.java.net/jeps/305" target="_blank">JEP 305</a>: Pattern Matching for instanceof (Preview)</li>
</ul>
</li>

<li>JDK 15 (<a href="https://www.oracle.com/java/technologies/javase/15-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/378" target="_blank">JEP 378</a>: Text Blocks (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/384" target="_blank">JEP 384</a>: Records (Second Preview)</li>
<li><a href="https://openjdk.java.net/jeps/375" target="_blank">JEP 375</a>: Pattern Matching for instanceof (Second Preview)</li>
<li><a href="https://openjdk.java.net/jeps/360" target="_blank">JEP 360</a>: Sealed Classes (Preview)</li>
</ul>
</li>

<li>JDK 16 (<a href="https://www.oracle.com/java/technologies/javase/16-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/395" target="_blank">JEP 395</a>: Records (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/394" target="_blank">JEP 394</a>: Pattern Matching for instanceof (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/397" target="_blank">JEP 397</a>: Sealed Classes (Second Preview)</li>
</ul>
</li>

<li>JDK 17 (<a href="https://www.oracle.com/java/technologies/javase/17-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/409" target="_blank">JEP 409</a>: Sealed Classes (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/406" target="_blank">JEP 406</a>: Pattern Matching for switch (Preview)</li>
</ul>
</li>

<li>JDK 18 (<a href="https://www.oracle.com/java/technologies/javase/18-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/420" target="_blank">JEP 420</a>: Pattern Matching for switch (Second Preview)</li>
</ul>
</li>

<li>JDK 19  (<a href="https://www.oracle.com/java/technologies/javase/19-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/427" target="_blank">JEP 427</a>: Pattern Matching for switch (Third Preview)</li>
<li><a href="https://openjdk.java.net/jeps/405" target="_blank">JEP 405</a>: Record Patterns (Preview)</li>
</ul>
</li>

<li>JDK 20 (<a href="https://www.oracle.com/java/technologies/javase/20-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/433" target="_blank">JEP 433</a>: Pattern Matching for switch (Fourth Preview)</li>
<li><a href="https://openjdk.java.net/jeps/432" target="_blank">JEP 432</a>: Record Patterns (Second Preview)</li>
</ul>
</li>

<li>JDK 21 (<a href="https://www.oracle.com/java/technologies/javase/21-relnote-issues.html">Release Notes</a>):
<ul>
<li><a href="https://openjdk.java.net/jeps/440" target="_blank">JEP 440</a>: Record Patterns (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/440" target="_blank">JEP 441</a>: Pattern Matching for switch (Standard)</li>
<li><a href="https://openjdk.java.net/jeps/430" target="_blank">JEP 430</a>: String Templates (Preview)</li>
<li><a href="https://openjdk.java.net/jeps/443" target="_blank">JEP 443</a>: Unnamed Patterns and Variables (Preview)</li>
<li><a href="https://openjdk.java.net/jeps/445" target="_blank">JEP 445</a>: Unnamed Classes and Instance Main Methods (Preview)</li>
</ul>
</li>

<li>JDK 22:
<ul>
<li><a href="https://openjdk.java.net/jeps/459" target="_blank">JEP 459</a>: String Templates (Second Preview)</li>
<li>more</li>
</ul>
</li>
</ul>


<h3>(JDK 7,12-14) &quot;<code>switch</code>&quot; Enhancements</h3>

<ul>
<li>(JDK 7) Switch with String selector</li>
<li>(JDK 12) <a href="https://openjdk.java.net/jeps/325" target="_blank">JEP 325</a>: Switch Expressions (Preview)</li>
<li>(JDK 13) <a href="https://openjdk.java.net/jeps/354" target="_blank">JEP 354</a>: Switch Expressions (Second Preview)</li>
<li>(JDK 14) <a href="https://openjdk.java.net/jeps/361" target="_blank">JEP 361</a>: Switch Expressions (Standard)</li>
<li>(JDK 17) <a href="https://openjdk.java.net/jeps/406" target="_blank">JEP 406</a>: Pattern Matching for switch (Preview) [TODO]</li>
<li>(JDK 18) <a href="https://openjdk.java.net/jeps/420" target="_blank">JEP 420</a>: Pattern Matching for switch (Second Preview) [TODO]</li>
<li>(JDK 19) <a href="https://openjdk.java.net/jeps/427" target="_blank">JEP 427</a>: Pattern Matching for switch (Third Preview) [TODO]</li>
<li>(JDK 20) <a href="https://openjdk.java.net/jeps/433" target="_blank">JEP 433</a>: Pattern Matching for switch (Fourth Preview) [TODO]</li>
<li>(JDK 21) <a href="https://openjdk.java.net/jeps/440" target="_blank">JEP 441</a>: Pattern Matching for switch (Standard) [TODO]</li>
</ul>

<h5>(JDK 7) <code>switch</code> with <code>String</code> selector</h5>
<p>Prior to JDK 7, a <code>switch</code> works on integral primitive (<code>byte</code>, <code>short</code>, <code>int</code>, <code>char</code>; but NOT <code>long</code>). It also works with enumerated types (<code>Enum</code>) and primitive wrapper classes (<code>Character</code>, <code>Byte</code>, <code>Short</code>, and <code>Integer</code>).</p>
<p>From JDK 7, you can use a <code>String</code> object as the selector. For example,</p>

<pre data-line="3,4"><code class="language-java line-numbers">public class J7SwitchOnStringTest {
   public static void main(String[] args) {
      String day = "SAT";
      switch (day) {  // switch on String selector (JDK 7)
         case "MON": case "TUE": case "WED": case "THU":
            System.out.println("Working Day");
            break;
         case "FRI":
            System.out.println("Thank God It's Friday");
            break;
         case "SAT": case "SUN":
            System.out.println("Gone Fishing");
            break;
         default:
            System.out.println("Invalid");
            break;  // recommended good defensive code
      }
   }
}</code></pre>

<p>Notes:</p>
<ul>
<li><code>String</code>'s <code>.equals()</code> method, which is case-sensitive, is used in comparison.</li>
<li><code>switch</code> vs. nested-<code>if</code>: An if-then-else statement can test <em>expressions</em> based on ranges of values or conditions (e.g., <code>num!=-1</code>, <code>x+y&lt;5</code>), whereas a <code>switch</code> statement tests expressions based only on a <em>single</em> integer, enumerated <em>value</em>, or <code>String</code> object.</li>
<li>You probably should use an <code>Enum</code>, which is safer, in this example.</li>
</ul>


<p>&quot;<code>switch</code> on <code>String</code>&quot; is handy in handling options specified in command-line arguments, which are <code>String</code>s. For example,</p>

<pre><code class="language-java line-numbers">/**
 * This program accepts the following command-line options:
 *   -c|--create  : create
 *   -v|--verbose : verbose
 *   -d|--debug   : debug
 * More than one options can be specified in any order.
 */
public class J7SwitchArgsTest {
   public static void main(String[] args) {
      boolean create  = false;
      boolean verbose = false;
      boolean debug   = false;

      for (String arg : args) {
         switch (arg) {   // Switch on String selector (JDK 7)
            case "-c": case "--create":
               create = true;
               break;
            case "-v": case "--verbose":
               verbose = true;
               break;
            case "-d": case "--debug":
               debug = true;
               break;
            default:
               throw new IllegalArgumentException("invalid option " + arg);
         }
      }
      System.out.println("create: " + create);
      System.out.println("verbose: " + verbose);
      System.out.println("debug: " + debug);  
   }
}</code></pre>

<h5>(JDK 12, 13, 14) &quot;<code>switch</code>&quot; expressions</h5>

<p>&quot;<code>switch</code> expressions&quot; started in JDK 12 (<a href="https://openjdk.java.net/jeps/325" target="_blank">JEP 325</a>) as a preview feature and continued to JDK 13 (<a href="https://openjdk.java.net/jeps/354" target="_blank">JEP354</a>) for second review. It is standardized in JDK 14 (<a href="https://openjdk.java.net/jeps/361" target="_blank">JEP 361</a>).</p>

<p>The original <code>switch</code> statement (follows the C/C++) has several irregularities, such as:</p>
<ul>
<li>the default control flow behavior between switch labels (i.e., fall through without a <code>break</code> statement)</li>
<li><code>switch</code> works only as a statement, not as an expression (i.e., <code>switch</code> does not return a value)</li>
<li>the default scoping in <code>switch</code> block (the whole block is treated as one scope)</li>
</ul>

<h5>New Arrow Labels &quot;<code>case L -&gt;</code>&quot; and New &quot;<code>yield</code>&quot; Statement</h5>

<ul>
<li>The original <code>switch</code>'s label has the form of &quot;<code>case L:</code>&quot; which fall through without <code>break</code>. JDK 14 introduced <em>arrow labels</em>, in the form of &quot;<code>case L -&gt;</code>&quot;, which does not fall thru to the next case and <code>hence break</code> is not needed.</li>
<li><code>switch</code> in arrow-label form can take an expression that <em>evaluates to a value</em>.</li>
<li>JDK 14 also introduced a new <code>yield</code> statement to produce a value.</li>

</ul>

<p>For example:</p>

<pre><code class="language-java line-numbers">enum Day {
   SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;
}

public class J14SwitchExprYieldTest {
   public static void main(String[] args) {
      Day day = Day.SUNDAY; // switch on String selector (From JDK 7)
      int numLetters;

      // Before JDK 14, switch is a statement without evaluated value
      switch (day) {
         case MONDAY: case FRIDAY: case SUNDAY: numLetters = 6; break;
         case TUESDAY:                          numLetters = 7; break;
         case THURSDAY: case SATURDAY:          numLetters = 8; break;
         case WEDNESDAY:                        numLetters = 9; break;
         default:  // defensive code for enum
            numLetters = 0;
            throw new IllegalArgumentException("invalid day " + day);
      }
      System.out.println("1. Number of letters: " + numLetters);

      // JDK 14 supports switch expression that evaluates to a value
      numLetters =   // Assign the new switch expression to a variable
         switch (day) {
            case MONDAY, FRIDAY, SUNDAY -&gt; 6; // single-line expression
            case TUESDAY                -&gt; 7;
            case THURSDAY, SATURDAY     -&gt; 8;
            case WEDNESDAY              -&gt; 9;
            default -&gt; { // braces {} needed for block in 'case -&gt; L', local scope
               System.out.println("invalid day " + day);
               yield 0; // use "yield" to return a value in a block
            }
         };
      System.out.println("2. Number of letters: " + numLetters);

      // switch expression can also use the traditional "case L:" with yield
      numLetters = switch (day) {
         case MONDAY: case FRIDAY: case SUNDAY: yield 6;
         case TUESDAY:                          yield 7;
         case THURSDAY: case SATURDAY:          yield 8;
         case WEDNESDAY:                        yield 9;
         default: // braces { } NOT needed in 'case: L'
            System.out.println("invalid day " + day);
            yield 0; // use "yield" to return a value in a block
      };
      System.out.println("3. Number of letters: " + numLetters);
   }
}</code></pre>

<p>Notes:</p>
<ul>
<li>Multiple labels are separated by commas in arrow labels &quot;<code>case L -&gt;</code>&quot;.</li>
<li>Body blocks must be enclosed in braces, with its scope.</li>
</ul>

<h5>(JDK 17,18,19,20,21) Pattern Matching for <code>switch</code></h5>
<p>[TODO]</p>

<h3>(JDK 7) Binary Integer Literals with Prefix &quot;0b&quot; and Underscore (<code>_</code>) in Numeric Literals</h3>
<p>From JDK 7, you can express literal values in binary with prefix '0b' (zero-b) (or '0B') for integral types, similar to C/C++. Prior to JDK 7, you can only use octal literal values with prefix '0' (zero) or hexadecimal literal values with prefix '0x' (zero-x) or '0X'.</p>
<p>From JDK 7, you are also permitted to use underscore (<code>_</code>) to break the digits to improve the readability but you must start and end with a digit. Underscores are allowed in fractional part for floating point numbers too. For examples,</p>

<pre class="example">int anInt1 = 0b01010000101000101101000010100010;    <span class="comment">// binary literal prefix with '0b' or '0B'</span>
int anInt2 = 0b0101_0000_1010_0010_1101_0000_1010_0010;  <span class="comment">// break digits with underscore for readability</span>
int anInt3 = 2_123_456;  <span class="comment">// break the digits with underscore</span>
 
byte aByte = (byte)0b0110_1101;  <span class="comment">// '0b' for int(32-bit), need to cast to byte(8-bit)/short(16-bit)</span>
short aShort = (short)0b0111_0101_0000_0101;
long aLong = 0b1000_0101_0001_0110_1000_0101_0000_1010_0010_1101_0100_0101_1010_0001_0100_0101L;
      <span class="comment">// long(64-bit) with suffix 'L'</span>
 
double aDouble = 3.1415_9265;  <span class="comment">// You can also use underscore on fractional part for readability</span>
float aFloat = 3.14_15_92_65f;</pre>

<h3>(JDK 7) Catching Multiple <code>Exception</code> Types and Re-throwing <code>Exception</code>s with Improved Type Checking</h3>

<p>Prior to JDK 7, you need two <code>catch</code> blocks to catch two exception types even though both perform identical task. For example,</p>

<pre class="example">try {
   ......
} <span class="new">catch(ClassNotFoundException ex)</span> {
   ex.printStackTrace();
} <span class="new">catch(SQLException ex)</span> {
   ex.printStackTrace();  <span class="comment">// same actions</span>
}</pre>

<p>From JDK 7, you could use one single <code>catch</code> block to handle more than one exception types, with the exception types separated by a vertical bar (<code>|</code>). For example,</p>

<pre class="example">try {
   ......
} <span class="new">catch(ClassNotFoundException|SQLException ex)</span> {
   ex.printStackTrace();
}</pre>

<h3 id="try_resource">(JDK 7,9) Automatic Resource Management in <code>try</code>-with-resources Statement</h3>

<h5>(Pre-JDK 7) <code>try-catch-finally</code></h5>
<p>Prior to JDK 7, we have the <code>try-catch-finally</code> clause to handle exceptions. For example,</p>

<pre><code class="language-java line-numbers">import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;

// Copy from one file to another file line by line.
// Pre-JDK 7 requires you to close the resources using a finally block.
public class PreJ7FileCopy {
   public static void main(String[] args) {
      BufferedReader src = null;
      BufferedWriter dest = null;
      try {
         src = new BufferedReader(new FileReader("in.txt"));
         dest = new BufferedWriter(new FileWriter("out.txt"));
         String line;
         while ((line = src.readLine()) != null) {
            System.out.println(line);
            dest.write(line);
            dest.newLine(); // write a newline
         }
      } catch (IOException ex) {
         ex.printStackTrace();
      } finally { // always close the streams
         try {
            if (src != null)
               src.close(); // close() throw IOException
            if (dest != null)
               dest.close();
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
   }
}</code></pre>

<h5>(JDK 7) New <code>try</code>-with-resources Statement in the form of &quot;<code>try(<em>resources</em>)</code>&quot;</h5>

<p>JDK 7 introduces a <code>try</code>-with-resources statement, which ensures that each of the resources in <code>try(<em>resources</em>)</code> is properly closed at the end of the statement. This results in much cleaner codes.</p>

<pre><code class="language-java line-numbers">import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;

// Copy from one file to another file line by line.
// JDK 7 has a try-with-resources statement, which ensures that
//   each resource opened in try(resources) is closed at the end of the statement.
public class J7FileCopy {
   public static void main(String[] args) {
      try (BufferedReader src = new BufferedReader(new FileReader("in.txt"));
            BufferedWriter dest = new BufferedWriter(new FileWriter("out.txt"))) {  // JDK 7
         String line;
         while ((line = src.readLine()) != null) {
            System.out.println(line);
            dest.write(line);
            dest.newLine();
         }
      } catch (IOException ex) {
         ex.printStackTrace();
      }
      // src and dest automatically close.
      // No need for finally to explicitly close the resources.
   }
}</code></pre>

<h5>(JDK 9) <code>try</code>-with-resource on <code>final</code> or &quot;effectively <code>final</code>&quot; variables</h5>

<p>From JDK 9, if you already have a resource as a <code>final</code> or &quot;effectively <code>final</code>&quot; variable, you can use that variable in a <code>try(resources)</code> clause without declaring a new variable. An "effectively <code>final</code>" variable is one whose value is never changed after it is initialized. For example,</p>

<pre><code class="language-java line-numbers">import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;

// Copy from one file to another file line by line.
// Java 7 has a try-with-resources statement, which ensures that
//   each resource opened in try(resources) is closed at the end of the statement.
public class J9FileCopy {
   public static void main(String[] args) throws IOException {
      BufferedReader src = new BufferedReader(new FileReader("in.txt"));
      BufferedWriter dest = new BufferedWriter(new FileWriter("out.txt"));

// before JDK 9
//    try (BufferedReader src1 = src; BufferedWriter dest1 = dest) {  // local variables only
      try (src; dest) {  // final or effectively final variables permitted from JDK 9
         String line;
         while ((line = src.readLine()) != null) {
            System.out.println(line);
            dest.write(line);
            dest.newLine();
         }
      } catch (IOException ex) {
         ex.printStackTrace();
      }
      // src and dest automatically close.
      // No need for finally to explicitly close the resources.
   }
}</code></pre>


<h3>(JDK 7,9) Improved Type Inference for Generic Instance Creation with the Diamond Operator <code>&lt;&gt;</code></h3>

<h5>(JDK 7) New Diamond Operator <code>&lt;&gt;</code></h5>
<p>For example,</p>

<pre><code class="language-java line-numbers">import java.util.*;

public class J7GenericTest {
   public static void main(String[] args) {
      // Pre-JDK 7
      List&lt;String&gt; lst1 = new ArrayList&lt;String&gt;();
      // JDK 7 supports limited type inference for generic instance creation with
      // diamond operator &lt;&gt;
      List&lt;String&gt; lst2 = new ArrayList&lt;&gt;();

      lst1.add("Mon");
      lst1.add("Tue");
      lst2.add("Wed");
      lst2.add("Thu");

      for (String item : lst1)
         System.out.println(item);
      // Mon
      // Tue
      for (String item : lst2)
         System.out.println(item);
      // Wed
      // Thu

      List&lt;String&gt; lst3 = List.of("Fri", "Sat"); // JDK 9
      System.out.println(lst3);
      // [Fri, Sat]
      System.out.println(Arrays.toString(lst3.toArray()));
      // [Fri, Sat]
      lst3.forEach(System.out::println); // JDK 8
      // Fri
      // Sat
   }
}</code></pre>

<h5>(JDK 9) Diamond operator is allowed in anonymous inner classes</h5>

<p>From JDK 9, as long as the inferred type is denotable, you can use the diamond operator &lt;&gt; when you create an anonymous inner class.</p>

<p>For example, [TODO]</p>

<h3>(JDK 7,9) Simplified <code>varargs</code> Method Declaration with <code>@SafeVarargs</code> Annotation</h3>

<h5>(JDK 7) New <code>@SafeVarargs</code></h5>

<p>From JDK 7, you have the option of using <code>@SafeVarargs</code> annotation to suppress the warning you get when compiling a method with a non-reifiable varargs parameter. This annotation should be used when the method ensures that only elements of the same type as the varargs parameter are stored in the varargs array.</p>
<p>Example [TODO]</p>

<h5>(JDK 9) <code>@SafeVargs</code> annotation is allowed on <code>private</code> instance methods</h5>

<p>In JDK 7, the <code>@SafeVarargs</code> annotation can be applied only to methods that cannot be overridden. These include <code>static</code> methods, <code>final</code> instance methods. From JDK 9, <code>@SafeVargs</code> annotation is allowed on <code>private</code> instance methods.
</p>




<h3>(JDK 8,9) New methods in <code>interface</code></h3>
<p>Prior to  JDK 8, only <code>public</code> <code>abstract</code> methods and <code>public</code> <code>static</code> <code>final</code> variables are allowed inside an <code>interface</code>.</p>

<h5>(JDK 8) <code>public</code> <code>default</code> method and <code>public</code> <code>static</code> method</h5>
<p>JDK 8 enhances <code>interface</code> by introducing these new methods:</p>
<ul>
<li><code>public</code> <code>default</code> method (JDK 8)</li>
<li><code>public</code> <code>static</code> method (JDK 8)</li></ul>

<p>For examples,</p>

<pre data-line="7,13"><code class="language-java line-numbers">public interface MyJ8Interface {
   // prior to JDK 8
   String NAME = "peter";  // public static final
   void sayHello();        // public abstract

   // JDK 8 public default method - may be overridden
   default void sayHi() {  // public
      System.out.print("(public default method) ");
      System.out.println("hello, " + NAME);
   }

   // JDK 8 public static method - must invoke via interface name 
   static void sayGoodDay() {  // public
      System.out.print("(public static method) ");
      System.out.println("good day, " + NAME);
   }
}</code></pre>

<pre><code class="language-java line-numbers">public class MyJ8InterfaceImpl1 implements MyJ8Interface {
   public void sayHello() {
      System.out.print("(public abstract implementation) ");
      System.out.println("hello, world");
   }

   public static void main(String[] args) {
      MyJ8InterfaceImpl1 obj1 = new MyJ8InterfaceImpl1();
      obj1.sayHello();            // run public abstract implementation
      obj1.sayHi();               // run public default
      MyJ8Interface.sayGoodDay();   // run public static via interface name
   }
}</code></pre>
<pre class="output">(public abstract implementation) hello, world
(public default method) hello, peter
(public static method) good day, peter</pre>

<h5>(JDK 9) <code>private</code> method and <code>private</code> <code>static</code> method</h5>
<p>JDK 9 introduces these new methods:</p>
<ul>
<li><code>private</code> (instance) methods</li>
<li><code>private</code> <code>static</code> methods: can be called by other <code>public|private</code> <code>static</code> methods within the same <code>interface</code>.</li>
</ul>
<p>They are used as <em>helper</em> methods within the <code>interface</code> to remove redundant codes.</p>
<p>See &quot;<a href="JDK8_Lambda.html">Enhanced Interface, Lambda Expressions, Streams and Functional Programming</a>&quot; for more details.</p>

<h3>(JDK 8) Lambda Expression</h3>
<p>JDK 8 introduces <em>lambda expressions</em>, which provides a shorthand notation for creating an instance of an anonymous inner class implementing a functional interface (single-abstract-method interface). The new syntax is as follows:</p>
<pre class="syntax">
(arg1, arg2,...) -&gt; abstract-method-body;
   <span class="comment">// Return an instance implementing the functional interface</span></pre>

<p>For examples,</p>
<p>[TODO]</p>
<p>This is a major update to support functional programming - started in JDK8 and continue into next few releases.  See &quot;<a href="JDK8_Lambda.html">Enhanced Interface, Lambda Expressions, Streams and Functional Programming</a>&quot;.</p>

<h3>(JDK 9) Java Module System</h3>
<p>See &quot;<a href="JDK9_Module.html">Java Module System</a>&quot;.</p>

<h3>(JDK 9) <code>jshell</code></h3>
<p>JDK 9 introduces a new tool called <code>jshell</code> to support REPL (Read-Evaluate-Print-Loop). It is used to execute and test any Java constructs like class, interface, enum, object, statements etc.</p>
<p>This is NOT a language feature.</p>

<h3>(JDK 10,11) <code>var</code> - Type Inference</h3>

<ul>
<li>(JDK 10) <a href="https://openjdk.java.net/jeps/286" target="_blank">JEP 286</a>: Local-Variable Type Inference with var</li>
<li>(JDK 11) <a href="https://openjdk.java.net/jeps/323" target="_blank">JEP 323</a>: Local-Variable Syntax for Lambda Parameters with var</li>
</ul>

<h5>(JDK 10) Type Inference (<code>var</code>) for Local-Variables with Initializers (<a href="https://openjdk.java.net/jeps/286" target="_blank">JEP 286</a>)</h5>
<p>Prior to JDK 10, all local variable declarations required an explicit (manifest) type on the left-hand side. JDK 10 introduces a new keyword <code>var</code> to extend type inference for declarations of local variables with initializers (JEP 286), while maintaining Java's commitment to static type safety.</p>
<p>For examples,</p>

<pre><code class="language-java line-numbers">
public class J10VarTest {
   public static void main(String[] args) {
      // inferred type from initialized value
      var anInt = 88;
      var aDouble = 55.66;
      var msg = "hello";
      // print type
      System.out.println(msg.getClass().getName());              // for object
      System.out.println(((Object)anInt).getClass().getName());  // for primitive (wrapper)
      System.out.println(((Object)aDouble).getClass().getName());
   }
}</code></pre>

<pre class="output">java.lang.String
java.lang.Integer
java.lang.Double</pre>

<p>&quot;There is a certain amount of controversy over this feature. Some welcome the concision it enables; others fear that it deprives readers of important type information, impairing readability. And both groups are right. It can make code more readable by eliminating redundant information, and it can also make code less readable by eliding useful information. Another group worries that it will be overused, resulting in more bad Java code being written. This is also true, but it’s also likely to result in more good Java code being written. Like all features, it must be used with judgment. There’s no blanket rule for when it should and shouldn’t be used.&quot;</p>

<h5>(JDK 11) Type Inference (<code>var</code>) for Local-Variable for Lambda Parameters (<a href="https://openjdk.java.net/jeps/323" target="_blank">JEP 323</a>)</h5>
<p>In JDK 11, <code>var</code> is allowed when declaring the formal parameters of implicitly typed lambda expressions.</p>

<p>Read &quot;Local Variable Type Inference Style Guidelines&quot; @ <a href="https://openjdk.org/projects/amber/guides/lvti-style-guide">https://openjdk.org/projects/amber/guides/lvti-style-guide</a>.</p>


<h3>(JDK 11) Launch Single-File Source-Code Programs (<a href="https://openjdk.org/jeps/330">JEP 330</a>)</h3>
<p>Single-file programs, where the whole program is kept in a single source file, are common in learning Java.</p>
<p>From JDK 11, you can run a single-file program directly from the source-code with the java launcher, without explicitly compiling the source (via <code>javac</code>).</p>
<p>For example, you can launch the <code>Hello.java</code> directly as follows:</p>
<pre class="command">
java Hello.java
</pre>

<p>Notes:</p>
<ul>
<li>This is applicable to single-file source only.</li>
<li>No external <code>.class</code> file will be generated.</li>
<li>It compiles the source in the memory, and executes directly from the memory.</li>
<li>This feature is introduced for beginners to learn Java, and for professionals to test a Java feature.</li>
<li>The filename and classname need not be the same.</li>
</ul>
<p>This is NOT a language feature.</p>

<h3>(JDK 13,14,15) Text Blocks</h3>

<ul>
<li>(JDK 13) <a href="https://openjdk.java.net/jeps/355" target="_blank">JEP 355</a>: Text Blocks (Preview)</li>
<li>(JDK 14) <a href="https://openjdk.java.net/jeps/368" target="_blank">JEP 368</a>: Text Blocks (Second Preview)</li>
<li>(JDK 15) <a href="https://openjdk.java.net/jeps/378" target="_blank">JEP 378</a>: Text Blocks (Standard)</li>
</ul>

<p>Read &quot;Programmer's Guide To Text Blocks&quot; @ <a href="https://docs.oracle.com/en/java/javase/14/text-blocks/index.html">https://docs.oracle.com/en/java/javase/14/text-blocks/index.html</a>.</p>

<h5>(JDK 13) <a href="https://openjdk.java.net/jeps/355" target="_blank">JEP 355</a>:  Text Blocks (Preview)</h5>

<p>In earlier releases of the JDK, embedding multi-line code snippets   required a tangled mess of explicit new line, string   concatenations, and delimiters. JDK 13 proposes to support multi-line string literal (or text block) (JEP 355) that eliminates most of these   obstructions, and automatically formats the multi-line string in a predictable way.</p>
<p>A multi-line text block is delimited by a pair of triple double quotes, i.e., <code>&quot;&quot;&quot; ... &quot;&quot;&quot;</code>, which may span over multiple lines. The object produced from a text block is a <code>java.lang.String</code> with the same characteristics as a traditional double quoted string.</p>
<p>For example,</p>
<pre><code class="language-java line-numbers">public class J15TextBlock {
   public static void main(String[] args) {
      String htmlStr = """
            &lt;html&gt;
              &lt;head&gt;
                &lt;title&gt;Hello&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
                &lt;p&gt;"Hello, world!"&lt;/p&gt;
              &lt;/body&gt;
            &lt;/html&gt;
            """; // A multi-line text block delimited by """......"""
                 // Leading incidental whitespaces and trailing whitespaces are stripped

      System.out.println(htmlStr);  // automatically formatted (see output below)

		// variable htmlStr is the same as:
      htmlStr =
            &quot;&lt;html&gt;\n&quot; +
            &quot;  &lt;head&gt;\n&quot; +
            &quot;    &lt;title&gt;Hello&lt;/title&gt;\n&quot; +
            &quot;  &lt;/head&gt;\n&quot; +
            &quot;  &lt;body&gt;\n&quot; +
            &quot;    &lt;p&gt;\"Hello, world!\"&lt;/p&gt;\n&quot; +     // need escape sequence for &quot;
            &quot;  &lt;/body&gt;\n&quot; +
            &quot;&lt;/html&gt;\n&quot;;
   }
}</code></pre>

<pre class="output">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;"Hello, world!"&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p>Notes:</p>
<ul>
<li>Text block must begin with <code>&quot;&quot;&quot;</code> on the first line (by itself only). The content starts from the next line as in the above example.
<pre class="example">String s1 = """testing""";   <span class="error">// error: no single line text block</span>
String s2 = """testing 1
            testing 2
            """;   <span class="error">// error: the opening &quot;&quot;&quot; must be on its own line</span>

String s3 = """
      testing 1
      testing 2
      """;   <span class="comment">// OK</span>
String s4 = "testing 1\n" +
            "testing 2\n";    <span class="comment">// s3 is the same as s4</span>
System.out.println(s3.equals(s4));  <span class="output">//true</span>

String s5 = """
      testing 1
      testing 2""";   <span class="comment">// OK, no trailing newline</span>
String s6 = "testing 1\n" +
            "testing 2";    <span class="comment">// s5 is the same as s6</span>
System.out.println(s5.equals(s6));  <span class="output">//true</span>
System.out.println(s5.equals(s4));  <span class="output">//false</span></pre>
</li>
<li>Text block is automatically formatted by removing incidental leading whitespaces. The entire contents of the text block is shifted to the left until the   line with the least leading white space has no leading white space. A text block can <em>opt out</em> of incidental white space stripping by positioning the closing delimiter in the first character position of a source line, e.g.,
<pre class="example">
String s7 = """
         testing 1
         testing 2
      """;
<span class="output">//   testing 1
//   testing 2</span>

String s8 = """
         testing 1
         testing 2
""";  <span class="comment">// All whitespaces preserved</span>
<span class="output">//         testing 1
//         testing 2</span>

String s9 = """
      testing 1
      testing 2""";  <span class="comment">// no trailing newline</span>
<span class="output">//testing 1
//testing 2</span>
</pre>
</li>

<li>Trailing whitespaces are stripped.</li>
<li>There is no need to use escape sequence for double-quote inside a text block.</li>

<li>For most multi-line strings, place the opening delimiter at the right end of the previous line, and place the closing delimiter on its own line, at the left margin of the text block. The contents shall start at 1-2 indents, like the variable <code>html</code> in the first example.</li>
</ul>

<h5>(JDK 14) <a href="https://openjdk.java.net/jeps/368" target="_blank">JEP 368</a>: New Escape Sequences (Preview)</h5>
<p>JDK 14 adds two new escape sequences:</p>
<ul>
<li><code>\&lt;newline&gt;</code>: a backslash (\) at the end of the line suppresses the newline, i.e., continue the next line.</li>
<li><code>\s</code>: to indicate a single space, can be used to create trailing whitespaces.</li>
</ul>
<p>For example,</p>
<pre class="example">
String s10 = """
      testing 1 \
      testing 2 \
      """;
<span class="comment"><span class="output">//testing 1 testing 2</span></span>

String s11 = """
      testing 1     \s=
      testing 2     \s=
      """;   <span class="comment">// with trailing whitespaces</span>
<span class="output">//testing 1      =
//testing 2      =</span></pre>


<h3>(JDK 14,15,16) Pattern Matching for <code>instanceof</code></h3>
<ul>
<li><a href="https://openjdk.java.net/jeps/305" target="_blank">JEP 305</a>: Pattern Matching for <code>instanceof</code> (Preview)</li>
<li><a href="https://openjdk.java.net/jeps/375" target="_blank">JEP 375</a>: Pattern Matching for <code>instanceof</code> (Second Preview)</li>
<li><a href="https://openjdk.java.net/jeps/394" target="_blank">JEP 394</a>: Pattern Matching for <code>instanceof</code> (Standard)</li>
</ul>

<h5>(JDK 14) <a href="https://openjdk.java.net/jeps/305" target="_blank">JEP 305</a>: Pattern Matching for <code>instanceof</code> (Preview)</h5>
<p>JDK 14 has introduced pattern matching for <code>instanceof</code> with the aim of eliminating boilerplate code.</p>

<p>For example, before this feature, we wrote:</p>

<pre class="example">
if (obj instanceof String) {
    String str = (String) obj;
    int len = str.length();
    // ...
}</pre>
<p>This is a very common pattern in Java. Whenever we check if a variable is a certain type, we almost always follow it with a cast to that type.</p>

<p>Now, we can write:</p>
<pre class="example">if (obj instanceof String str) {
    int len = str.length();
    // ...
}</pre>

<p>In future releases, Java is going to come up with pattern matching for other constructs such as a switch.</p>
<p>JDK 15, 16 [MORE]</p>

<h3>(JDK 14,15,16) Record</h3>
<ul>
<li><a href="https://openjdk.java.net/jeps/359" target="_blank">JEP 359</a>: Records (Preview)</li>
<li><a href="https://openjdk.java.net/jeps/384" target="_blank">JEP 384</a>: Records (Second Preview)</li>
<li><a href="https://openjdk.java.net/jeps/395" target="_blank">JEP 395</a>: Records (Standard)</li>
</ul>

<p>JDK 14 introduces record (<a href="https://openjdk.java.net/jeps/359" target="_blank">JEP 359</a>) as a preview feature, with a second review in JDK 15 (<a href="https://openjdk.java.net/jeps/384" target="_blank">JEP 384</a>), and standardized in JDK 16 (<a href="https://openjdk.java.net/jeps/395" target="_blank">JEP 395</a>).</p>

<h5>(JDK 14) <a href="https://openjdk.java.net/jeps/359" target="_blank">JEP 359</a>: Records (Preview)</h5>
<p>A common complaint of Java is there is too much boilerplate codes. Records were introduced to reduce boilerplate code in immutable data model. For example, a data model for a <code>User</code> with an <code>id</code> and <code>name</code> can be simply defined as:</p>

<pre class="example">public record User(int id, String name) { }</pre>

<p>A new keyword "<code>record</code>" is introduced. This simple declaration will automatically add a canonical constructor with matching parameters, getters, <code>equals()</code>, <code>hashCode()</code> and <code>toString()</code> methods. Record is a restricted form of class, like <code>enum</code>. Records are immutable.</p>

<pre><code class="language-java line-numbers">
import java.util.Objects;
// Before "record"
public class User {
   private final int id;  // immutable
   private final String name;
   
   public User(int id, String name) {  // constructor
      this.id = id;
      this.name = name;
   }
   public int getId() {  // getters
      return this.id;
   }
   public String getName() {
      return this.name;
   }
   @Override public boolean equals(Object obj) {
      if (!(obj instanceof User)) return false;
      var other = (User)obj;
      return other.id == this.id &amp;&amp; other.name.equals(this.name);
   }
   @Override public int hashCode() {
      return Objects.hash(id, name);
   }
}</code></pre>

<p>The above class can be defined in one line with record:</p>
<pre><code class="language-java line-numbers">public record User(int id, String name) {}</code></pre>

<pre><code class="language-java line-numbers">public class J16RecordUserTest {
   public static void main(String[] args) {
      User user = new User(123, "Tan Ah Teck");  // canonical constructor
      System.out.println(user.id());  // getters
      System.out.println(user.name());
      System.out.println(user);  // toString()
   }
}</code></pre>

<p>You are allow to override the default implementation of the implicitly-defined methods, for example,</p>
<pre><code class="language-java line-numbers">public record Student(int id, String name) {
   public Student(int id, String name) {  // canonical constructor
      if (id &lt; 0)
         throw new IllegalArgumentException("id=" + id + " &lt; 0");
      this.id = id;
      this.name = name;
   }

   @Override
   public int id() {
      return 0;
   }

   @Override
   public String toString() {
      return "This is a Student";
   }

   public static void main(String[] args) {  // test driver
      var s1 = new Student(0, "Peter");
      System.out.println(s1);
      //This is a Student
      var s2 = new Student(-9, "Paul");
      //Exception in thread "main" java.lang.IllegalArgumentException: id=-9 &lt; 0
   }
}</code></pre>

<p>You can also add more methods to record, for example,</p>
<pre><code class="language-java line-numbers">public record Rectangle (double length, double width) {
   public double area() {
      return length * width;
   }

   public static void main(String[] args) {   // test driver
      var r1 = new Rectangle(2.2, 1.1);
      System.out.println(r1);
      //Rectangle[length=2.2, width=1.1]
      System.out.println(r1.area());
      //2.4200000000000004
   }
}
</code></pre>

<p>Take note that records do have some restrictions, e.g., the fields are always <code>final</code>, they cannot be declared <code>abstract</code>, and they cannot use native methods.</p>

<p>Note that the introduction of classes in the <code>java.lang</code> package is rare but necessary from time to time, such as <code>Enum</code> in JDK 5, <code>Module</code> in JDK 9, and <code>Record</code> in JDK 14 (preview).</p>

<h5>Constructor for the record class</h5>
<p>A record without any constructor is automatically given a canonical constructor that assigns all the <code>private</code> fields to the corresponding arguments of the new expression which instantiated the record. (In contrast, a class without any constructor is automatically given a default constructor that does nothing.)</p>

<h5>Compact Canonical Constructor</h5>
<p>You can override the constructor in the usual way. There is also a <em>compact</em> way, for example,</p>
<pre><code class="language-java line-numbers">public record Time(int hour, int minute, int second) {
   // Compact form to override the canonical constructor to do validation
   public Time {  // The parameters (int hour, int minute, int second) are declared implicitly
      if (hour &lt; 0 || hour &gt; 23 || minute &lt; 0 || minute &gt; 59 || second &lt; 0 || second &gt; 59)
         throw new IllegalArgumentException(String.format("%02d:%02d:%02d", hour, minute, second));
      // At the end of the constructor, implicitly run:
      // this.hour = hour; this.minute = minute; this.second = second;
   }

   public static void main(String[] args) {
      var t1 = new Time(23, 59, 59);
      System.out.println(t1);
      //Time[hour=23, minute=59, second=59]
      var t2 = new Time(23, 60, 59);
      //Exception in thread "main" java.lang.IllegalArgumentException: 23:60:59
      System.out.println(t2);
   }
}</code></pre>

<p>JDK 15, 16 [MORE]</p>

<h3>(JDK 21,22) String Templates</h3>
<ul>
<li><a href="https://openjdk.java.net/jeps/430" target="_blank">JEP 430</a>: String Templates (Preview)</li>
<li><a href="https://openjdk.java.net/jeps/459" target="_blank">JEP 459</a>: String Templates (Second Preview)</li>
</ul>

<h5>Embedded Expressions <code>\{expr}</code></h5>

<p>String templates complement Java's existing string literals and text blocks by coupling literal text with <em>embedded expressions</em> and template processors to produce specialized results. The embedded expression is in the form of <code>\{expr}</code>.</p>

<h5>The <code>STR</code> String Template Processor</h5>
<p>For example,</p>
<pre class="example">
//import static <span class="new">java.lang.StringTemplate.STR</span>;  <span class="comment">// not needed, imported automatically</span>

String <span class="new">name</span> = "Peter";
String greeting = <span class="new">STR.</span>"Hello <span class="new">\{name}</span>";
System.out.println(greeting);

String title = "My Hello";
String message = "hello, world";
String html = <span class="new">STR.</span>"""
      &lt;html&gt;-
        &lt;head&gt;
          &lt;title&gt;<span class="new">\{title}</span>&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;"<span class="new">\{message}</span>"&lt;/p&gt;
        &lt;/body&gt;
      &lt;/html&gt;
      """;
System.out.println(html);</pre>

<p>STR (String Template Processor) performs string interpolation by replacing each embedded expression in the template with the (stringified) value of that expression. The result of evaluating a template expression which uses STR is a <code>String</code>.</p>
<p>The embedded expressions are evaluated and the results are converted to <code>String</code>. For example,</p>
<pre class="example">int x = 8, y = 9;
String result = STR."<span class="new">\{2*x}</span> + <span class="new">\{3*y}</span> = <span class="new">\{2*x + 3*y}</span>";
System.out.println(result);
<span class="output">//16 + 27 = 43</span>

System.out.println(STR."<span class="new">\{x++}</span>, <span class="new">\{x++}</span>, <span class="new">\{x++}</span>");  <span class="comment">// evaluate from left to right</span>
<span class="output">//8, 9, 10</span>

System.out.println(STR."A random number: <span class="new">\{Math.random()}</span>");  <span class="comment">// can invoke method</span>

System.out.println(STR."<span class="new">\{x}</span> is <span class="new">\{(x % 2 == 0 ? &quot;even&quot; : &quot;odd&quot;)}</span>"); <span class="comment">// escape not needed for double-quote
</span><span class="output">//11 is odd</span></pre>

<h5>The <code>FMT</code> Format Template Processor</h5>
<p>FMT is another template processor. FMT is like STR in that it performs interpolation, but it also interprets format specifiers which appear to the left of embedded expressions. For example,</p>
<pre class="example">import static <span class="new">java.util.FormatProcessor.FMT</span>;

int hour = 23;
int minute = 1;
int second = 5;
String time = <span class="new">FMT.</span>&quot;The time is <span class="new">%02d\{hour}</span>:<span class="new">%02d\{minute}</span>:<span class="new">%02d\{second}</span>&quot;;
System.out.println(time);
<span class="output">//The time is 23:01:05</span></pre>

<p>String Template is a preview feature in JDK 21. You need to compile and run the program with &quot;<code>--enable-preview -source 21</code>&quot; flags.</p>

<p>JDK 22 [MORE]</p>

</main> 
<!-- end of class="content-main" -->

<footer id="content-footer">
<p>Latest version tested: JDK 21.0.1<br>
Last modified: January 2024</p>
</footer>

</div>  <!-- end of <div class="wrap-inner"> for inner container  -->


<!-- ======= @@@ v3 footer changes starts here, before "footer" ======== -->
<!-- footer filled by JavaScript -->
<footer id="footer" class="footer"><p>&nbsp;</p></footer>

</div>  <!-- end of <div class="wrap-outer"> for outer container -->

<!-- Place all JavaScript before end of body to load last -->
<!-- jQuery -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<!-- My custom JavaScript v3 -->
<script src="../scripts/programming_notes_v3.js"></script>
<!-- Prism Syntax Highlighter -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
