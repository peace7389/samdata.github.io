<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>JDK 8 New Features</title>

<!-- @@ start change in v1 -->
<link rel="stylesheet" href="../css/programming_notes_v1.css">
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
<script src="../scripts/programming_notes_v1.js"></script>
</head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="JDK8_Lambda.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Enhanced Interface, Lambda Expressions, Streams and Functional Programming (JDK 8, 9, 10, 11)</h1>
</div>

<div id="content-main">

<!-- @@ end change in v1 -->

<p>JDK 8 is a MAJOR upgrade, which introduces many new language features to support <em>Functional Programming</em>:</p>
<ol>
<li>Re-design the interface to support <code>public</code> <code>default</code> and <code>public</code> <code>static</code> methods. JDK 9 further supports <code>private</code> and <code>private</code> <code>static</code> methods.</li>
<li>Introduce <em>lambda expressions</em> as a shorthand for creating an instance of an anonymous inner class implementing a single-abstract-method interface.</li>
<li>Retrofit the Collection framework, by adding new <code>default</code> and <code>static</code> methods to the existing interfaces.</li>
<li>Introduce the Stream API to efficiently handle filter-map-reduce operations in functional programming.</li>
</ol>

<h3 id="NewInterfaceMethods">Interface <span class="font-code">public</span> <span class="font-code">default</span>, <span class="font-code">public</span> <span class="font-code">static</span> (JDK 8), <span class="font-code">private</span>, <span class="font-code">private</span> <span class="font-code">static</span> (JDK 9) Methods</h3>

<p>One of the main goal of interfaces is to let you &quot;program at the specification instead of the actual implementation&quot;. You define the specifications in the interfaces, write the implementation subclasses, construct instances of implementation subclasses and upcast them to the interfaces. Once upcasted, you can only use methods defined in the interfaces, not in the implementation subclasses. In other words, you program at the specifications. Via polymorphism, overridden methods in the implementation subclasses will be invoked.</p>
<p>Prior to JDK 8, a Java interface can contain only two entities:</p>
<ol>
<li><code>public</code> <code>abstract</code> methods: Methods with only signature and without the implementation body. All <code>interface</code>'s methods are <code>public</code> and <code>abstract</code> by default. (Take note that class's methods and fields are package by default.)</li>
<li><code>public</code> <code>static</code> <code>final</code> fields (or constants). All interface's fields are <code>public</code> <code>static</code> <code>final</code> by default.</li>
</ol>

<p>A subclass implements an <code>interface</code> MUST override ALL the <code>abstract</code> methods by providing the implementation body.</p>
<p>As a consequence, maintaining interfaces becomes difficult because if we were to add an additional <code>abstract</code> method to the interface, ALL the existing implementation subclasses must be retrofitted to implement the additional <code>abstract</code> method.</p>

<p> To resolve this constraint, starting from JDK 8, an <code>interface</code> can include <code>public</code> <code>static</code> methods and <code>public</code> <code>default</code> methods. JDK 9 further includes <code>private</code> method and <code>private</code> <code>static</code> methods into the interfaces.</p>

<ul>
<li>Both <code>public</code> <code>default</code> method and <code>public</code> <code>static</code> method are non-<code>abstract</code> (or concrete), with an implementation method body.</li>
<li>Adding a <code>public</code> <code>default</code> method or a <code>public</code> <code>static</code> method to an existing interface does not require retrofitting the existing implementation subclasses.</li>
<li><code>public</code> <code>default</code> methods are instance methods, where each instance has its own copy. Since <code>interface</code>'s methods are <code>public</code> and <code>abstract</code> by default prior to JDK 8, the keyword <code>default</code> is needed to mark the method non-<code>abstract</code>. (Whereas <code>class</code>'s methods are non-<code>abstract</code> by default.)</li>
<li>The interface's  <code>public</code> <code>default</code> method are inherited by its sub-types (subclasses or sub-interfaces). The implementation subclasses or sub-interfaces CAN override a  <code>public</code> <code>default</code> method inherited; but NOT necessarily.</li>
<li>The interface's <code>public</code> <code>static</code> method are NOT inherited by its sub-types. It can only be invoke via the super-type; and CANNOT invoke via its sub-types or sub-type's instances. (Unlike superclass' <code>static</code> methods, which are inherited by its subclasses, but CANNOT be overridden, but CAN be hidden by its subclasses. Read <a href="J3c_OOPWrappingUp.html#static_inheritance">HERE</a>.)</li>
<li>(JDK 9) The <code>private</code> (instance) method and <code>private</code> <code>static</code> method are meant for helper methods within the interface. They are NOT inherited by its sub-types. <code>private</code> <code>static</code> methods can be called by <code>public|private</code> <code>static</code> methods within the <code>interface</code>.</li>
</ul>

<p>In summary, JDK 8/9's interface may include:</p>
<ol>
<li>(Pre-JDK 8) <code>public</code> <code>static</code> (class) <code>final</code> fields or constants.</li>
<li>(Pre-JDK 8) <code>public</code> <code>abstract</code> (instance) methods WITHOUT implementation - MUST be overridden by the implementation subclasses.</li>
<li>(JDK 8) <code>public</code> <code>default</code> (instance) method with implementation - inherited by the implementation subclasses; MAY be overridden but NOT necessarily.</li>
<li>(JDK 8) <code>public</code> <code>static</code> (class) method with implementation - NOT inherited by its sub-types (unlike superclass' <code>static</code> methods).</li>
<li>(JDK 9) <code>private</code> (instance) method with implementation - NOT inherited by its sub-types; CANNOT be invoked by other <code>static</code> (class) methods within the interface.</li>
<li>(JDK 9) <code>private</code> <code>static</code> (class) method with implementation - NOT inherited by its sub-types; CAN be invoked by other <code>static</code> (class) methods within the interface.</li>
</ol>
<h4>Interface <span class="font-code">public</span> <span class="font-code">default</span> (instance) Methods (JDK 8)</h4>
<p>JDK 8's interface supports <code>public default</code> (instance) methods via a new keyword &quot;<code>default</code>&quot;. Default methods are non-<code>abstract</code>. You need to provide the implementation body. The implementation subclasses are NOT require to override the <code>default</code> methods, but could do so if they desire. The <code>default</code> (instance) methods are always <code>public</code>.</p>

<pre class="color-example">
public interface <strong>MyJ8InterfaceWithDefault</strong> {
   void foo();   <span class="color-comment">// abstract public (instance) (pre-JDK 8)</span>

   <span class="color-comment">// Default methods are marked by keyword &quot;default&quot;</span>
   <span class="color-new">default</span> void bar() {    <span class="color-comment">// public (instance) (JDK 8)</span>
      System.out.println(&quot;MyJ8InterfaceWithDefault runs default bar()&quot;);
   }
   
   <span class="color-comment">//<span class="color-error">default void bar1();</span>
   //<span class="color-error">compilation error: missing method body, or declare abstract</span></span>
}</pre>

<p>If you did not provide the method body to default method, you will receive compilation &quot;error: missing method body, or declare <code>abstract</code>&quot;, as shown in the above example.</p>

<pre class="color-example">
public class <strong>MyImplClass1</strong> implements <strong>MyJ8InterfaceWithDefault</strong> {
   <span class="color-comment">// Need to override ALL the abstract methods,
   //   but not necessarily for the default methods.</span>
   <span class="color-new">@Override</span>
   public void <span class="color-new">foo</span>() {
      System.out.println(&quot;MyImplClass1 runs foo()&quot;);
   }

   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args) {
      MyImplClass1 c = new MyImplClass1();
      c.foo();  <span class="color-comment">//</span><span class="color-output">MyImplClass1 runs foo()</span>
      c.bar();  <span class="color-comment">//<span class="color-output">MyJ8InterfaceWithDefault runs default bar()</span></span>
   }
}</pre>

<h5>Implementing Multiple Interfaces</h5>

<p>Java classes can implement multiple interfaces (but extend only one superclass). In the above example, if another interface (say <code>MyJ8InterfaceWithDefault1</code>) also provides a default method <code>bar()</code>, and a class (say <code>MyImplClass2</code>) implements both <code>MyJ8InterfaceWithDefault</code> and <code>MyJ8InterfaceWithDefault1</code>, a conflict arises in the implementation body. To resolve this problem, JDK 8 requires the implementation classes to override the <code>default</code> methods if more than one versions are inherited. For example,</p>

<pre class="color-example">
public interface <strong>MyJ8InterfaceWithDefault1</strong> {
   <span class="color-comment">// This default method has same signature but different implementation as MyJ8InterfaceWithDefault</span>
   <span class="color-new">default</span> void bar() {   <span class="color-comment">// public (instance) (JDK 8)</span>
      System.out.println(&quot;MyJ8InterfaceWithDefault1 runs default bar() too!&quot;);
   }
}</pre>

<pre class="color-example">
public class <strong>MyImplClass2</strong> implements <strong>MyJ8InterfaceWithDefault</strong>, <strong>MyJ8InterfaceWithDefault1</strong> {
   <span class="color-comment">// Need to override ALL abstract methods</span>
   @Override
   public void foo() {
      System.out.println(&quot;MyImplClass2 runs foo()&quot;);
   }

   <span class="color-new">@Override
   public void bar() {
      System.out.println(&quot;MyImplClass2 runs overridden bar()&quot;);
   }</span>
   <span class="color-comment">// bar() exists in both interfaces.
   // You MUST override, otherwise
   //<span class="color-error">compilation error: class MyImplClass2 inherits unrelated defaults for bar()</span>
   //        <span class="color-error">from types MyJ8InterfaceWithDefault and MyJ8InterfaceWithDefault1</span></span>

   public static void main(String[] args) {
      MyImplClass2 c = new MyImplClass2();
      c.foo();   <span class="color-comment">//<span class="color-output">MyImplClass2 runs foo()</span></span>
      c.bar();   <span class="color-comment">//<span class="color-output">MyImplClass2 runs overridden bar()</span></span>
   }
}</pre>

<p>If you fail to override the <code>default</code> method, you will get an &quot;error: class <code>MyImplClass2</code> inherits unrelated defaults for <code>bar()</code> from types <code>MyJ8InterfaceWithDefault </code>and <code>MyJ8InterfaceWithDefault1</code>&quot;.</p>

<h4>Interface <span class="font-code">public</span> <span class="font-code">static</span> (class) Methods (JDK 8)</h4>
<p>Recall that a <code>static</code> method belong to a class/interface, instead of instances. You can invoke <code>static</code> method directly <em>via <code>ClassName</code></em><code>.<em>staticMethodName</em>()</code> without creating any instances.</p>
<p>The <code>public static</code> (class) method is similar to the <code>default</code> method. However, it is NOT inherited by its sub-types (unlike superclass' <code>static</code> method). By default, interface's <code>static</code> methods are <code>public</code>. JDK 9 supports <code>private</code> <code>static</code> methods.</p>

<pre class="color-example">
public interface <strong>MyJ8InterfaceWithStatic</strong> {
   void foo();   <span class="color-comment">// abstract public (instance) (pre-JDK 8)</span>

   <span class="color-new">static</span> void bar() {  <span class="color-comment">// public (class) (JDK 8)</span>
      System.out.println(&quot;MyJ8InterfaceWithStatic runs static bar()&quot;);
   }

   <span class="color-comment">//static void bar1();
   //</span><span class="color-error">compilation error: missing method body, or declare abstract</span>
}</pre>

<p>Like <code>default</code> methods, <code>static</code> methods are non-<code>abstract</code> and you need to provide the implementation method body. Otherwise, it triggers compilation error &quot;missing method body, or declare abstract&quot;.</p>

<pre class="color-example">
public class <strong>MyImplClass3</strong> <strong>implements MyJ8InterfaceWithStatic</strong> {
   <span class="color-comment">// Need to override ALL abstract method</span>
   @Override
   public void foo() {
      System.out.println(&quot;MyImplClass3 run foo()&quot;);
   }

   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args) {
      MyImplClass3 c = new MyImplClass3();
      c.foo();  <span class="color-comment">//<span class="color-output">MyImplClass3 run foo()</span></span>
      <span class="color-comment">// Invoke static (class) method via ClassName.staticMethodName()</span>
      MyJ8InterfaceWithStatic.bar();  <span class="color-comment">//<span class="color-output">MyJ8InterfaceWithStatic runs static bar()</span></span>

      <span class="color-comment">// Interface's static methods are NOT inherited (Unlike Superclass)!!!</span>
      <span class="color-error">//MyImplClass3.bar();
            //compilation error: cannot find symbol bar()
      //c.bar();
            //compilation error: cannot find symbol bar()
      //MyJ8InterfaceWithStatic c1 = new MyImplClass3();
      //c1.bar();
            //compilation error: illegal static interface method call</span>
   }
}</pre>

<p>Take note that:</p>
<ul>
<li><code>static</code> (class) methods are invoked via <code><em>ClassName</em>.<em>staticMethodName</em>()</code>.</li>
<li>Interface's <code>static</code> methods are NOT inherited by its sub-types!!! Unlike superclass's <code>static</code> methods, which are inherited by its subclasses. This is probably because we can extend only one superclass, but can implement multiple interfaces to avoid conflicting inheritance.</li>
</ul>

<pre class="color-example">
public class <strong>MyImplClass4 implements MyJ8InterfaceWithStatic</strong> {
   @Override
   public void foo() {
      System.out.println("MyImplClass4 run foo()");
   }

   <span class="color-comment">//<span class="color-error">@Override</span>  //</span><span class="color-error">compilation error: static methods cannot be annotated with @Override</span>
   <span class="color-new">public static void bar() {
      System.out.println(&quot;MyImplClass4 run bar()&quot;);
   }</span>
      <span class="color-comment">// This class provides its own definition for the static methods of the same name</span>

   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args) {
      MyImplClass4 c = new MyImplClass4();
      c.foo();  <span class="color-comment">//<span class="color-output">MyImplClass4 run foo()</span></span>

      MyJ8InterfaceWithStatic.bar();  <span class="color-comment">//<span class="color-output">MyJ8InterfaceWithStatic runs static bar()</span></span>
     <span class="color-new"> MyImplClass4.bar();</span> <span class="color-comment">//<span class="color-output">MyImplClass4 run bar()</span></span>
      <span class="color-new">c.bar();</span>            <span class="color-comment">//<span class="color-output">MyImplClass4 run bar()</span></span>
   }
}</pre>

<p>Since the interface's <code>static</code> methods are NOT inherited by its sub-types, you CAN provide your own definition of the <em>same</em> <code>static</code> methods in the sub-types.</p>

<h5>Are Java superclass's <span class="font-code">static</span> methods inherited by its subclasses?</h5>
<p>YES. Read <a href="J3c_OOPWrappingUp.html#static_inheritance">HERE</a>.</p>

<h5>Are Java interface's <span class="font-code">static</span> methods inherited by its sub-types (subclasses or sub-interfaces)?</h5>
<p>NO. Probably because a sub-type can implement multiple interfaces, but can extend only one superclass.</p>

<h4>Interface <span class="font-code">private</span> (instance) and <span class="font-code">private</span> <span class="font-code">static</span> (class) methods (JDK 9)</h4>
<p>JDK 9 introduces <code>private</code> (instance) and <code>private static</code> (class) methods into interface. This is meant for you to write <em>helper</em> methods for re-use within this interface only. Take note that <code>private</code> methods are accessible within the class/interface only.</p>

<ul>
<li><code>private</code> (instance) methods can be called by <code>public default</code> (instance) methods (and all instance methods) within the interface. For example,
  <pre class="color-example">
public interface <strong>MyJ9InterfaceWithPrivate</strong> {
   <span class="color-comment">// private helper method for use by all instance methods inside this interface</span>
   <span class="color-new">private</span> void showMsg(String greeting, String name) {  <span class="color-comment">// private instance</span>
      System.out.println(greeting + &quot;, &quot; + name);
   }

   <span class="color-new">default</span> void sayHello(String name) {  <span class="color-comment">// public instance</span>
      showMsg(&quot;hello&quot;, name);  <span class="color-comment">// call private instance helper method</span>
   }

   <span class="color-new">default</span> void sayHi(String name) {  <span class="color-comment">// public instance</span>
      showMsg(&quot;hi&quot;, name);     <span class="color-comment">// call private instance helper method</span>
   }

   <span class="color-comment">// Other abstract, static methods</span>
}</pre>

<pre class="color-example">
public class <strong>MyJ9InterfaceWithPrivateImpl implements MyJ9InterfaceWithPrivate</strong> {
   <span class="color-comment">// to implement all abstract methods</span>
}</pre>

<pre class="color-example">
public class <strong>MyJ9InterfaceWithPrivateTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the instance method, thru a constructed instance</span>
      MyJ9InterfaceWithPrivate h = new MyJ9InterfaceWithPrivateImpl();
      h.sayHello(&quot;Peter&quot;);  <span class="color-comment">//<span class="color-output">hello, Peter</span></span>
      h.sayHi(&quot;Paul&quot;);      <span class="color-comment">//<span class="color-output">hi, Paul</span></span>
   }
}</pre>



</li>
<li><code>private static</code> (class) methods can be called by <code>public/private static</code> (class) methods, as well as <code>public default</code> (instance) and <code>private</code> methods within the interface. For example,
<pre class="color-example">
public interface <strong>MyJ9InterfaceWithPrivateStatic</strong> {
   <span class="color-comment">// private static helper method for use by all static/instance methods inside this interface</span>
   <span class="color-new">private static</span> void showMsg(String greeting, String name) {  <span class="color-comment">// private class</span>
      System.out.println(greeting + &quot;, &quot; + name);
   }

   <span class="color-new">default</span> void sayHello(String name) {  <span class="color-comment">// public instance</span>
      showMsg(&quot;hello&quot;, name);  <span class="color-comment">// call private static (class) helper method</span>
   }

   <span class="color-new">static</span> void staticSayHi(String name) {  <span class="color-comment">// public class</span>
      showMsg(&quot;hi&quot;, name);     <span class="color-comment">// call private static (class) helper method</span>
   }

   <span class="color-comment">// Other abstract, static methods</span>
}</pre>

<pre class="color-example">
public class <strong>MyJ9InterfaceWithPrivateStaticImpl implements MyJ9InterfaceWithPrivateStatic</strong> {
   <span class="color-comment">// to implement all abstract methods</span>
}</pre>

<pre class="color-example">
public class <strong>MyJ9InterfaceWithPrivateStaticTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Invoke static (class) method (no need to construct an instance)</span>
      MyJ9InterfaceWithPrivateStatic.staticSayHi(&quot;Peter&quot;);  <span class="color-comment">//<span class="color-output">hi, Peter</span></span>

      <span class="color-comment">// Invoke instance method, thru an instance</span>
      MyJ9InterfaceWithPrivateStatic h = new MyJ9InterfaceWithPrivateStaticImpl();
      h.sayHello(&quot;Paul&quot;);  <span class="color-comment">//<span class="color-output">hello, Paul</span></span>
   }
}</pre>
</li>
</ul>

<p>The benefits of interface private methods:</p>
<ul>
<li>Pull repeating codes into a helper method for code re-use.</li>
<li>The <code>private</code> methods are not exposed outside this class/interface, nor inherited by its subclasses.</li>
</ul>


<h4>Interface &quot;Instance&quot; Methods (JDK 8)</h4>
<p>There are three kinds of methods in JDK 8 interfaces: <code>abstract</code> (instance), <code>default</code> (instance) and <code>static</code> (class). All methods are <code>public</code>.</p>

<p>JDK 8 documentation for interfaces lists &quot;All methods&quot;, as well as &quot;Static methods&quot;, &quot;Instance methods&quot; (non-<code>static</code>, i.e., <code>abstract</code> and <code>default</code>), &quot;Abstract methods&quot; and &quot;Default methods&quot;. For example, checkout interface <code>java.util.stream.Stream</code>. Take note that <code>private</code> method (JDK 9) are not shown in the API documentation, as they are not meant for re-use.</p>

<h4>Interface vs. <span class="font-code">abstract</span> Superclass</h4>

<p>Prior to JDK 8, a Java <code>interface</code> is a <em>pure</em> abstract superclass, containing <code>public abstract</code> (instance) methods without implementation. JDK 8 introduces <code>public default</code> (instance) and <code>public static</code> (class) methods. JDK 9 introduces <code>private</code> (instance) and <code>private static</code> (class) methods.</p>
<p>JDK 8/9 blurs the distinction between interface and <code>abstract</code> superclass.</p>
<ol>
<li>Variables: Interface can contain only class variables (<code>public static final</code>). Abstract superclass can contain instance variables, but interface cannot.</li>
<li>Method Access Control: All methods (<code>abstract</code>, <code>static</code> and <code>default</code>) in interface are <code>public</code>. JDK 9 supports <code>private</code> (instance) and <code>private</code> <code>static</code> (class) methods.</li>
<li>A Java class can extend one superclass, but can implement multiple interfaces.</li>
</ol>



<h3 id="LambdaExpressions">Lambda Expressions</h3>

<h5>Reference:</h5>
<ol>
<li>Java Tutorial &quot;Lambda Expression&quot; @ <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a>.</li>
<li>&quot;Java SE 8: Lambda Quick Start&quot; @ <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html</a>.</li>
<li>Java Tutorial &quot;Collections&quot; @ <a href="http://docs.oracle.com/javase/tutorial/collections/">http://docs.oracle.com/javase/tutorial/collections/</a>.</li>
<li>Java Tutorial &quot;Aggregate Operations&quot; @ <a href="http://docs.oracle.com/javase/tutorial/collections/streams/index.html">http://docs.oracle.com/javase/tutorial/collections/streams/index.html</a>.</li>
</ol>



<p>&nbsp;</p>
<p>The most notable new language feature in JDK 8 is the <em>Lambda Expressions</em>, which provides a concise notation to <em>construct an instance of an anonymous inner class implementing a single-abstract-method interface.</em></p>
<p>JDK 8 also retrofitted the Collection framework by adding new <code>default</code> and <code>static</code> methods with Lambda expression to the interfaces, and the introduction of streams API, to support chaining and aggregate operations (or <em>filter-map-reduce</em>) in <em>functional programming</em>.</p>


<h4>Functional Interfaces</h4>

<p>An interface containing only ONE <code>abstract</code> method is called a <em>single-abstract-method interface</em> or <em>functional interface</em>.</p>

<p>JDK has many <em>functional interfaces</em>. The most commonly-used are:</p>
<ul>
<li>Interface <code>java.awt.event.ActionListener</code> with single abstract method <code>actionPerformed()</code>: used as <code>ActionEvent</code> handler.</li>
<li>Interface <code>java.lang.Runnable</code> with single abstract method <code>run()</code>: for starting a new thread.</li>
<li>Interface <code>java.util.Comparator</code> with single abstract method <code>compare()</code>: used in <code>Collections.sort()</code> or <code>Arrays.sort()</code>.</li>
</ul>

<p>These interfaces are commonly implemented in an anonymous inner class.</p>

<h5><span class="font-code">@FunctionalInterface</span> Annotation</h5>
<p>The <code>@FunctionalInterface</code> annotation can be used to mark and inform the compiler that an interface contains only one <code>abstract</code> method. This is useful to prevent accidental addition of extra <code>abstract</code> methods into a functional interface.</p>

<h4>Example 1: Hello Lambda</h4>

<p>We shall first define an interface with a single abstract method (called functional interface) as follows:</p>

<h5><span class="font-code">HelloFunctionalInterface.java</span></h5>
<pre class="color-example">
<span class="color-comment">// A Single-Abstract-Method Interface called Functional Interface</span>
<span class="color-new">@FunctionalInterface</span>   <span class="color-comment">// ask compiler to check this interface contains only one abstract method</span>
public interface <strong>HelloFunctionalInterface</strong> {
   void sayHello(String name);  <span class="color-comment">// public abstract</span>
}</pre>

<p>We could define an anonymous inner class implementing the interface, construct an instance and invoke the method as follows:</p>

<h5><span class="font-code">HelloFunctionalInterfaceInnerClassTest.java</span></h5>

<pre class="color-example">
public class <strong>HelloFunctionalInterfaceInnerClassTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Define an anonymous inner class implementing the interface.</span>
      <span class="color-comment">// Construct an instance and invoke the method.</span>
      HelloFunctionalInterface h = <span class="color-new">new HelloFunctionalInterface() {
         public void sayHello(String name) {
            System.out.println(&quot;Hello, &quot; + name);
         }
      }</span>;
      h.sayHello(&quot;Paul&quot;);
   }
}</pre>

<p>JDK 8 introduces <em>lambda expressions</em>, which provides a shorthand notation for creating an instance of an anonymous inner class implementing a functional interface (single-abstract-method interface). The above can be written in a single-line as follows:</p>

<h5><span class="font-code">HelloFunctionalInterfaceLambdaTest.java</span></h5>

<pre class="color-example">
public class <strong>HelloFunctionalInterfaceLambdaTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Define an anonymous inner class implementing the interface.</span>
      <span class="color-comment">// Construct an instance and invoke the method.</span>
      HelloFunctionalInterface h = <span class="color-new">name -&gt; System.out.println(&quot;Hello, &quot; + name)</span>;
             <span class="color-comment">// Using lambda expression as a shorthand for the above</span>
      h.sayHello(&quot;Peter&quot;);
   }
}</pre>

<p>Notes:</p>
<ul>
<li>The <em>lambda expression</em> consists of the method parameter and the method body, separated by <code>-&gt;</code>.</li>
<li>The <em>lambda expression</em> is an <em>expression</em> which evaluates to a value. It evaluates to an instance of an anonymous inner class implementing a functional interface.</li>
<li>The name of the functional interface can be deduced from the type declaration. The  parameters-type and return-type of the method can also be deduced, because there is only one method in the functional interface.</li>
</ul>

<h4>Example 2: Swing's <span class="font-code">ActionListener</span> Functional Interface Lambda</h4>

<p>In Swing programs, we use an <code>ActionListener</code> to handle the <code>ActionEvent</code>, triggered by pushing a button. <code>ActionListener</code> is a <em>functional interface</em> containing a single <code>abstract</code> method, defined as follows:</p>

<h5><span class="font-code">java.awt.event.ActionListener</span></h5>
<pre class="color-example">
package java.awt.event;

<strong>@FunctionalInterface</strong>   <span class="color-comment">// contains only one abstract method</span>
public interface <strong>ActionListener extends java.util.EventListener</strong> {
   <span class="color-new">void actionPerformed(ActionEvent e)</span>;  <span class="color-comment">// public abstract</span>
}</pre>

<p>The following Swing counter program contains a text field to display the count, and two buttons for counting up and counting down.</p>

<img src="images/Swing_CounterLambda.png" alt="Swing_CounterLambda.png"/>

<h5><span class="font-code">SwingCounterLambda.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td><pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></td>
<td><pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class <strong>SwingCounterLambda extends JFrame</strong> {
   private JTextField tfCount;
   private int count = 0;

   public SwingCounterLambda() {
      Container cp = getContentPane();
      cp.setLayout(new FlowLayout());

      cp.add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(count + &quot;&quot;, 8);
      tfCount.setEditable(false);
      cp.add(tfCount);

      <span class="color-comment">// Construct an instance of an anonymous inner class 
      //   implementing ActionListener as the ActionEvent handler</span>
      JButton btnUp = new JButton("Count Up");
      cp.add(btnUp);
      btnUp.addActionListener(<span class="color-new">new ActionListener() {
         public void actionPerformed(ActionEvent e) {
            tfCount.setText(++count + "");
         }
      }</span>);

      <span class="color-comment">// Using a Lambda Expression which evaluates to an instance of 
      //   an anonymous inner class implementing ActionListener functional interface</span>
      JButton btnDown = new JButton("Count Down");
      cp.add(btnDown);
      btnDown.addActionListener(<span class="color-new">e -&gt; tfCount.setText(--count + "")</span>);

      setSize(400, 100);
      setVisible(true);
   }
   public static void main(String[] args) {
      <span class="color-comment">// Using Lambda Expression which evaluates to a Runnable instance</span>
      SwingUtilities.invokeLater(<span class="color-new">() -&gt; new SwingCounterLambda()</span>);
   }
}</pre></td>
</tr>
</tbody>
</table>

<h5>How It Works</h5>

<ol>
<li>Using an anonymous inner class (Line 22 to 26) requires at least 5 lines of codes, which can be replaced by a one-liner Lambda Expression (Line 32). You can treat <em>Lambda Expression</em> as a <em>shorthand</em>. I will explain the syntax in the following section.</li>
<li>Similar, the <code>Runnable</code> can be coded in a one-liner using Lambda Expression (Line 39).</li>
</ol>

<h5>JavaFX</h5>
<p>For JavaFX, you can also replace an anonymous inner class <code>EventHandler</code> with a one-line lambda expression which evaluates to an instance of an anonymous inner class implementing a functional interface. For example,</p>
<pre class="color-example">
<span class="color-comment">// Anonymous inner class</span>
btn.setOnAction(<span class="color-new">new EventHandler&lt;ActionEvent&gt;() {
   @Override
   public void handle(ActionEvent e) {
      System.out.println(&quot;hello, world&quot;);
   }
}</span>);

<span class="color-comment">// Lambda Expression</span>
btn.setOnAction(<span class="color-new">e -&gt; System.out.println(&quot;hello, world&quot;)</span>);</pre>

<h4>Syntax of Lambda Expressions and Method References</h4>

<h5>Lambda Expressions <span class="font-code">(args) -&gt; { body }</span></h5>

<p>Prior to JDK 8, to construct an instance of an anonymous inner class that implements a Functional Interface (Single-Abstract-Method Interface) requires many lines of codes. Lambda Expression provides a shorthand notation. Moreover, you can pass  a lambda expression as a method argument (treating code as data), as shown in the above example.</p>
<p>Lambda Expression defines the &quot;sole&quot; method of a Functional Interface. It consists of 2 parts: parameters and method body, separated by <code>-&gt;</code>. The parameters are separated by commas and enclosed by parentheses. The parentheses can be omitted if there is only one parameter. The method body could be a statement or a block. The method name is omitted, as it can be inferred from the sole abstract method of the Functional Interface. The parameters' type and the return type are also optional, as they can be inferred from the method signature.</p>
<p>Lambda expression is an expression, which evaluates to a value. It evaluates to an instance of inner class implementing the deduced functional interface.</p>

<p>The syntax is:</p>
<pre class="color-syntax">
(arguments) -&gt; { body }</pre>

<p>For examples:</p>

<pre class="color-command">
() -&gt; statement    <span class="color-comment">// No argument and one-statement method body</span>

arg -&gt; statement   <span class="color-comment">// One argument (parentheses can be omitted) and method body</span> 

(arg1, arg2, ...) -&gt; { 
   body-block 
}   <span class="color-comment">// Arguments separated by commas and the block body</span>

(Type1 arg1, Type2 arg2, ...) -&gt; { 
   method-body-block;
   return return-value; 
}   <span class="color-comment">// With arguments and block body</span></pre>

<p>In other languages that support function variables or function objects (such as C++ and Python), Lambda is used to define an <em>anonymous function</em>. However, in JDK 8, Lambda expression is used to define the method implementation of an instance of an anonymous inner class implementing a Single-Abstract-Method Interface!</p>
<p>In fact, if you try to write:</p>

<pre class="color-example">
int i = () -&gt; 5;
<span class="color-comment">//</span><span class="color-error">compilation error: incompatible types: int is not a functional interface</span></pre>

<p>But,</p>

<pre class="color-example">
<span class="color-comment">// Using Lambda expression to construct a Runnable instance (of an anonymous inner class implementing Runnable).
// In other words, Lambda expression evaluates to an instance of Function Interface</span>
Runnable r = <span class="color-new">() -&gt; System.out.println(&quot;run run()&quot;);</span>
   <span class="color-comment">// Runnable is a functional interface
   // Lambda expression is used to define the implementation of the abstract method run()</span>

<span class="color-comment">// Using Lambda expression to construct an ActionListener instance</span>
ActionListener lis = <span class="color-new">e -&gt; System.out.println(&quot;run actionPerformed()&quot;)</span>;</pre>

<p>Java is an Object-oriented Programming language. Everything in Java are objects (except primitives). Functions are not objects in Java (but part of an object), and hence, they cannot exist by themselves.  Unlike other languages (such as C++, Python and JavaScript) functions can exist by themselves, and you can pass a function as a function's argument, and return a function from a function.</p>
<p>JDK 8's Functional Interface and Lambda Expression allow us to construct a &quot;Function Object&quot; in a one-liner (or a fewer lines of codes). However, it can be used only for objects with single abstract method.</p>

<h5>Method References <span class="font-code">Class::method</span></h5>
<p>JDK 8 introduced a new operator <code>::</code> to reference a method without invoking it - called <em>Method Reference</em>. For example,</p>

<pre class="color-example">
<span class="color-comment">// Method References</span>
System.out::println   <span class="color-comment">// static method of System.out</span>
   <span class="color-comment">// same as: e -&gt; System.out.println(e)</span>
Person::getName       <span class="color-comment">// instance method of class Person</span>
   <span class="color-comment">// same as p -&gt; p.getName()</span>

<span class="color-comment">// Constructor References</span>
Integer::new    <span class="color-comment">// Construct an Integer instance</span>
   <span class="color-comment">// same as: i -&gt; new Integer(i)</span>
int[]::new      <span class="color-comment">// Construct an int array</span>
   <span class="color-comment">// same as: len -&gt; new int[len]</span></pre>

<p>We can replace Lambda Expression <code>t -&gt; t.method()</code> with a method reference <code>ClassT::method</code>; or <code>t -&gt; Class.staticMethod(t)</code> with <code>Class::staticMethod</code>. For example,</p>

<pre class="color-example">
<span class="color-comment">// A Single-Abstract-Method Interface (Functional Interface)</span>
@FunctionalInterface
public interface <strong>HelloFunctionalInterface</strong> {
   void sayHello(String name);  <span class="color-comment">// public abstract</span>
}</pre>

<pre class="color-example">
public class <strong>HelloFunctionInterfaceMethodReferenceTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Using JDK 8 method references</span>
      HelloFunctionalInterface h = <span class="color-new">System.out::println</span>;
      <span class="color-comment">// same as:
      //HelloFunctionalInterface h = <span class="color-new">name -&gt; System.out.println(name)</span>;</span>
      
      h.sayHello("Peter");
      <span class="color-comment">//<span class="color-output">Peter</span></span>
   }
}</pre>


<h4>Example 3: <span class="font-code">Runnable</span> Lambda</h4>
<p>The <code>Runnable</code> interface defines a single <code>abstract</code> method, defined as follows:</p>

<h5><span class="font-code">java.lang.Runnable</span></h5>
<pre class="color-example">
<strong>@FunctionalInterface</strong>
public interface <strong>Runnable</strong> {
   void run();  <span class="color-comment">// public abstract</span>
}</pre>

<p>We can create a <code>Runnable</code> object via an anonymous inner class (Pre-JDK 8) or Lambda Expression (JDK 8), as follows:</p>

<h5><span class="font-code">RunnableLambdaTest.java</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td><pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td>
<td><pre>
public class <strong>RunnableLambdaTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Create an instance of an anonymous inner class implements Runnable interface</span>
      Runnable r1 = <span class="color-new">new Runnable() {
         public void run() {
            System.out.println(&quot;Runnable 1&quot;);
         }
      }</span>;
      <span class="color-comment">// Using a one-liner Lambda Expression as a shorthand of the above</span>
      Runnable r2 = <span class="color-new">() -&gt; System.out.println(&quot;Runnable 2&quot;)</span>;

      r1.run();  <span class="color-comment">//<span class="color-output">Runnable 1</span></span>
      r2.run();  <span class="color-comment">//<span class="color-output">Runnable 2</span></span>
   }
}</pre></td>
</tr>
</tbody>
</table>
<p>[TODO] Explanation</p>

<h4>Example 4: Binary Operator Functional Interface</h4>
<p>Let's define a Functional Interface to denote a binary operator (such as addition or subtraction), as follows:</p>

<h5><span class="font-code">MyIntBinaryOperator.java</span></h5>
<pre class="color-example">
@FunctionalInterface
public interface <strong>MyIntBinaryOperator</strong> {
   <span class="color-comment">// Apply a custom operator to two int operands and return an int</span>
   int applyAsInt(int left, int right);
}</pre>

<p>In the following class, the method <code>operate()</code> takes 2 <code>int</code>'s and an object of the above Functional Interface as parameters, and carries out the binary operation.</p>

<h5><span class="font-code">MyMathBinaryOperation.java</span></h5>

<pre class="color-example">
public class <strong>MyMathBinaryOperation</strong> {
   <span class="color-comment">// Define instances of MyIntBinaryOperator for add, subtract, multiply and divide
   // The single abstract method takes two int's and return an int</span>
   public <span class="color-new">MyIntBinaryOperator add = (left, right) -&gt; left + right;</span>
   public <span class="color-new">MyIntBinaryOperator sub = (left, right) -&gt; left - right;</span>
   public <span class="color-new">MyIntBinaryOperator mul = (left, right) -&gt; left * right;</span>
   public <span class="color-new">MyIntBinaryOperator div = (left, right) -&gt; left / right;</span>

   <span class="color-comment">// Carry out the binary operation with two operands and operator</span>
   public int operate(int left, int right, <span class="color-new">MyIntBinaryOperator operator</span>) {
      return <span class="color-new">operator.applyAsInt</span>(left, right);
   }

   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args){
      MyMathBinaryOperation op = new MyMathBinaryOperation();
      <span class="color-comment">// Use pre-defined IntBinaryOperator</span>
      System.out.println(&quot;8 + 9 = &quot; + op.operate(8, 9, <span class="color-new">op.add</span>));  <span class="color-comment">//<span class="color-output">8 + 9 = 17</span></span>
      System.out.println(&quot;8 - 9 = &quot; + op.operate(8, 9, <span class="color-new">op.sub</span>));  <span class="color-comment">//<span class="color-output">8 - 9 = -1</span></span>
      System.out.println(&quot;8 x 9 = &quot; + op.operate(8, 9, <span class="color-new">op.mul</span>));  <span class="color-comment">//<span class="color-output">8 x 9 = 72</span></span>
      System.out.println(&quot;8 / 9 = &quot; + op.operate(8, 9, <span class="color-new">op.div</span>));  <span class="color-comment">//<span class="color-output">8 / 9 = 0</span></span>
      <span class="color-comment">// Define a custom IntBInaryOperator via a Lambda Expression</span>
      System.out.println(&quot;2 ^ 5 = &quot; + op.operate(2, 5, <span class="color-new">(a, b) -&gt; (int)Math.pow(a, b))</span>);  <span class="color-comment">//<span class="color-output">2 ^ 5 = 32</span></span>
   }
}</pre>

<p>[TODO] Explanation</p>

<h5>Package <span class="font-code">java.util.function</span> (JDK 8)</h5>

<p>The JDK 8 new package <code>java.util.function</code> provides <em>similar</em> functional interfaces, such as type-specific <code>IntBinaryOperator</code>, <code>LongBinaryOperator</code>, <code>DoubleBinaryOperator</code>, and a generic <code>BinaryOperator</code>.</p>

<p>We will discuss the new <code>java.util.function</code> package in details later.</p>

<h4 id="ComparatorLambda">Example 5: <span class="font-code">Comparator&lt;T&gt;</span> Lambda</h4>

<p>We can use the <code>static</code> method <code>Collections.sort()</code> to custom sort a <code>Collection</code> object, which has the following signature:</p>

<pre class="color-example">
<span class="color-comment">// Utility Class java.util.<span class="color-new">Collections</span></span>
public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</pre>

<p>The second argument of <code>sort()</code> is a Functional Interface <code>Comparator</code>, which contains an <code>abstract</code> method <code>compare()</code> to compare two objects of the given <code>Collection</code>, defined as follows:</p>

<h5><span class="font-code">java.util.Comparator</span></h5>
<pre class="color-example">
package java.util;

<strong>@FunctionalInterface</strong>
public interface <strong>Comparator</strong>&lt;T&gt; {
   <span class="color-comment">// Compares its two arguments for order.
   // Returns a negative integer, zero, or a positive integer
   //   as the first argument is less than, equal to, or greater than the second.</span>
   int compare(T o1, T o2);  <span class="color-comment">// public abstract</span>
}</pre>

<p>Suppose that we have a <code>List</code> of <code>Person</code> objects, and want to perform a custom sort. Again, we could use an anonymous inner class (Pre-JDK 8), or a Lambda Expression (JDK 8) to construct a <code>Comparator</code> instance.</p>

<h5 id="ClassPerson"><span class="font-code">Person.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre>
</td>
<td>
<pre>
public class <strong>Person</strong> {
   private String name;  <span class="color-comment">// private instance variables</span>
   private int age;

   public Person(String name, int age) {  <span class="color-comment">// constructor</span>
      this.name = name; this.age = age;
   }
   public String getName() {  <span class="color-comment">// getter for name</span>
      return name;
   }
   public int getAge() {  <span class="color-comment">// getter for age</span>
      return age;
   }
   public String toString() {  <span class="color-comment">// describe itself</span>
      return name + &quot;(&quot; + age + &quot;)&quot;;
   }

   public void sayHello() {  <span class="color-comment">// for testing</span>
      System.out.println(name + &quot; says hello&quot;);
   }

   <span class="color-comment">// Compare two Person objects by name strings, case insensitive</span>
   @Override
   public boolean equals(Object o) {
      return o != null &amp;&amp; o instanceof Person &amp;&amp; this.name.equalsIgnoreCase(((Person)o).name);
   }
   <span class="color-comment">// To be consistent with equals()</span>
   <span class="color-comment">// Two objects which are equal shall have the same hashcode.</span>
   @Override
   public int hashCode() {
      return this.name.toLowerCase().hashCode();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5><span class="font-code">ComparatorLambdaTest.java</span></h5>

<pre class="color-example">
import java.util.*;
public class <strong>ComparatorLambdaTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = new ArrayList&lt;&gt;();  <span class="color-comment">// JDK 7</span>
      pList.add(new Person(&quot;Peter&quot;, 21));
      pList.add(new Person(&quot;Paul&quot;, 18));
      pList.add(new Person(&quot;Patrick&quot;, 22));
      System.out.println(pList);
         <span class="color-comment">//<span class="color-output">[Peter(21), Paul(18), Patrick(22)]</span> (Unsorted)</span>

      <span class="color-comment">// In JDK 9, you can write:</span>
      List&lt;Person&gt; pList9 = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;Paul&quot;, 18), new Person(&quot;Patrick&quot;, 22));
      System.out.println(pList9);
      
      <span class="color-comment">// Using an anonymous inner class to create a Comparator instance to sort by name</span>
      Collections.sort(pList, <span class="color-new">new Comparator&lt;Person&gt;() {
         @Override
         public int compare(Person p1, Person p2){
            return p1.getName().compareToIgnoreCase(p2.getName());  <span class="color-comment">// String's compareToIgnoreCase()</span>
         }
      })</span>;
      System.out.println(pList);
         <span class="color-comment">//<span class="color-output">[Patrick(22), Paul(18), Peter(21)]</span> (Sort by name)</span>

      <span class="color-comment">// Using a Lambda Expression to create a Comparator instance to sort by age</span>
      Collections.sort(pList, <span class="color-new">(p1, p2) -&gt; p1.getAge() - p2.getAge()</span>);
      System.out.println(pList);
         <span class="color-comment">//<span class="color-output">[Paul(18), Peter(21), Patrick(22)]</span> (Sort by age)</span>
   }
}</pre>

<h5>How It Works</h5>

<ol>
<li>For the first <code>sort()</code>, we use an anonymous inner class to construct an instance of <code>Comparator</code> to sort by name; whereas for the second <code>sort()</code>, we replaced by a one-liner lambda expression to construct an instance of <code>Comparator</code> to sort by age.</li>
</ol>

<p>Read &quot;<a href="J5c_Collection.html#ordering"><span class="font-code">List</span> Ordering/Searching/Sorting with <span class="font-code">Comparable&lt;T&gt;/Comparator&lt;T&gt;</span></a>&quot; for more details.</p>

<h3>Introduction to Functional Programming</h3>

<h4>Object-Oriented Programming vs. Functional Programming</h4>

<p>Object-Oriented Programming (OOP) is a programming paradigm based on the concept of <em>objects</em>, which encapsulate <em>data</em>  and <em>code</em> (or <em>behavior</em>) in the same box.</p>
<p>Functional programming (FP) is a programming paradigm that treats computation   as applying a series of mathematical functions (or transforms) to the data. It avoids changing-state and mutable data.</p>
<p>In a program, there are two primary components: data and code. OOP brings together data and its associated code into an <em>object</em> to make it easier to understand how a program works. FP says that data and behavior are distinctively different and should be kept separate for clarity.</p>

<p>As a Java Programmer, you should be familiar with OOP, but FP could be new to you.</p>

<h5>FP's Key Concepts</h5>

<ul>
<li><span class="line-heading">First-class functions</span>: You can store functions in variables or data structures; you can pass them as parameters, or return them from other functions.</li>
<li><span class="line-heading">Immutability</span>: The data and objects are immutable, i.e., the their state cannot be changed after their creation.</li>
<li><span class="line-heading">No Side Effects</span>: You use <em>pure functions</em> that return the same result given the same inputs without modifying the state of other objects or interact with the outside world.</li>
</ul>

<h5>FP's Benefits</h5>
<ul>
<li><span class="line-heading">Conciseness</span>: Working with first-class functions could be more powerful in abstraction, and let you avoid duplicate code. Anonymous functions can be written in concise syntax called lambda expression.</li>
<li><span class="line-heading">Safe Multithreading</span>: Immutable data and pure functions ensure that unsafe modifications won't happen, and you don't need to worry about complex synchronization schemes.</li>
<li><span class="line-heading">Ease in Testing</span>: Pure functions (without side effects) can be tested in isolation, without the need to setup the entire environment that they depend on.</li>
</ul>

<h5>Example: Filter-Map-Reduce Use Case</h5>

<p>Let's illustrate the differences of the two approaches with the following example.</p>


<p> Suppose that we have a list of persons (containing names and ages), and we wish to find the average age of all the adults. This use case is known as <em>filter-map-reduce</em> (or <em>map-filter-reduce</em> or <em>map-reduce</em>).</p>

<ol>
<li>Loop through the entire list to process each element (in this example, person).</li>
<li>Filter with some criteria (age &gt;= 21).</li>
<li>Map or transform the element (from person to age).</li>
<li>Reduce or collect the desired result (the average age).</li>
</ol>

<h5>OOP Approach</h5>
<p>In OOP, we will write a class called <code>Person</code>, which encapsulates the data (<code>name</code>, <code>age</code>) and methods (<code>getName()</code>, <code>getAge()</code>). See above &quot;<a href="JDK8_Lambda.html#ClassPerson">Person.java</a>&quot;.</p>

<p>We construct a <code>List&lt;Person&gt;</code> and apply the <em>filter-map-reduce</em> operations via a loop on each of the <code>Person</code> objects.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
import java.util.List;
public class <strong>FilterMapReduceOOPTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(  <span class="color-comment">// (JDK 9) create an unmodifiable List</span>
         new Person(&quot;Peter&quot;, 21),
         new Person(&quot;John&quot;, 16),
         new Person(&quot;Paul&quot;, 60)
      );
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(16), Paul(60)]</span></span><br>      int sum = 0;
      int countAdults = 0;
      double average;

      for (Person p : pList) {  <span class="color-comment">// loop</span>
         int age = p.getAge();
         if (age &gt;= 21) {       <span class="color-comment">// filter</span>
            sum += age;     <span class="color-comment">// map</span>
            ++countAdults;
         }
      }
      average = (double)sum / countAdults;  <span class="color-comment">// reduce</span>
      System.out.println(average);  <span class="color-comment">//<span class="color-output">40.5</span></span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In OOP:</p>
<ol>
<li>We first define the class.</li>
<li>We then create instances of class (<code>List&lt;Person&gt;</code>)</li>
<li>We apply filter-map-reduce operations on each of the elements, via a for-each loop.</li>
<li>Data are fed to objects during construction. We invoke methods on objects to interact with the data stored.</li>
<li>The data (instances) are typically mutable.</li>
</ol>

<h5>FP Approach</h5>
<p>In FP, the data and behavior are separated. Data are often kept in a simple structure, such as an array, lists, map, or record (JDK 14). Behavior is implemented in tiny, standalone and specialized functions. Data are immutable.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre>
</td>
<td>
<pre>
import java.util.Map;
public class <strong>FilterMapReduceFPTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Data are kept in simple structure such as a map of key-value pairs</span>
      Map&lt;String, Integer&gt; pMap = Map.of(&quot;Peter&quot;, 21, &quot;John&quot;, 16, &quot;Paul&quot;, 60);  <span class="color-comment">// (JDK 9)</span>
      System.out.println(pMap);  <span class="color-comment">//<span class="color-output">{John=16, Peter=21, Paul=60}</span></span>

      <span class="color-comment">// Using JDK 8 Stream API for filter-map-reduce operation</span>
      double average = pMap
         .entrySet()
         .stream()
         .filter(p -&gt; p.getValue() &gt;= 21)
         .mapToInt(Map.Entry::getValue)
         .average()
         .getAsDouble();
      System.out.println(average);  <span class="color-comment">//40.5</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<p><span class="line-heading">Explanation</span>: You need to read the entire article to understand the syntax, but notice that data are passed through a sequence of operations (a chain of functions) to produce the result.</p>

<p>In FP, data are kept in simple arrays, hashes, records, instead of high-level objects. Data are not mix with behavior. Data are immutable and shared state is avoided. FP relies heavily on tiny and specialized functions that do one small part of a larger job, and delegate the details to other tiny functions.</p>
<p>FP views computation as <em>data transformation</em>: you start with the original dataset, apply transformations to generate a new dataset. The contents (or state) of the original data does not change. A new state after the transformation is created.</p>
<p>FP focuses computation on <em>pure functions</em>. A <em>pure function</em> is a function where:</p>
<ol>
<li>The return value depends only on the input, i.e., the same input always produces the same return value.</li>
<li>There is no side effect.</li>
<li>It does not alter the data that was passed into it.</li>
</ol>

<h5>OOP and FP Comparison</h5>

<ul>
<li>FP is good when you have a fixed set of data; and as your application evolves, you <em>add new functions</em> to operate on existing data. The existing functions are left alone. For example, [TODO]</li>
<li>FP is often used in Big Data Analytic.</li>
<li>FP is good in concurrent environments (parallel processing). The immutable state enables easy concurrency.</li>
<li>OOP is good when you have a fixed set classes (data and behavior); and as your application evolves, you <em>add new classes</em> (with composition or inheritance). The existing classes are left alone. For example, [TODO]</li>
</ul>

<p>However, when the evolution goes the wrong way, you have problems:</p>
<ul>
<li>Adding new data to a FP program may require modifying many existing functions. For example, [TODO]</li>
<li>Adding a new method to an OO program may require modifying many existing classes. For example, [TODO]</li>
</ul>

<p>However, you don't necessarily have to choose between OOP and FP, you can write applications with an OO architecture using many functional concepts. Developers can create tiny, standalone and specialized functions in an OO environment.</p>

<h4>JDK 8's Support for FP</h4>

<p>In order to support functional programming, JDK 8 re-designs the interface, introduces <em>lambda expression</em>, retrofits the Collection framework and introduce Stream API.</p>
<p>We have describe the new interface and lambda expressions. We shall continue into Stream API and Functional Programming.</p>

<h3 id="FunctionalProgramming">Functional Programming in Java</h3>

<p>Let's revisit the previous example on filter-map-reduce.</p>

<h4>Example Use Case: Filter-Map-Reduce</h4>
<p>Suppose that we have a <code>List</code> (a subclass of <code>Collection</code>) of <code>Person</code> objects and we want to:</p>
<ol>
<li><em>Loop</em> through the entire list to process each element (i.e., <code>Person</code> object).</li>
<li><em>Filter</em> with some criteria (e.g., <code>age &gt;= 21</code>).</li>
<li><em>Map</em> or <em>transform</em> the element (e.g., from <code>Person</code> to <code>name</code> or <code>age</code>).</li>
<li><em>Reduce</em> or <em>collect</em> the desired result (e.g., invoke <code>sayHello()</code>, <code>toString()</code>, or find the average age).</li>
</ol>

<p>The codes should be general to handle any <em>filtering criteria</em>, any <em>mapping transform</em>s, and any <em>reduction operations</em>.</p>

<h4>Filter-Map-Reduce 1: Roll Your Own Functional Interfaces for Filter-Reduce</h4>

<p><span class="line-heading"><span class="font-code">Person.java</span>:</span> see &quot;<a href="JDK8_Lambda.html#ClassPerson">Person.java</a>&quot;.</p>


<p><span class="line-heading"><span class="font-code">MyPredicate&lt;T&gt;.java</span>:</span> Define a Functional Interface called <code>MyPredicate&lt;T&gt;</code> to perform filtering, based on a <code>boolean</code> function <code>test()</code>, as follows. A <em>predicate</em> is a boolean function or relation that returns true to indicate such a relation, i.e., <code>P: o -&gt; {true, false}</code>.</p>

<pre class="color-example">
@FunctionalInterface   <span class="color-comment">// single-abstract-method interface</span>
public interface <strong>MyPredicate&lt;T&gt;</strong> {  <span class="color-comment">// use generic to handle all types of objects</span>
   boolean test(T o);  <span class="color-comment">// Perform this boolean test on the given Object</span>
}</pre>

<p><span class="line-heading"><span class="font-code">MyConsumer&lt;T&gt;.java</span>:</span> Define a Functional Interface called <code>MyConsumer&lt;T&gt;</code> to run some operations on a <code>Person</code> object, as follows. A <em>consumer</em> is a function that has side effect (such as printing) and returns <code>void</code>, i.e., <code>C: o -&gt; void</code>.</p>
<pre class="color-example">
@FunctionalInterface  <span class="color-comment">// single-abstract-method interface</span>
public interface <strong>MyConsumer&lt;T&gt;</strong> {  <span class="color-comment">// use generic to handle all types of objects</span>
   void accept(T o);  <span class="color-comment">// Run the side-effect on the given object</span>
}</pre>


<p><span class="line-heading"><span class="font-code">ProcessPersonList1.java</span>:</span> we shall define a <code>static</code> method <code>process()</code> to carry out the filter-reduce operation, by <em>looping</em> through the <code>List&lt;Person&gt;</code>. We can test with various filters and reduction operations as in test driver:</p>

<pre class="color-example">
import java.util.List;

public class <strong>ProcessPersonList1</strong> {
   <span class="color-comment">// A generic method given a List&lt;T&gt;, filter with MyPredicate&lt;T&gt;, and consume with MyConsumer&lt;T&gt;</span>
   public static <span class="color-new">&lt;T&gt; void process(List&lt;T&gt; lst, MyPredicate&lt;T&gt; predicate, MyConsumer&lt;T&gt; consumer)</span> {
      for (T e : lst) {
         if (predicate.test(e)) {  <span class="color-comment">// Filter</span>
            consumer.accept(e);    <span class="color-comment">// Reduce</span>
         }
      }
   }

   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21),  <span class="color-comment">// (JDK 9) create an unmodificable list</span>
                                   new Person(&quot;John&quot;, 60),
                                   new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Pre-JDK 8: Using an anonymous inner class to implement the interface</span>
      process(
         pList,
         <span class="color-new">new MyPredicate&lt;Person&gt;() {
            @Override
            public boolean test(Person p) {
               return p.getAge() &gt;= 21;  <span class="color-comment">// Filtering criteria</span>
            }
         }</span>,
         <span class="color-new">new MyConsumer&lt;Person&gt;() {
            @Override
            public void accept(Person p) {
               p.sayHello();   <span class="color-comment">// Apply this operation</span>
            }
         }</span>
      );
      <span class="color-comment">//<span class="color-output">Peter says hello</span></span>
      <span class="color-comment">//<span class="color-output">John says hello</span></span>

      <span class="color-comment">// JDK 8: Using Lambda Expressions to create an instance of an inner class</span>
      <span class="color-comment">//   implementing the functional interface</span>
      process(pList, <span class="color-new">p -&gt; p.getAge() &lt; 21</span>, <span class="color-new">Person::sayHello</span>);
      <span class="color-comment">//<span class="color-output">Paul says hello</span></span>
   }
}</pre>

<h5>Dissecting the Program</h5>

<ol>
<li>The <code>MyPredicate&lt;T&gt;</code> and <code>MyConsumer&lt;T&gt;</code> are defined using <em>generics</em> to handle all types of objects. During instantiation, we replace <code>T</code> with <code>Person</code> to handle the <code>Person</code> objects.</li>
<li>The <code>static</code> method <code>process()</code> is also defined with <em>generics</em>. We need to declare the generic type <code>&lt;T&gt;</code> before the return type.</li>

<li>A Functional Interface is an interface that contains only one abstract method, which can be marked by <code>@FunctionalInterface</code> annotation.</li>
<li>A lambda expression can be used as a shorthand to create an instance of an anonymous inner class implementing a functional interface.</li>
<li>[TODO] more</li>

</ol>

<h4>Filter-Map-Reduce 2: Using JDK 8 Pre-defined Functional Interfaces in Package <span class="font-code">java.util.function</span></h4>

<p>JDK 8  added a new package <code>java.util.function</code>, which contains many standard functional interfaces, including <code>Predicate&lt;T&gt;</code> and <code>Consumer&lt;T&gt;</code>, defined with <em>generics</em>, as follows:</p>

<p><span class="line-heading"><span class="font-code">java.util.function.Predicate&lt;T&gt;</span>:</span></p>
<pre class="color-example">
package java.util.function;

@FunctionalInterface
public interface <strong>Predicate&lt;T&gt;</strong> {
   boolean test(T t);  <span class="color-comment">// Evaluates this predicate on the given object.</span>
   ......              <span class="color-comment">// other default and static methods (JDK 8)</span>
}</pre>

<p><span class="line-heading"><span class="font-code">java.util.function.Consumer&lt;T&gt;</span>:</span></p>
<pre class="color-example">
package java.util.function;

@FunctionalInterface
public interface <strong>Consumer&lt;T&gt;</strong> {
   void accept(T t);  <span class="color-comment">// Run this operation on the given object.</span>
   ......             <span class="color-comment">// other default and static methods (JDK 8)</span>
}</pre>


<p>Instead of rolling our own functional interfaces in the previous example, we shall use the pre-defined ones.</p>

<p><span class="line-heading"><span class="font-code">ProcessPersonList2.java</span>:</span> We re-write <code>process()</code>, which uses the standard functional interfaces <code>Predicate&lt;T&gt;</code> and <code>Consumer&lt;T&gt;</code> as follows:</p>

<pre class="color-example">
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Consumer;

public class <strong>ProcessPersonList2</strong> {
   <span class="color-comment">// A generic method given a List&lt;T&gt;, filter with Predicate&lt;T&gt;, and consume with Consumer&lt;T&gt;</span>
   public static <span class="color-new">&lt;T&gt; void process(List&lt;T&gt; lst, Predicate&lt;T&gt; predicate, Consumer&lt;T&gt; consumer)</span> {
      for (T e : lst) {
         if (predicate.test(e)) {
            consumer.accept(e);
         }
      }
   }

   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21),  <span class="color-comment">// (JDK 9) create an unmodificable List</span>
                                   new Person(&quot;John&quot;, 60),
                                   new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Using JDK 8 standard functional interfaces Predicate&lt;T&gt; and Consumer&lt;T&gt; with lambda expressions</span>
      process(pList, <span class="color-new">p -&gt; p.getAge() &gt;= 21</span>, <span class="color-new">Person::sayHello</span>);
      <span class="color-comment">//<span class="color-output">Peter says hello</span></span>
      <span class="color-comment">//<span class="color-output">John says hello</span></span>
   }
}</pre>

<h4>Filter-Map-Reduce 3: Filter-Map-Reduce</h4>
<p>Suppose that instead of operating on the filtered <code>List&lt;Person&gt;</code>, we want to operate on a certain property of <code>Person</code> (e.g., <code>name</code> or <code>age</code>), then we need to add a mapper or transformer to transform a Person object to the property <code>name</code> or <code>age</code>. This is known as <em>filter-map-reduce</em> pattern. We shall use the standard Functional Interface <code>java.util.function.Function</code> as our mapper, which transforms from type <code>T</code> to <code>R</code>, i.e., <code>F: T -&gt; R</code>, defined as follows:</p>

<p><span class="line-heading"><span class="font-code">java.util.function.Function</span>:</span></p>
<pre class="color-example">
package java.util.function;

@FunctionalInterface
public <strong>Function&lt;T, R&gt;</strong> {
   R apply(T t);  <span class="color-comment">// Apply this mapping to the given object of type T and return an object of type R</span>
   ......         <span class="color-comment">// other default and static methods (JDK 8)</span>
}</pre>

<p><span class="line-heading"><span class="font-code">ProcessPersonList3.java</span>:</span> We re-write method <code>process()</code> and test this new method as follows:</p>

<pre class="color-example">
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Function;
import java.util.function.Consumer;

public class ProcessPersonList3 {
   <span class="color-comment">// A generic method given a List&lt;T&gt;, filter with Predicate&lt;T&gt;, apply mapper Function&lt;T,R&gt;,</span>
   <span class="color-comment">//   and reduce with Consumer&lt;R&gt; (filter-map-reduce pattern)</span>
   public static <span class="color-new">&lt;T,R&gt; void process(List&lt;T&gt; lst,
                               Predicate&lt;T&gt; predicate,
                               Function&lt;T, R&gt; mapper,
                               Consumer&lt;R&gt; consumer)</span> {
      for (T e : lst) {
         if (predicate.test(e)) {
            R r = mapper.apply(e);  <span class="color-comment">// Apply mapper to transform from T to R</span>
            consumer.accept(r);
         }
      }
   }

   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21),  <span class="color-comment">// (JDK 9) create an unmodificable List</span>
                                   new Person(&quot;John&quot;, 60),
                                   new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// (JDK 8) Using Lambda Expression</span>
      process(
         pList,
         <span class="color-new">p -&gt; p.getAge() &gt;= 21</span>,  <span class="color-comment">// filter</span>
         <span class="color-new">Person::getName</span>,        <span class="color-comment">// map</span>
         <span class="color-new">System.out::println</span>     <span class="color-comment">// reduce</span>
      );
      <span class="color-comment">//<span class="color-output">Peter</span></span>
      <span class="color-comment">//<span class="color-output">John</span></span>
   }
}</pre>

<p>[TODO] Explanation</p>

<h4>Package <span class="font-code">java.util.function</span> (JDK 8)</h4>

<p>JDK 8 introduces a new package <code>java.util.function</code>, which provides a number of <em>Standard Functional Interfaces</em>. Besides declaring one <code>abstract</code> method, these interfaces also heavily use <code>default</code> and <code>static</code> methods (with implementation) to enhance their functionality.</p>

<p>There are four basic  patterns (suppose that <code>t</code> is an instance of <code>T</code>):</p>
<ul>
<li><code><span class="color-new">Predicate&lt;T&gt;: t -&gt; boolean</span></code>: Apply boolean test on the given <code>t</code>.</li>
<li><code><span class="color-new">Function&lt;T, R&gt;: t -&gt; r</span></code>: Transform or mapping from <code>t</code> to <code>r</code>.</li>
<li><code><span class="color-new">Consumer&lt;T&gt;: t -&gt; void</span></code>: Consume <code>t</code> with side effect such as printing</li>
<li><code><span class="color-new">Supplier&lt;T&gt;: () -&gt; t</span></code>: Supply an instance <code>t</code>.</li>
</ul>

<p>The following table summaries the Functional Interfaces. Take note that with the use of lambda expressions, you only have to focus on the parameters and return type/value. You can ignore the <code>abstract</code> method name as it will be inferred.</p>



<table class="table-zebra" style="width:100%">
<tr>
  <th>Pattern</th>
  <th>Functional Interface</th>
  <th>Lambda Expression</th>
  <th>Explanation</th>
</tr>
<tr>
  <td rowspan="2" class="font-code">Predicate</td>
  <td class="font-code">Predicate&lt;T&gt;</td>
  <td class="font-code">t -&gt; boolean</td>
  <td>Apply <code>boolean</code> test on the given element <code>t</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">BiPredicate&lt;T, U&gt;</td>
  <td class="font-code">(t, u) -&gt; boolean</td>
  <td>Binary predicate on <code>t</code> and <code>u</code></td>
</tr>
<tr>
  <td rowspan="4" class="font-code">Function</td>
  <td class="font-code">Function&lt;T, R&gt;</td>
  <td class="font-code">t -&gt; r</td>
  <td>Transform (Map) from <code>t</code> to <code>r</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">BiFunction&lt;T, U, R&gt;</td>
  <td class="font-code">(t, u) -&gt; r</td>
  <td>Binary function</td>
</tr>
<tr>
  <td class="font-code">UnaryOperator&lt;T&gt;</td>
  <td class="font-code">t -&gt; t</td>
  <td>A unary operator on <code>T</code>, special case (extends) of <code>Function&lt;T, T&gt;</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">BinaryOperator&lt;T&gt;</td>
  <td class="font-code">(t, t) -&gt; t</td>
  <td>A binary operator on <code>T</code>, special case (extends) of <code>BiFunction&lt;T, T, T&gt;</code></td>
</tr>
<tr>
  <td rowspan="2" class="font-code">Consumer</td>
  <td class="font-code">Consumer&lt;T&gt;</td>
  <td class="font-code">t -&gt; void</td>
  <td>Consume <code>t</code> with side effect such as printing</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">BiConsumer&lt;T, U&gt;</td>
  <td class="font-code">(t, u) -&gt; void</td>
  <td>Binary consumer</td>
</tr>
<tr>
  <td rowspan="2" class="font-code">Supplier</td>
  <td class="font-code">Supplier&lt;T&gt;</td>
  <td class="font-code">() -&gt; t</td>
  <td>Supply  an instance t<code></code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">BooleanSupplier</td>
  <td class="font-code">() -&gt; boolean</td>
  <td>Supply a boolean value</td>
</tr>
</table>

<h5>Primitive Type Specializations for <span class="font-code">int</span>, <span class="font-code">long</span> and <span class="font-code">double</span></h5>

<p>For greater efficiency, specialized functional interfaces are defined for primitive types <code>int</code>, <code>long</code> and <code>double</code>, as summarized below:</p>

<table class="table-zebra" style="width:100%">
<tr>
  <th>Pattern</th>
  <th>Functional Interface</th>
  <th>Lambda Expression</th>
</tr>
<tr>
  <td class="font-code">Predicate</td>
  <td class="font-code">IntPredicate</td>
  <td class="font-code">int -&gt; boolean</td>
</tr>
<tr class="tr-alt">
  <td rowspan="7" class="font-code">Function</td>
  <td class="font-code">IntFunction&lt;R&gt;</td>
  <td class="font-code">int -&gt; r</td>
</tr>
<tr>
  <td class="font-code">IntToDoubleFunction</td>
  <td class="font-code">int -&gt; double</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">IntToLongFunction</td>
  <td class="font-code">int -&gt; long</td>
</tr>
<tr>
  <td class="font-code">ToIntFunction&lt;T&gt;</td>
  <td class="font-code">t -&gt; int</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">ToIntBiFunction&lt;T, U&gt;</td>
  <td class="font-code">(t, u) -&gt; int</td>
</tr>
<tr>
  <td class="font-code">IntUnaryOperator</td>
  <td class="font-code">int -&gt; int</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">IntBinaryOperator</td>
  <td class="font-code">(int, int) -&gt; int</td>
</tr>
<tr>
  <td rowspan="2" class="font-code">Consumer</td>
  <td class="font-code">IntConsumer</td>
  <td class="font-code">int -&gt; void</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">ObjIntConsumer&lt;T&gt;</td>
  <td class="font-code">(t, int) -&gt; void</td>
</tr>
<tr>
  <td class="font-code">Supplier</td>
  <td class="font-code">IntSupplier</td>
  <td class="font-code">() -&gt; int</td>
</tr>
</table>

<p><strong>Notes</strong>: Same Functional Interfaces as <code>int</code> are also defined for primitives <code>long</code> and <code>double</code>.</p>


<p>&nbsp;</p>
<p>Some of the functional interfaces with examples are elaborated below.</p>

<h5><span class="font-code">Predicate&lt;T&gt;: t -&gt; boolean</span></h5>

<p><span class="line-heading font-code"></span>A predicate is a <code>boolean</code> function in the form of <code>P: T -&gt; {true, false}</code>.</p>

<p>The <code>java.util.function.Predicate</code> functional interface contains:</p>
<ol>
<li><code>abstract</code> <code>boolean</code> method <code>test()</code> to implement predicate test.</li>
<li><code>default</code> methods <code>and()</code>, <code>or()</code> and <code>negate()</code> for logical AND, OR and NOT with <code>test()</code>.</li>
<li><code>static</code> method <code>isEqual()</code> for equality test on arguments.</li>
</ol>

<p>How it works?</p>
<ol>
<li>A <code>Predicate</code> instance implements <code>Predicate</code> interface to provide implementation for the <code>test()</code> <code>abstract</code> method.</li>
<li>Methods such as <code>aStream.filter(aPredicate)</code> takes <code>aPredicate</code> as its argument. It then invokes <code>aPredicate.test(e)</code> on each of its elements <code>e</code>, which returns <code>true/false</code>, to decide if the element is to be filtered in/out.</li>
<li>Lambda expression hides the name of the <code>abstract</code> method and the <code>Predicate</code>, e.g., <code>aStream.filter(p -&gt; p.getAge() &gt;= 21)</code>. You simply apply the method body to each of the elements <code>p</code>.</li>
</ol>


<p>Study the code, which is extracted from the JDK source.</p>


<pre class="color-example">
package java.util.function;
import java.util.Objects;

@FunctionalInterface
public interface <span class="color-new">Predicate&lt;T&gt;</span> {
   boolean <span class="color-new">test</span>(T t);  <span class="color-comment">// Evaluates this predicate on the given argument.</span>

   <span class="color-comment">// Returns a composed predicate that represents a short-circuiting logical AND
   //   of this predicate and another.</span>
   default Predicate&lt;T&gt; <span class="color-new">and</span>(Predicate&lt;? super T&gt; other) {
      Objects.requireNonNull(other);  <span class="color-comment">// ensure &quot;other&quot; is NOT null</span>
      return (t) -&gt; this.test(t) &amp;&amp; other.test(t);  <span class="color-comment">// return an instance of Predicate&lt;T&gt;</span>
   }
   <span class="color-comment">// Returns a composed predicate that represents a short-circuiting logical OR
   //   of this predicate and another.</span>
   default Predicate&lt;T&gt; <span class="color-new">or</span>(Predicate&lt;? super T&gt; other) {
      Objects.requireNonNull(other);
      return (t) -&gt; test(t) || other.test(t);
   }

   <span class="color-comment">// Returns a predicate that represents the logical negation of this predicate.</span>
   default Predicate&lt;T&gt; <span class="color-new">negate</span>() {
      return (t) -&gt; !test(t);
   }

   <span class="color-comment">// A static method to create a Predicate that tests if if the element is the same
   //   as the the argument, according to Objects.equals(Object, Object)</span>
   static &lt;T&gt; Predicate&lt;T&gt; <span class="color-new">isEqual</span>(Object targetRef) {
        return (null == targetRef)
               ? Objects::isNull  <span class="color-comment">// true if both are null</span>
               : object -&gt; targetRef.equals(object);
   }
}</pre>

<h5>Example on <span class="font-code">Predicate&lt;T&gt;</span></h5>

<pre class="color-example">
import java.util.List;
import java.util.function.Predicate;

public class <strong>FunctionInterfacePredicateTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Define Predicate objects, which are boolean tests that returns true/false, to be used as filtering criteria</span>
      <span class="color-new">Predicate&lt;Person&gt; adult = p -&gt; p.getAge() &gt;= 21;
      Predicate&lt;Person&gt; senior = p -&gt; p.getAge() &gt;= 55;
      Predicate&lt;Person&gt; junior = p -&gt; p.getAge() &lt;= 15;</span>

      pList.stream().filter(<span class="color-new">adult</span>).map(Person::getName).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter</span></span>
      <span class="color-comment">//<span class="color-output">John</span></span>
      pList.stream().filter(<span class="color-new">senior.or(junior)</span>).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">John(60)</span></span>
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>
      pList.stream().filter(<span class="color-new">senior.and(junior)</span>).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">no output</span></span>
      pList.stream().filter(<span class="color-new">adult.negate()</span>).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>

      <span class="color-new">Predicate&lt;Person&gt; notAdult = adult.negate();</span>
      pList.stream().filter(<span class="color-new">notAdult</span>).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>
      
      <span class="color-comment">// static method isEqual(Object) creates a Predicate to test if the element is the same as the argument</span>
      <span class="color-new">Predicate&lt;Person&gt; john = Predicate.isEqual(new Person(&quot;john&quot;, 80));</span>  <span class="color-comment">// name only ignore case</span>
      pList.stream().filter(<span class="color-new">john.negate()</span>).forEach(System.out::println);   <span class="color-comment">// filter out John</span>
      <span class="color-comment">//<span class="color-output">Peter(21)</span>
      //<span class="color-output">Paul(15)</span></span>
   }
}</pre>

<h5><span class="font-code">Function&lt;T, R&gt;: t -&gt; r</span></h5>

<p>A <code>Function</code> is a transform or mapping from <code>t</code> to <code>r</code>.<code></code></p>
<p>The source code (extracted from JDK source) is as follows:</p>
<pre class="color-example">
package java.util.function;
import java.util.Objects;<br>
@FunctionalInterface
public <span class="color-new">Function&lt;T, R&gt;</span> {
   <span class="color-comment">// Applies this Function to the given argument.</span>
   R <span class="color-new">apply</span>(T t);
    
   <span class="color-comment">// Returns a composed Function that first applies the before Function to its input,
   //   and then applies this Function to the result</span>
   default &lt;V&gt; Function&lt;V, R&gt; <span class="color-new">compose</span>(Function&lt;? super V, ? extends T&gt; before) {
      Objects.requireNonNull(before);  <span class="color-comment">// ensure before is NOT null</span>
      return (V v) -&gt; this.apply(before.apply(v));  <span class="color-comment">// before.apply then this.apply</span>
   }
     
   <span class="color-comment">// Returns a composed Function that first applies this Function to its input,
   //   and then applies the after Function to the result</span>
   default &lt;V&gt; Function&lt;T, V&gt; <span class="color-new">andThen</span>(Function&lt;? super R, ? extends V&gt; after) {
      Objects.requireNonNull(after);
      return (T t) -&gt; after.apply(this.apply(t));
   }
    
   <span class="color-comment">// static method to generate a Function that always returns its input argument</span>
   static &lt;T&gt; Function&lt;T, T&gt; <span class="color-new">identity</span>() {
      return t -&gt; t;
   }
}</pre>

<h5>Example on <span class="font-code">Function&lt;T,R&gt;</span></h5>

<pre class="color-example">
import java.util.List;
import java.util.function.Function;
import java.util.function.Predicate;

public class <strong>FunctionInterfaceFunctionTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Define Function&lt;T, R&gt; objects for transforming from t to r</span>
      <span class="color-new">Function&lt;Person, String&gt; name = Person::getName;
      Function&lt;String, Integer&gt; length = String::length;
      Function&lt;Integer, String&gt; mask = n -&gt; &quot;*&quot;.repeat(n);</span>

      Predicate&lt;Person&gt; junior = p -&gt; p.getAge() &lt; 21;
      pList.stream().filter(junior)<span class="color-new">.map(name)</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Paul</span></span>
      
      <span class="color-comment">// Belows are the equivalent</span>
      pList.stream().filter(junior)<span class="color-new">.map(name.andThen(length).andThen(mask))</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">****</span></span>
      pList.stream().filter(junior)<span class="color-new">.map(length.compose(name).andThen(mask))</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">****</span></span>
      pList.stream().filter(junior)<span class="color-new">.map(name).map(length).map(mask)</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">****</span></span>
      pList.stream().filter(junior)<span class="color-new">.map(p -&gt; &quot;*&quot;.repeat(p.getName().length()))</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">****</span></span>
   }
}</pre>


<h5><span class="font-code">BiFunction&lt;T,U,R&gt;: (t,u) -&gt; r</span></h5>

<pre class="color-example">
package java.util.function;
import java.util.Objects;<br>
@FunctionalInterface
public <span class="color-new">BiFunction&lt;T, U, R&gt;</span> {
   <span class="color-comment">// Applies this function to the given arguments.</span>
   R <span class="color-new">apply</span>(T t, U u);
    
   <span class="color-comment">// Returns a composed function that first applies this function to its inputs,
   //   and then applies the after function to the result.</span>
   default &lt;V&gt; BiFunction&lt;T, U, V&gt; <span class="color-new">andThen</span>(Function&lt;? super R, ? extends V&gt; after) {
      Objects.requireNonNull(after);
      return (T t, U u) -&gt; after.apply(this.apply(t, u));
   }
}</pre>

<p>[TODO] Example</p>


<h5><span class="font-code">Consumer&lt;T&gt;: t -&gt; void</span></h5>
<p><span class="line-heading font-code"></span>Accept a single input argument and return no result. Operate via side-effects.</p>
<pre class="color-example">
package java.util.function;
import java.util.Objects;<br>
@FunctionalInterface
public interface <span class="color-new">Consumer&lt;T&gt;</span> {
   <span class="color-comment">// Performs this operation on the given argument</span>
   void accept(T t);
<span class="color-comment">
   // Returns a composed Consumer that performs this operation followed by after operation.</span>
   default Consumer&lt;T&gt; <span class="color-new">andThen</span>(Function&lt;? super T&gt; after) {
      Objects.requireNonNull(after);
      return (T t) -&gt; this.accept(t); after.accept(t);
   }
}</pre>

<h5><span class="font-code">Supplier&lt;T&gt;: () -&gt; t</span></h5>
<p><span class="line-heading font-code"></span>Provide an instance <code>t</code>.</p>
<pre class="color-example">
package java.util.function;

@FunctionalInterface
public <span class="color-new">Supplier&lt;T&gt;</span> {
   T get();  <span class="color-comment">// Gets a result.</span>
}</pre>

<p>[TODO] Example</p>

<h5><span class="font-code">UnaryOperator&lt;T&gt;: t -&gt; t</span></h5>

<p><span class="line-heading font-code"></span>A <code>UnaryOperator&lt;T&gt;</code> is a special case of <code>Function&lt;T,T&gt;</code>, where the type of argument is the same as the return type.</p>
<pre class="color-example">
package java.util.function;

@FunctionalInterface
public <span class="color-new">UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt;</span> {
   <span class="color-comment">// Inherit apply(), default compose() and default andThen() from supertype Function</span>

   <span class="color-comment">// Provide its own identity(), as static method are NOT inherited.</span>
   static &lt;T&gt; UnaryOperator&lt;T&gt; <span class="color-new">identity</span>() { ...... }
}</pre>

<p>[TODO] Example</p>

<h5><span class="font-code">BinaryOperator&lt;T&gt;: (t,t) -&gt; t</span></h5>
<p><span class="line-heading font-code"></span>A <code>BinaryOperator&lt;T&gt;</code> is a special case of <code>BiFunction&lt;T,T,T&gt;</code>, where both inputs and return value have the same type.</p>
<pre class="color-example">
package java.util.function;

@FunctionalInterface
public <span class="color-new">BinaryOperator&lt;T&gt; extends BiFunction&lt;T, T, T&gt;</span> {
   <span class="color-comment">// Inherit apply() and default andThen() from supertype BiFunction</span>
   static &lt;T&gt; BinaryOperator&lt;T&gt; <span class="color-new">minBy</span>(Comparator&lt;? super T&gt; comparator);
   static &lt;T&gt; BinaryOperator&lt;T&gt; <span class="color-new">maxBy</span>(Comparator&lt;? super T&gt; comparator);
}</pre>

<p>[TODO] Example</p>


<h3 id="StreamAPI">Stream API (JDK 8)</h3>

<h4>Filter-Map-Reduce 4: Using Stream API for Filter-Map-Reduce</h4>

<p>JDK 8 introduces a new Stream API to support <em>filter-map-reduce</em> operations with great simplicity and efficiency. For example, we can simplify the above filter-map-reduce operations to a one-liner without an explicit for-loop.</p>

<h5><span class="font-code">ProcessPersonList4.java</span></h5>
<pre class="color-example">
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class <strong>ProcessPersonList4</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(  <span class="color-comment">// (JDK 9) create an unmodificable List</span>
            new Person(&quot;Peter&quot;, 21),
            new Person(&quot;John&quot;, 60),
            new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Using JDK 8 Stream API for filter-reduce(foreach)</span>
      pList<span class="color-new">.stream()
            .filter(p -&gt; p.getAge() &gt;= 21)  <span class="color-comment">// filter with Predicate</span>
            .forEach(Person::sayHello)</span>;     <span class="color-comment">// Using method reference</span>
      <span class="color-comment">//Same as:      
      //pList<span class="color-new">.stream().filter(p -&gt; p.getAge() &gt;= 21).forEach(p -&gt; p.sayHello())</span>;</span>
      <span class="color-comment">//</span><span class="color-output">Peter says hello</span><br>      <span class="color-comment">//</span><span class="color-output">John says hello</span>

      <span class="color-comment">// Using JDK 8 Stream API for filter-map-reduce(foreach)</span>
      <span class="color-comment">// Use map() to extract a specific property from the object</span>
      Predicate&lt;Person&gt; adult = p -&gt; p.getAge() &gt;= 21;
      pList.stream()
            .filter(adult)
            <span class="color-new">.map(Person::getName)  <span class="color-comment">// Person -&gt; String</span>
            </span>.forEach(System.out::println);
      <span class="color-comment">//</span><span class="color-output">Peter</span><br>      <span class="color-comment">//</span><span class="color-output">John</span>

      <span class="color-comment">// Using JDK 8 Stream API for filter-map-reduce(aggregate)</span>
      <span class="color-comment">// Apply aggregate operation average(), sum() to an int property extracted via mapToInt()</span>
      System.out.println(pList
            .stream()
            .filter(adult)
            <span class="color-new">.mapToInt(Person::getAge)   <span class="color-comment">// Person -&gt; int</span>
            .sum())</span>;  <span class="color-comment">//</span><span class="color-output">81</span>
      System.out.println(pList
            .stream()
            .filter(adult)
            <span class="color-new">.mapToInt(Person::getAge)   <span class="color-comment">// Person -&gt; int</span>
            .average().getAsDouble())</span>;  <span class="color-comment">//</span><span class="color-output">40.5</span>

      <span class="color-comment">// Using JDK 8 Stream API for filter-map-reduce(collect)
      // Increase the age by 1
</span>      List&lt;Person&gt; pListGrowUp = pList
            .stream()
            .map(<span class="color-new">p -&gt; new Person(p.getName(), p.getAge()+1)</span>)  <span class="color-comment">// Person -&gt; Person</span>
            .collect(Collectors.toList());  <span class="color-comment">// collect into a List</span>
      System.out.println(pListGrowUp);
      <span class="color-comment">//</span><span class="color-output">[Peter(22), John(61), Paul(16)]</span>
   }
}</pre>

<h5>How it Works</h5>
<ol>
<li>We begin with a <em>source</em> such as a <code>Collection</code> of objects. In this case, a <code>List</code> of <code>Person</code> objects or <code>List&lt;Person&gt;</code>.</li>
<li>We create a <code>Stream&lt;E&gt;</code> from a <code>Collection&lt;E&gt;</code> via <code>.stream()</code>.</li>
<li>We then apply <code>Stream</code>'s <em>intermediate operations</em> such as <code>.filter()</code>, <code>.map()</code>, which operates on each element of the <code>Stream</code> (without an explicit loop), to filter or transform the <code>Stream</code>.</li>
<li>We finally apply <code>Stream</code>'s <em>terminal operations</em> such as <code>forEach()</code>, <code>sum()</code>, <code>collect()</code> to produce the desired results.</li>
</ol>



<h4>Stream and Pipeline</h4>
<p>JDK 8 introduces Stream API to process collections of objects. A <code>Stream</code> is a sequence of elements that supports sequential and parallel aggregate operations (such as filter, map and reduce), which can be pipelined to produce the desired result.</p>
<p>A <em>pipeline</em> is a sequence of  operations on a <code>Collection</code>. The sequence composes:</p>
<ol>
<li>A <em>source</em>: a <code>Collection</code>, an array, a generator function, or I/O channel of objects, e.g., <code>pList</code> (which is a <code>List</code> of <code>Person</code> objects) in the above examples.</li>
<li><code>.stream()</code> or <code>.parallelStream()</code>: produce a <code>Stream</code>, which is a sequence of elements to be carried from the source into the pipeline.</li>
<li>Some (zero or more) <em>intermediate</em> operations: for example, <code>filter(Predicate)</code> and <code>map(Function)</code>.</li>
<li>A terminal operation: such as <code>forEach()</code>, which produces the desired result (a value or side-effect).</li>
</ol>

<h5><span class="font-code">Stream</span>s vs. <span class="font-code">Collection</span>s</h5>

<p><code>Stream</code>s differ from <code>Collection</code>s in several ways:</p>
<ul>
<li>No Storage: A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a <code>Collection</code>, an array, a generator function, or an I/O channel, through a pipeline of operations.</li>
<li>Functional-Programming Style and Immutable Source: A stream operation on a source produces a new stream. It does not modify its source. For example, the following stream filtering operation does not modified its source.
  <pre class="color-example">
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class <strong>StreamImmutableTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      List&lt;Person&gt; adultList = pList
            .stream()
            .filter(p -&gt; p.getAge() &gt;= 21)   <span class="color-comment">// filter with a Predicate</span>
            <span class="color-new">.collect(Collectors.toList())</span>;   <span class="color-comment">// collect into a List</span>
      System.out.println(adultList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60)]</span></span>

      <span class="color-comment">// The source is not modified, i.e., immutable source</span>
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>
   }
}</pre></li>

<li>Laziness: Streams are lazy because the intermediate operations, such as filtering and mapping, are not evaluated until the terminal operation is invoked. This exposes opportunities for optimization. For example, &quot;find the first string (<code>findFirst()</code> operation) with three consecutive vowels (intermediate filtering operation)&quot;, you need not filter all the source strings  when the terminal operation is invoked. Another example: a filter-map-sum pipeline can be fused into a single pass on the data, with minimal intermediate state.</li>
<li>Possibly Unbounded Source: While collections have a finite size, streams need not. Short-circuiting  operations such as <code>limit(n)</code>, <code>findFirst()</code> can allow computations on infinite streams.</li>
<li>Consumable: The elements of a stream are only visited ONCE during the life of a stream. A new stream must be generated to revisit the same element. See <code>StreamSupplier</code> below.</li>
<li>Stateless/Stateful intermediate operations: Intermediate operations are divided into stateless and stateful operations. Stateless operations, such as filter and map, retain no state from the previously seen element when processing a new element. Stateful operations, such as sorted and distinct, need to incorporate state from previously seen elements when processing a new element, and need to process the entire input before producing a result. Parallel pipeline with stateful operations may require multiple passes or may need to buffer significant data.</li>
<li>Short-circuiting operations: A short-circuit intermediate or terminal operation can produce a new finite stream or result in a finite time, given an infinite input. For example, [TODO]</li>
</ul>

<h4>Creating a <span class="font-code">Stream&lt;E&gt;</span></h4>

<p>A <code>Stream</code> can be obtained in a number of ways, depending on its <em>source</em>:</p>



<ol>
<li>From a <code>Collection&lt;E&gt;</code>: We can create a sequential <code>Stream&lt;E&gt;</code> via the new <code>default</code> method in the <code>Collection&lt;E&gt;</code> interface <code>.stream()</code>; or create a parallel <code>Stream</code> via method <code>.parallelStream()</code>, defined as follows:
  <pre class="color-syntax">
Package java.util;
interface <span class="color-new">Collection&lt;E&gt;</span> {
   default <span class="color-new">Stream&lt;E&gt; stream</span>()          <span class="color-comment">// Returns a sequential Stream with this Collection as its source</span>
   default <span class="color-new">Stream&lt;E&gt; parallelStream</span>()  <span class="color-comment">// Returns a possibly parallel Stream with this Collection as its source</span>
   ......
}</pre>
  This is the most commonly-used. See the above examples.</li>

<li>From an <code>Object</code> Array: via <code>static</code> method <code>Arrays.stream(Object[])</code>. For example,
  <pre class="color-example">
import java.util.Arrays;
public class <strong>ArrayToStreamTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Create an array of Person objects</span>
      <span class="color-new">Person[] personArray = {new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15)};</span>
      System.out.println(Arrays.toString(personArray));  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-new">Arrays.stream(personArray)</span>
            .filter(p -&gt; p.getAge() &gt;= 21)
            .forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>
      <span class="color-comment">//<span class="color-output">John(60)</span></span>
   }
}</pre></li>

<li>From <code>static</code> factory method of the <code>Stream</code> class, such as <code>Stream.of(Object[])</code>, <code>Stream.of(Object...)</code>, <code>IntStream.range(int, int)</code>, or <code>Stream.iterate(Object, UnaryOperator)</code>. For example,
  <pre class="color-example">
import java.util.stream.Stream;
import java.util.Arrays;

public class <span class="color-new">StreamOfTest</span> {
   public static void main(String[] args) {
      <span class="color-new">Stream&lt;Person&gt; pStream = Stream.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));</span>
      System.out.println(pStream);  <span class="color-comment">//<span class="color-output">java.util.stream.ReferencePipeline$Head@5ca881b5</span></span>

      String[] adultNames = pStream
            .filter(p -&gt; p.getAge() &gt;= 21)   <span class="color-comment">// filter with a Predicate</span>
            .map(Person::getName)            <span class="color-comment">// Person -&gt; String</span>
            .toArray(String[]::new);         <span class="color-comment">// collect names into an array</span>
      System.out.println(Arrays.toString(adultNames));  <span class="color-comment">//</span><span class="color-output">[Peter, John]</span>

      <span class="color-comment">// A Stream can only be traversed once</span>
      pStream.forEach(System.out::println);
      <span class="color-comment">//<span class="color-error">runtime java.lang.IllegalStateException: stream has already been operated upon or closed</span></span>
   }
}</pre></li>

<li>The lines of a file via <code>BufferedReader.lines()</code>. [TODO] Example.</li>

<li>Streams of file paths via methods in <code>Files</code>. [TODO] Example.</li>

<li>Streams of random number via <code>Random.ints()</code>. [TODO] Example.</li>
</ol>

<h5>Creating a Parallel Stream</h5>
<p>The Stream API supports parallel (concurrent) processing. We can create a parallel stream via:</p>
<ol>
<li>From  a <code>Collection&lt;E&gt;</code>: use <code>.parallelStream()</code> instead of <code>.stream()</code>. For example,
<pre class="color-example">
import java.util.List;
public class <strong>CollectionParallelStreamTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Create a parallel stream from a Collection</span>
      pList.<span class="color-new">parallelStream()</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">John(60)</span></span>
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>
   }
}</pre></li>

<li>From a sequential <code>Stream</code>: we can parallelize a serial stream via <code>.parallel()</code> (in the class <code>BaseStream</code>). For example,
  <pre class="color-example">
import java.util.List;
public class <strong>BaseStreamParallelTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      <span class="color-comment">// Create a serial stream</span>
      pList<span class="color-new">.stream()</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>
      <span class="color-comment">//<span class="color-output">John(60)</span></span>
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>

      <span class="color-comment">// Parallel a serial stream</span>
      pList<span class="color-new">.stream().parallel()</span>.forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">John(60)</span></span>
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>
   }
}</pre>
Another example,
<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Stream;

public class <strong>SequentialParallelStreamTest</strong> {
   public static void main(String[] args) {
      List&lt;Integer&gt; lst = new ArrayList&lt;&gt;();<span class="color-comment"></span>
      for (int i = 1; i &lt;= 100; ++i) lst.add(i);  <span class="color-comment">// 1 to 100</span>
      System.out.println(lst);

      Stream&lt;Integer&gt; sequentialStream = lst.<span class="color-new">stream()</span>;
      Stream&lt;Integer&gt; parallelStream   = lst.<span class="color-new">parallelStream()</span>;

      sequentialStream
         .filter(i -&gt; (i % 10) == 0)
         .forEach(i -&gt; System.out.println(&quot;sequential: &quot; + i)); <span class="color-comment">// outputs sequential</span>

      parallelStream
         .filter(i -&gt; (i % 10) == 0)
         .forEach(i -&gt; System.out.println(&quot;parallel: &quot; + i)); <span class="color-comment">// outputs non-sequential</span>
   }
}</pre></li>
</ol>

<h4>Intermediate Operations</h4>

<p>An <em>intermediate operation</em> operates on the given <code>Stream</code> and produces a new <code>Stream</code>. They include:</p>

<table class="table-zebra" style="width:100%">
<tr>
  <th>Intermediate Op</th>
  <th>Full Syntax</th>
  <th>Meaning</th>
</tr>
<tr>
  <td class="font-code">filter(p)</td>
  <td class="font-code">Stream&lt;T&gt;    filter​(Predicate&lt;Ts&gt; predicate)</td>
  <td>Returns a <code>Stream</code> of  elements that match the given <code>Predicate</code>.</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">map(f)</td>
  <td class="font-code">&lt;R&gt; Stream&lt;R&gt;  map​(Function&lt;Ts, ​Re&gt; mapper)</td>
  <td>Returns a <code>Stream</code> of the results of applying the given <code>Function</code> to the elements.</td>
</tr>
<tr>
  <td class="font-code">mapToInt(f)<br /></td>
  <td class="font-code">IntStream mapToInt(ToIntFunction&lt;Ts&gt; mapper)</td>
  <td>Primitive type <code>int</code> specializations of <code>map()</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">mapToLong(f)</td>
  <td class="font-code">LongStream mapToLong(ToLongFunction&lt;Ts&gt; mapper)</td>
  <td>Primitive type <code>long</code> specializations of <code>map()</code></td>
</tr>
<tr>
  <td class="font-code">mapToDouble(f)</td>
  <td class="font-code">DoubleStream mapToDouble(ToDoubleFunction&lt;Ts&gt; mapper)</td>
  <td>Primitive type <code>double</code> specializations of <code>map()</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">sorted()</td>
  <td class="font-code">Stream&lt;T&gt; sorted()</td>
  <td>Returns a  <code>Stream</code> sorted by natural order</td>
</tr>
<tr>
  <td class="font-code">sorted(comp)</td>
  <td class="font-code">Stream&lt;T&gt; sorted(Comparator&lt;Ts&gt; comparator)</td>
  <td>Returns a  <code>Stream</code> sorted according to the <code>Comparator</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">distinct()</td>
  <td class="font-code">Stream&lt;T&gt; distinct()</td>
  <td>Returns a <code>Stream</code> of distinct elements</td>
</tr>
<tr>
  <td class="font-code">Limit(maxSize)</td>
  <td class="font-code">Stream&lt;T&gt; limit(long maxSize)</td>
  <td>Returns a <code>Stream</code> of no more than <code>maxSize</code> elements</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">skip(n)</td>
  <td class="font-code">Stream&lt;T&gt; skip(long n)</td>
  <td>Skip the first <code>n</code> elements</td>
</tr>
</table>

<p>Notes: <code>Ts</code> denotes <code>&lt;? super T&gt;</code>, <code>Re</code> denotes <code>&lt;? extends R&gt;</code></p>

<p>For example,</p>

<pre class="color-example">
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class <strong>StreamIntermediateOpTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//[Peter(21), John(60), Paul(15)]</span>

      <span class="color-comment">// Test filter() and map()</span>
      pList.stream()
            <span class="color-new">.filter(p -&gt; p.getAge() &gt;= 21)</span>  <span class="color-comment">// filter with predicate</span>
            <span class="color-new">.map(Person::getName)</span>           <span class="color-comment">// map Person -&gt; String</span>
            .forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter</span></span>
      <span class="color-comment">//<span class="color-output">John</span></span>

      <span class="color-comment">// Test sorted(comparator)</span>
      pList.stream()
            <span class="color-new">.sorted((p1, p2) -&gt; p1.getName().compareToIgnoreCase(p2.getName()))</span>  <span class="color-comment">// by names, case insensitive</span>
            .forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">John(60)</span></span>
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>

      <span class="color-comment">// Test limit(maxSize)</span>
      pList.stream()
            <span class="color-new">.limit(2)</span>
            .forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>
      <span class="color-comment">//<span class="color-output">John(60)</span></span>

      <span class="color-comment">// Test skip(n)</span>
      pList.stream()
            <span class="color-new">.skip(2)</span>
            .forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Paul(15)</span></span>
   }
}</pre>

<h4>Terminal Operations</h4>
<p>A terminal operation produces a value, an <code>Optional</code> (with a value or nothing), or side-effect, which includes:</p>


<table class="table-zebra" style="width:100%">
<tr>
  <th>Terminal Op</th>
  <th>Full Syntax</th>
  <th>Meaning</th>
</tr>
<tr>
  <td class="font-code">forEach(consumer)</td>
  <td class="font-code">void forEach​(Consumer&lt;Ts&gt; action)</td>
  <td>Performs action on each of the elements</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">peek(consumer)</td>
  <td class="font-code">Stream&lt;T&gt; peek(Consumer&lt;Ts&gt; action)</td>
  <td>Same as <code>forEach()</code> but returns the Stream</td>
</tr>
<tr>
  <td rowspan="3" class="font-code">reduce()</td>
  <td class="font-code">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</td>
  <td>&nbsp;</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="font-code">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, Ts, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</td>
  <td>&nbsp;</td>
</tr>
<tr class="tr-alt">
  <td rowspan="2" class="font-code">collect()</td>
  <td class="font-code">&lt;R,A&gt; R collect(Collector&lt;Ts, A, R&gt; collector)</td>
  <td>Performs a mutable reduction on the elements using a <code>Collector</code>.</td>
</tr>
<tr>
  <td class="font-code">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, Ts&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</td>
  <td>&nbsp;</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">max()<br>
    min()<br>
    count()</td>
  <td class="font-code">Optional&lt;T&gt; max(Comparator&lt;Ts&gt; comparator)<br>
    Optional&lt;T&gt; min(Comparator&lt;Ts&gt; comparator)
    <br>
    long count()</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="font-code">findAny()<br>
    findFirst()</td>
  <td class="font-code">Optional&lt;T&gt; findAny()<br>
    Optional&lt;T&gt; findFirst()</td>
  <td>Any element<br>
    First element</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">allMatch(pred)<br>
    anyMatch(pred)<br>
    noneMatch(pred)</td>
  <td class="font-code">boolean allMatch(Predicate&lt;Ts&gt; predicate)<br>
    boolean anyMatch(Predicate&lt;Ts&gt; predicate)<br>
    boolean noneMatch(Predicate&lt;Ts&gt; predicate)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td rowspan="2" class="font-code">toArray()</td>
  <td class="font-code">Object[] toArray()</td>
  <td>&nbsp;</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</td>
  <td>&nbsp;</td>
</tr>
</table>

<p>A <em>reduction operation</em> (aka a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum, or accumulating (collecting) elements into a list. The stream classes have some general reduction operations, called <code>reduce()</code> and <code>collect()</code>, as well as many specialized reduction operations, such as <code>max()</code> and <code>count()</code>.</p>


<p>[TODO] Examples</p>

<h4>New Class <span class="font-code">java.util.Optional</span> (JDK 8)</h4>

<p>JDK 8 introduces a new container class <code>java.util.Optional&lt;T&gt;</code> as a container which may contain a value or nothing. It is primarily intended for use as a method return-type, where the method may return a non-null value or nothing. Instead of returning <code>null</code>, which may trigger <code>NullPointerException</code>, you can return an <code>Optional.empty()</code>.</p>
<p>See &quot;<a href="J5c_CollectionPart2.html#OptionalClass">New Class <span class="font-code">java.util.Optional&lt;T&gt;</span> (JDK 8)</a>&quot; for more details.</p>


<h4>Reduction Operations via <span class="font-code">reduce()</span></h4>

<p>The <code>Stream.reduce()</code> method has these forms:</p>
<pre class="color-syntax">
T <span class="color-new">reduce</span>(T identity,
         BinaryOperator&lt;T&gt; accumulator)
   <span class="color-comment">// Performs a reduction on the elements of this stream, using the provided identity value 
   //   and an associative accumulation function, and returns the reduced value</span>

Optional&lt;T&gt; <span class="color-new">reduce</span>(BinaryOperator&lt;T&gt; accumulator)
   <span class="color-comment">// Similar to above, with identity=null. Returns an Optional as the results could be null.</span>

&lt;U&gt; U <span class="color-new">reduce</span>(U identity,
             BiFunction&lt;U, ? super T, U&gt; accumulator,
             BinaryOperator&lt;U&gt; combiner)
   <span class="color-comment">// Performs a reduction on the elements of this stream, using the provide identity,
   //   accumulation and combining functions.</span></pre>

<h5>Example on <span class="font-code">reduce()</span></h5>

<pre class="color-example">
import java.util.List;
public class <strong>StreamReductionTest</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>

      int sumAge;
      sumAge = pList.stream()<span class="color-new">.map(Person::getAge).reduce(0, (x, y) -&gt; x+y)</span>;  <span class="color-comment">// identify, accumulator</span>
      System.out.println(sumAge);   <span class="color-comment">//<span class="color-output">96</span></span>
      sumAge = pList.stream()<span class="color-new">.map(Person::getAge).reduce(0, Integer::sum)</span>;   <span class="color-comment">// identify, accumulator</span>
      System.out.println(sumAge);   <span class="color-comment">//<span class="color-output">96</span></span>
      sumAge = pList.stream()<span class="color-new">.reduce(0, (sum, p) -&gt; sum + p.getAge(), Integer::sum)</span>;  <span class="color-comment">// identify, accumulator, combiner</span>
      System.out.println(sumAge);   <span class="color-comment">//<span class="color-output">96</span></span>
      sumAge = pList.stream()<span class="color-new">.mapToInt(Person::getAge).sum()</span>;  <span class="color-comment">// same as above</span>
      System.out.println(sumAge);   <span class="color-comment">//<span class="color-output">96</span></span>
      sumAge = pList.stream()<span class="color-new">.mapToInt(Person::getAge).reduce(0, Integer::sum)</span>;  <span class="color-comment">// same as above</span>
      System.out.println(sumAge);   <span class="color-comment">//<span class="color-output">96</span></span>


      List&lt;String&gt; fruits = List.of(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;);
      String concatenated = fruits.stream()<span class="color-new">.reduce(&quot;&quot;, String::concat)</span>;
      System.out.println(concatenated);  <span class="color-comment">//<span class="color-output">appleorangebanana</span></span>
      int totalLen;<br>      totalLen = fruits.stream()<span class="color-new">.map(String::length).reduce(0, Integer::sum)</span>;
      System.out.println(totalLen);  <span class="color-comment">//<span class="color-output">17</span></span>
      totalLen = fruits.stream()<span class="color-new">.reduce(0, (sum, s) -&gt; sum + s.length(), Integer::sum)</span>;
      System.out.println(totalLen);  <span class="color-comment">//<span class="color-output">17</span></span>
      totalLen = fruits.stream()<span class="color-new">.mapToInt(String::length).sum()</span>;  <span class="color-comment">// same as above</span>
      System.out.println(totalLen);  <span class="color-comment">//<span class="color-output">17</span></span>
   }
}</pre>

<h4>Mutable Reduction via <span class="font-code">collect()</span></h4>

<p>Instead of the <code>reduce()</code>, we could use <code>collect()</code> which accumulates into a mutable container such as a <code>Collection</code>. The <code>Stream.collect()</code> has these forms:</p>

<pre class="color-syntax">
&lt;R&gt; R <span class="color-new">collect</span>(Collector&lt;? super T, A, R&gt; collector)
   <span class="color-comment">// Performs a mutable reduction operation on the elements of this stream
   //  using a Collector</span>

&lt;R&gt; R <span class="color-new">collect</span>(Supplier&lt;R&gt; supplier,
              BiConsumer&lt;R, ? super T&gt; accumulator,
              BiConsumer&lt;R, R&gt; combiner)
   <span class="color-comment">// Performs a mutable reduction operation on the elements of this stream</span></pre>
   
<p>Example: See the next section</p>


<h4>Filter-Map-Reduce 5: Using the Collectors: <span class="font-code">java.util.stream.Collectors</span> Utility Class and <span class="font-code">java.util.stream.Collector</span> interface</h4>

<p>The utility class <code>Collectors</code> provides many useful <code>static</code> <em>mutable reduction</em> operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc, which returns a <code>Collector</code>.</p>
<p>For example,</p>

<pre class="color-example">
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class <strong>ProcessPersonListStreamCollector</strong> {
   public static void main(String[] args) {
      List&lt;Person&gt; pList = List.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pList);  <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span></span>
      Predicate&lt;Person&gt; adult = p -&gt; p.getAge() &gt;= 21;

      <span class="color-comment">// Collect (Accumulate) names into a List&lt;String&gt;</span>
      List&lt;String&gt; nameList = pList
            .stream()
            .filter(adult)
            .map(Person::getName)
            <span class="color-new">.collect(Collectors.toList())</span>;  <span class="color-comment">// collect into a List</span>
      System.out.println(nameList);   <span class="color-comment">//<span class="color-output">[Peter, John]</span></span>

      <span class="color-comment">// Collect into a Map&lt;String, Integer&gt; of name-age pairs</span>
      Map&lt;String, Integer&gt; personMap = pList
            .stream()
            .filter(adult)
            <span class="color-new">.collect(Collectors.toMap(Person::getName, Person::getAge))</span>;  <span class="color-comment">// collect into a map of key-value pairs</span>
      System.out.println(personMap);   <span class="color-comment">//<span class="color-output">{Peter=21, John=60}</span></span>

      <span class="color-comment">// Collect names into a TreeSet&lt;String&gt;</span>
      Set&lt;String&gt; nameSet = pList
            .stream()
            .filter(adult)
            .map(Person::getName)
            <span class="color-new">.collect(Collectors.toCollection(TreeSet::new))</span>;  <span class="color-comment">// or Collectors.toSet()</span>
      System.out.println(nameSet);   <span class="color-comment">//<span class="color-output">[John, Peter]</span></span>

      <span class="color-comment">// Collect names into an String[] array</span>
      <span class="color-comment">// Does not need .collect(), as array is fixed in size.</span>
      String[] nameArray = pList
            .stream()
            .filter(adult)
            .map(Person::getName)
            <span class="color-new">.toArray(String[]::new)</span>;  <span class="color-comment">// collect into a String array</span>
      System.out.println(Arrays.toString(nameArray));   <span class="color-comment">//<span class="color-output">[Peter, John]</span></span>

      <span class="color-comment">// Convert elements to Strings, join them separated by semicolon</span>
      String personStr = pList
            .stream()
            .map(Object::toString)
            <span class="color-new">.collect(Collectors.joining(&quot;; &quot;))</span>;  <span class="color-comment">// join string</span>
      System.out.println(personStr);   <span class="color-comment">//<span class="color-output">Peter(21); John(60); Paul(15)</span></span>

      <span class="color-comment">// Compute the sum of age</span>
      int sum = pList
            .stream()
            <span class="color-new">.collect(Collectors.summingInt(Person::getAge))</span>;
      System.out.println(sum);  <span class="color-comment">//<span class="color-output">96</span></span>
      <span class="color-comment">// Other similar methods are: summingDouble(), summingLong(),</span>
      <span class="color-comment">//   averagingInt(), averagingDouble(), averagingLong(),</span>
      <span class="color-comment">//   maxBy(Comparator), minBy(Comparator)</span>
      <span class="color-comment">// same as:</span>
      System.out.println(pList.stream().mapToInt(Person::getAge).sum());  <span class="color-comment">//<span class="color-output">96</span></span>

      <span class="color-comment">// Partition elements into a Map of adult and non-adult</span>
      Map&lt;Boolean, List&lt;Person&gt;&gt; adultMap = pList
            .stream()
            <span class="color-new">.collect(Collectors.partitioningBy(adult))</span>;
      System.out.println(adultMap);
      <span class="color-comment">//<span class="color-output">{false=[Paul(15)], true=[Peter(21), John(60)]}</span></span>

      <span class="color-comment">// Group int a Map by the initials of names</span>
      Map&lt;Character, List&lt;Person&gt;&gt; byInitialMap = pList
            .stream()
            <span class="color-new">.collect(Collectors.groupingBy(p -&gt;p.getName().charAt(0)))</span>;
      System.out.println(byInitialMap);
      <span class="color-comment">//<span class="color-output">{P=[Peter(21), Paul(15)], J=[John(60)]}</span></span>
   }
}</pre>

<h5>Utility Class <span class="font-code">java.util.stream.Collectors</span></h5>

<p>The utility class <code>java.util.stream.Collectors</code> provides many <code>static</code> methods:</p>
<table class="table-zebra" style="width:100%">
<tr>
  <th>Operation</th>
  <th>Full Syntax</th>
  <th>Meaning</th>
</tr>
<tr>
  <td class="font-code">toList()</td>
  <td class="font-code">&lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; toList()</td>
  <td>Collects into a new <code>List</code></td>
</tr>
<tr class="tr-alt">
  <td class="font-code">toSet()</td>
  <td class="font-code">&lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; toList()</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="font-code">toMap()</td>
  <td class="font-code">&lt;T,K,V&gt; Collector&lt;T,?,Map&lt;K,V&gt;&gt; toMap(Function&lt;Ts,Ke&gt; keyMapper, Function&lt;Ts,Ve&gt; valueMapper)</td>
  <td>&nbsp;</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">toCollection()</td>
  <td class="font-code">&lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T,?,C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="font-code"><p>toUnmodifiableList()<br>
    toUnmodifiableSet()<br>
    toUnmodifiableMap()
  </p></td>
  <td class="font-code">&nbsp;</td>
  <td>Similar to the above</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">[TODO] more</td>
  <td class="font-code">&nbsp;</td>
  <td>&nbsp;</td>
</tr>
</table>

<h5>Interface <span class="font-code">java.util.stream.Collector&lt;T,A,R&gt;</span></h5>
<p>The type parameters are:</p>
<ul>
<li><code>T</code>: the type of input elements to the reduction operation</li>
<li><code>A</code>: the mutable accumulator type</li>
<li><code>R</code>: the result type</li>
</ul>

<p>A <code>Collector</code> is specified by <em>four functions</em> that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result.</p>
<ol>
<li>Creation of a new result container (<code>supplier()</code>)</li>
<li>Incorporating a new data element into a result container (<code>accumulator()</code>)</li>
<li>Combining two result containers into one (<code>combiner()</code>)</li>
<li>Performing an optional final transform on the container (<code>finisher()</code>)</li>
</ol>

<p>Read JDK API documentation of &quot;<a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Collector.html">Interface <code>Collector&lt;T,A,R&gt;</code></a>&quot;.</p>

<h4>Primitive Specialized Streams: <span class="font-code">IntStream</span>, <span class="font-code">LongStream</span> and <span class="font-code">DoubleStream</span></h4>

<p>For greater efficiency, specialized streams for primitive types <code>int</code>, <code>long</code> and <code>double</code> are created.</p>

<h5>Creating a Specialized <span class="font-code">XxxStream</span></h5>

<ol>
<li>From a <code>Stream</code> with <code>mapToXxx()</code>:
<pre class="color-syntax">
<span class="color-comment">// java.util.stream.<span class="color-new">Stream&lt;T&gt;</span></span>
IntStream <span class="color-new">mapToInt</span>(ToIntFunction&lt;? super T&gt;)
LongStream <span class="color-new">mapToLong</span>(ToLongFunction&lt;? super T&gt;)
DoubleStream <span class="color-new">mapToDouble</span>(ToDoubleFunction&lt;? super T&gt;)
</pre>
</li>
<li>Via one of the <code>static</code> methods of <code>IntStream</code> (or <code>LongStream</code> or <code>DoubleStream</code>):
<pre class="color-syntax">
<span class="color-comment">// Interface java.util.stream.<span class="color-new">IntStream</span></span>
static IntStream <span class="color-new">of</span>(int... values)
static IntStream <span class="color-new">range</span>(int startInclusive, int endExclusive)
static IntStream <span class="color-new">rangeClosed</span>(int startInclusive, int endInclusive)
static IntStream <span class="color-new">generate</span>(IntSupplier s)   <span class="color-comment">// infinite sequence</span>
static IntStream <span class="color-new">iterate</span>(int seed, IntUnaryOperator f)   <span class="color-comment">// f(seed), f(f(seed)), ... infinite sequence</span>
static IntStream <span class="color-new">iterate</span>(int seed, IntPredicate hasNext, IntUnaryOperator next)
static IntStream <span class="color-new">empty</span>()   <span class="color-comment">// empty IntStream</span></pre>
</li>
</ol>
<p>[TODO] Example</p>

<h5>Intermediate Operations</h5>

<p>Most of the intermediate operations for <code>Stream&lt;T&gt;</code> are also defined for <code>IntStream</code>, but tailored to work on <code>int</code>. For example,</p>
<pre class="color-syntax">
IntStream <span class="color-new">filter</span>(IntPredicate predicate)
IntStream <span class="color-new">map</span>(IntUnaryOperator mapper)
LongStream <span class="color-new">mapToLong</span>(IntToLongFunction mapper)
DoubleStream <span class="color-new">mapToDouble</span>(IntToDoubleFunction mapper)
&lt;U&gt; Stream&lt;U&gt; <span class="color-new">mapToObj</span>(IntFunction&lt;? extends U&gt; mapper)
IntStream <span class="color-new">sorted</span>()
IntStream <span class="color-new">distinct</span>()
IntStream <span class="color-new">limit</span>(long maxSize)
IntStream <span class="color-new">skip</span>(long n)
</pre>

<p>Similar operations are defined for <code>LongStream</code> and <code>DoubleStream</code>.</p>
<p>[TODO] Example</p>

<h5>Terminal Operations</h5>

<p>The following terminal operations are added to <code>IntStream/LongStream/DoubleStream</code>. For <code>Stream&lt;T&gt;</code>, arithmetic may not be applicable to <code>T</code>.</p>
<table class="table-zebra" style="width:100%">
<tr>
  <th>Terminal Op</th>
  <th>Full Syntax</th>
  <th>Meaning</th>
</tr>
<tr>
  <td class="font-code">sum()</td>
  <td class="font-code">int|long|double sum()</td>
  <td>accumulate the sum in the respective primitive type</td>
</tr>
<tr class="tr-alt">
  <td class="font-code">average()</td>
  <td class="font-code">OptionalDouble average()</td>
  <td>returns the average in <code>OptionalDouble</code>, or empty for empty stream</td>
</tr>
</table>


<p>Most of the terminal operations for <code>Stream&lt;T&gt;</code> are also available for <code>IntStream</code>, but tailored to work on <code>int</code>. For example,</p>
<pre class="color-syntax">
void <span class="color-new">forEach</span>(IntConsumer action)
IntStream <span class="color-new">peek</span>(IntConsumer action)
int <span class="color-new">reduce</span>(int identity, IntBinaryOperator op)
OptionalInt <span class="color-new">reduce</span>(IntBinaryOperator op)
&lt;R&gt; R <span class="color-new">collect</span>(Supplier&lt;R&gt; supplier, ObjIntConsumer&lt;R&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)
OptionalInt <span class="color-new">max</span>()
OptionalInt <span class="color-new">min</span>()
long <span class="color-new">count</span>()
OptionalInt <span class="color-new">findAny</span>()
OptionalInt <span class="color-new">findFirst</span>()
boolean <span class="color-new">allMatch</span>(IntPredicate predicate)
boolean <span class="color-new">anyMatch</span>(IntPredicate predicate)
boolean <span class="color-new">noneMatch</span>(IntPredicate predicate)
int[] <span class="color-new">toArray</span>()</pre>

<p>[TODO] Example</p>



<h4>Filter-Map-Reduce 6: Using <span class="font-code">Stream</span> and <span class="font-code">StreamSupplier</span></h4>

<pre class="color-example">
import java.util.List;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.util.function.Predicate;

public class <strong>StreamSupplierTest1</strong> {
   public static void main(String[] args) {
      <span class="color-new">Stream&lt;Person&gt;</span> pStream = Stream.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      System.out.println(pStream);
      <span class="color-comment">//<span class="color-output">[Peter(21), John(60), Paul(15)]</span>
</span>
      Predicate&lt;Person&gt; adult = p -&gt; p.getAge() &gt;= 21;
      pStream.filter(adult).map(Person::getName).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter</span></span>
      <span class="color-comment">//<span class="color-output">John</span></span>

      <span class="color-comment">// Collect as List</span>
      <span class="color-comment">//List&lt;Person&gt; adultList =</span>
      <span class="color-comment">//      pStream.filter(adult).collect(Collectors.toList());</span>
      <span class="color-comment">//<span class="color-error">java.lang.IllegalStateException:</span></span>
      <span class="color-comment">//<span class="color-error">stream has already been operated upon or closed</span></span>
   }
}</pre>

<p>A <code>Stream</code> can only be used once. You need to construct a <code>StreamSupplier</code> to supply <code>Stream</code>s, as follows:</p>

<pre class="color-example">
import java.util.List;
import java.util.stream.Stream;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.function.Predicate;
import java.util.Arrays;

public class <strong>StreamSupplierTest2</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Create a Stream Supplier</span>
      <span class="color-new">Supplier&lt;Stream&lt;Person&gt;&gt;</span> streamSupplier =
            () -&gt; Stream.of(new Person(&quot;Peter&quot;, 21), new Person(&quot;John&quot;, 60), new Person(&quot;Paul&quot;, 15));
      Predicate&lt;Person&gt; adult = p -&gt; p.getAge() &gt;= 21;

      <span class="color-comment">// Get a new stream</span>
      <span class="color-new">Stream&lt;Person&gt;</span> pStream1 = <span class="color-new">streamSupplier.get()</span>;
      pStream1.filter(adult).forEach(System.out::println);
      <span class="color-comment">//<span class="color-output">Peter(21)</span></span>
      <span class="color-comment">//<span class="color-output">John(60)</span></span>

      <span class="color-comment">// Collect the results as List</span>
      <span class="color-new">List&lt;Person&gt;</span> adultList =
            <span class="color-new">streamSupplier.get()</span>.filter(adult).collect(Collectors.toList());
      System.out.println(adultList);
      <span class="color-comment">//<span class="color-output">[Peter(21), John(60)]</span></span>

      <span class="color-comment">// Collect as array</span>
      <span class="color-new">String[]</span> adults =
            <span class="color-new">streamSupplier.get()</span>.filter(adult).map(Person::getName).toArray(String[]::new);
      System.out.println(Arrays.toString(adults));
      <span class="color-comment">//<span class="color-output">[Peter, John]</span></span>
   }
}</pre>


<h4>Package <span class="font-code">java.util.stream</span> (JDK 8)</h4>

<p>JDK 8 added a new <code>java.util.stream</code> package to support Stream API. It contains the following interfaces:</p>

<ul>
<li><code>BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt;</code>: the base interface</li>
<li><code>Stream&lt;T&gt;</code>: A sequence of elements supporting sequential and parallel aggregate operations.</li>
<li><code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>: Primitive types specialization of <code>Stream&lt;T&gt;</code>.</li>
<li>Stream.Builder&lt;T&gt;, <code>IntStream.Builder</code>, <code>LongStream.Builder</code>, <code>DoubleStream.Builder</code>: Mutable builder for streams.</li>
<li><code>Collector&lt;T,A,R&gt;</code> and utility class <code>Collectors</code>.</li>
</ul>

<p>[TODO] more</p>

<h4>More on Lambda Expression and Functional Programming</h4>
<p>Java is an OOP language where functions are defined inside  objects. Java does not support passing of function as a function's argument and returning a function.  You need to pass objects arguments into function.</p>
<p>On the other hand, functional programming are based on functions and passing of functions. Lambda Expression lets you visualize functional programming in the Java object-oriented world, by wrapping a function in a Functional Interface (Object).</p>
<p>The benefits of Lambda expression are:</p>
<ol>
<li>Reduced lines of codes.</li>
<li>Support parallel execution.</li>
<li>Passing of behavior (in Functional Interface instance) as function's argument.</li>
</ol>

<h4><span class="font-code">Map&lt;K,V&gt;</span> to <span class="font-code">Stream</span></h4>

<p>Suppose the source is a  <code>Map(K, V)</code> of key-value pairs.</p>
<p>The following example shows how to increase the pay of all employees by 10%, given the data in key-value of <code>{name=pay}</code>.</p>

<pre class="color-example">
import java.util.Map;
import java.util.stream.Collectors;

public class <strong>RaiseSalaryTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Data are kept in simple structure</span>
      Map&lt;String, Double&gt; workers = Map.of(&quot;Peter&quot;, 1000.0, &quot;Paul&quot;, 2000.0);  <span class="color-comment">// name and salary pairs</span>
      System.out.println(workers);
      <span class="color-comment">//<span class="color-output">{Paul=2000.0, Peter=1000.0}</span></span>

      <span class="color-comment">// Keep source immutable</span>
      Map&lt;String, Double&gt; happierWorkers = workers
         .entrySet()   <span class="color-comment">// Returns a Set view Set&lt;Map.Entry&lt;K,V&gt;&gt; of this map</span>
         .stream()
         .collect(Collectors.toMap(Map.Entry::getKey, w -&gt; w.getValue()*1.1));
      System.out.println(happierWorkers);
      <span class="color-comment">//<span class="color-output">{Peter=1100.0, Paul=2200.0}</span></span>
   }
}</pre>

<p>[TODO] More example</p>




<!-- @@ start change in v1 -->
<a class="references" href="../howto/References.html#java">REFERENCES &amp; RESOURCES</a>


</div> 
<!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 13.0.1<br>
Last modified: February, 2020</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
