<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- for responsive web design -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- for SEO -->
<meta name="description" content="Java Tutorial for the beginners">
<meta name="keywords" content="Java, Tutorial, Basics, beginners">
<title>Java Basics - Java Programming Tutorial</title>

<!-- @@ v3 header changes starts here after <title> -->
<!-- My custom CSS v3 -->
<link rel="stylesheet" href="../css/programming_notes_v3.css">
<!-- Prism Syntax Highlighter -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css" rel="stylesheet" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.css" rel="stylesheet" />
<!-- favicon -->
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
</head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>Table of Contents <a id="show-toc" href="J2_Basics.html#show-toc">(Hide)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<!-- @@ v3 header changes ends here before "content-header" <h1> and <h2>"" -->

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Java Basics</h2>
</div>

<div id="content-main">

<p>This chapter explains the basic syntaxes of the Java programming language. I shall assume that you have written some simple Java programs. Otherwise, read &quot;<a href="J1a_Introduction.html">Introduction To Java Programming for First-time Programmers</a>&quot;.</p>

<p>To be proficient in a programming language, you need to master two things:</p>
<ol>
<li>The <em>syntax</em> of the programming language: Not too difficult to learn a small  set of keywords and syntaxes. 
For examples, JDK  1.8 has 48 keywords; C11 has 44, and C++11 has 73.</li>
<li>The <em>Application Program Interface</em> (API) libraries associated with the language: You don&rsquo;t want to write everything from scratch yourself. Instead, you can re-use the available code in the library. Learning library could be difficult as it is really huge, evolving and could take on its own life as another programming language.</li>
</ol>


<p>The first few sections are a bit boring, as I have to explain the basic concepts with some details.</p>
<p>You may also try the &quot;<a href="J2a_BasicsExercises.html">Exercises on Java Basics</a>&quot;.</p>


<h3>Basic Syntaxes</h3>

<h4>Steps in Writing a Java Program</h4>

<p>The steps in writing a Java program is illustrated as follows:</p>

<img src="images/programming_steps.gif" alt="JavaBasics_Process.png" width="424" height="270" class="image-left" />

<p><span class="lead">Step 1:</span> Write the source code <code>Xxx.java</code> using a programming text editor (such as Sublime Text, Atom, Notepad++, Textpad, gEdit) or an <acronym title="Integrated Development Environment">IDE</acronym> (such as Eclipse or NetBeans).</p>

<p><span class="lead">Step 2:</span> Compile the source code <code>Xxx.java</code> into Java portable bytecode <code>Xxx.class</code> using the JDK Compiler by issuing command:</p>
<pre class="command">
javac Xxx.java
</pre>

<p><span class="lead">Step 3:</span> Run the compiled bytecode <code>Xxx.class</code> with the input to produce the desired output, using the Java Runtime by issuing command:</p>
<pre class="command">
java Xxx
</pre>

<h4>Java Program Template</h4>
<p>You can use the following <em>template</em> to write your Java programs. Choose a meaningful &quot;<em>Classname</em>&quot; that reflects the <em>purpose</em> of your program, and write your programming statements inside the body of the <code>main()</code> method. Don't worry about the other terms and keywords now. I will explain them in due course. Provide comments in your program!</p>
	
<pre data-line="6"><code class="language-java line-numbers">/**
 * Comment to state the purpose of the program
 */
public class Classname {   // Choose a meaningful Classname. Save as "Classname.java"
   public static void main(String[] args) {  // Entry point of the program
      // Your programming statements here!!!
   }
}</code></pre>

<h4>A Sample Program Illustrating Sequential, Decision and Loop Constructs</h4>

<p>Below is a simple Java program that demonstrates the three basic programming constructs: <em>sequential</em>, <em>loop</em>, and <em>conditional</em>. Read &quot;<a href="J1a_Introduction.html">Introduction To Java Programming for First-time Programmers</a>&quot; if you need help in understanding this program.</p>
	
<pre><code class="language-java line-numbers">/**
 * Find the sums of the running odd numbers and even numbers from a given lowerbound 
 * to an upperbound. Also compute their absolute difference.
 */
public class OddEvenSum {  // Save as "OddEvenSum.java"
   public static void main(String[] args) {
      // Declare variables
      final int LOWERBOUND = 1;
      final int UPPERBOUND = 1000;  // Define the bounds
      int sumOdd  = 0;    // For accumulating odd numbers, init to 0
      int sumEven = 0;    // For accumulating even numbers, init to 0
      int absDiff;        // Absolute difference between the two sums

      // Use a while loop to accumulate the sums from LOWERBOUND to UPPERBOUND
      int number = LOWERBOUND;   // loop init
      while (number &lt;= UPPERBOUND) {  // loop test
            // number = LOWERBOUND, LOWERBOUND+1, LOWERBOUND+1, ..., UPPERBOUND
         // A if-then-else decision
         if (number % 2 == 0) {  // Even number
            sumEven += number;   // Same as sumEven = sumEven + number
         } else {                // Odd number
            sumOdd += number;    // Same as sumOdd = sumOdd + number
         }
         ++number;  // loop update for next number
      }
      // Another if-then-else Decision
      if (sumOdd &gt; sumEven) {
         absDiff = sumOdd - sumEven;
      } else {
         absDiff = sumEven - sumOdd;
      }
      // OR using one liner conditional expression
      //absDiff = (sumOdd &gt; sumEven) ? sumOdd - sumEven : sumEven - sumOdd;
 
      // Print the results
      System.out.println("The sum of odd numbers from " + LOWERBOUND + " to " + UPPERBOUND + " is: " + sumOdd);
      System.out.println("The sum of even numbers from " + LOWERBOUND + " to " + UPPERBOUND + " is: " + sumEven);
      System.out.println("The absolute difference between the two sums is: " + absDiff);
   }
}</code></pre>
 
<p>The expected outputs are:</p>
<pre class="output">The sum of odd numbers from 1 to 1000 is: 250000<br>The sum of even numbers from 1 to 1000 is: 250500<br>The absolute difference between the two sums is: 500</pre>

<h4>Comments</h4>
<p>Comments are used to document and explain your code and your program logic.  Comments are not programming statements. They are  ignored by the compiler and have no consequences to the program execution. Nevertheless, comments are VERY IMPORTANT for providing documentation and explanation for others to understand your programs (and also for yourself three days later).</p>

<p>There are two kinds of comments in Java:</p>
<ol>
<li><span class="lead">Multi-Line Comment</span>: begins with a <code>/*</code> and ends with a <code>*/</code>, and can span multiple lines. <code>/** .... */</code> is a special <em>documentation comment</em>. These comment can be extracted to produce documentation.</li>
<li><span class="lead">End-of-Line (Single-Line) Comment</span>: begins with <code>//</code> and lasts till the end of the current line.</li>
</ol>

<p>I recommend that you use comments <em>liberally</em> to explain and document your code.</p>
<p>During program development, instead of deleting a chunk of statements irrevocably, you could <em>comment-out</em> these statements so that you could get them back later, if needed.</p>

<h4>Statements and Blocks</h4>

<p><span class="lead">Statement</span>: A programming <em>statement</em> is the smallest independent unit in a program, just like a sentence in the English language. It performs <em>a piece of programming action</em>. A programming statement must be terminated by a semi-colon (<code>;</code>), just like an English sentence ends with a period. (Why not ends with a period like an English sentence? This is because period crashes with decimal point - it is challenging for the dumb computer to differentiate between period and decimal point in the early days of computing!)</p>

<p>For examples,</p>

<pre class="example">
<span class="comment">// Each of the following lines is a programming statement, which ends with a semi-colon (;).
// A programming statement performs a piece of programming action.</span>
int number1 = 10;
int number2, number3 = 99;
int product;
number2 = 8;
product = number1 * number2 * number3;
System.out.println(&quot;Hello&quot;);
</pre>

<p><span class="lead">Block</span>: A <em>block</em> is a group of  programming statements surrounded by a pair of curly braces <code>{ }</code>. All the statements inside the block is treated as one single unit. Blocks are used as the <em>body</em> in constructs like class, method, if-else and loop, which may contain multiple statements but are treated as one unit (one body). There is no need to put a semi-colon after the closing brace to end a compound statement. Empty block (i.e., no statement inside the braces) is permitted.</p>
<p>For examples,</p>

<pre class="example">
<span class="comment">// Each of the followings is a &quot;compound&quot; statement comprising one or more blocks of statements.
// No terminating semi-colon needed after the closing brace to end the &quot;compound&quot; statement.
// Take note that a &quot;compound&quot; statement is usually written over a few lines for readability.</span>
if (mark &gt;= 50) {     <span class="comment">// A if statement</span>
   System.out.println(&quot;PASS&quot;);
   System.out.println(&quot;Well Done!&quot;);
   System.out.println(&quot;Keep it Up!&quot;);
}
 
if (input != -1) {   <span class="comment">// A if-else statement</span>
   System.out.println(&quot;Continue&quot;); 
} else { 
   System.out.println(&quot;Exit&quot;); 
}
 
i = 1;
while (i &lt; 8) {      <span class="comment">// A while-loop statement</span>
   System.out.print(i + &quot; &quot;);
   ++i; 
}
 
public static void main(String[] args) {   <span class="comment">// A method definition statement</span>
   ...<em>statements...</em> 
}
 
public class Hello {   <span class="comment">// A class definition statement</span>
   ...<em>statements...</em> 
}</pre>

<h4>White Spaces and Formatting Source Code</h4>
<p><span class="lead">White Spaces</span>: <em>Blank</em>, <em>tab</em> and <em>newline</em> are collectively called <em>white spaces</em>.</p>
<p>You need to use a white space to separate two keywords or tokens to avoid ambiguity, e.g.,</p>
<pre class="example">
int sum = 0;     <span class="comment">// Cannot write &quot;intsum&quot;. Need at least one white space between &quot;int&quot; and &quot;sum&quot;</span>
double average;  <span class="comment">// Again, need at least a white space between &quot;double&quot; and &quot;average&quot;</span></pre>
<p> Java, like most of the programming languages, ignores <em>extra</em> white spaces.  That is, multiple contiguous white spaces are treated as a <em>single</em> white space. Additional white spaces and extra lines are ignored, e.g.,</p>
<pre class="example">
<span class="comment">// Same as above with many redundant white spaces. Hard to read.</span>
int  sum 
=0     ;

   double  
average
;

<span class="comment">// Also same as above with minimal white space. Also hard to read</span>
int sum=0;double average;</pre>

<p><span class="lead">Formatting Source Code</span>: As mentioned, extra white spaces are ignored and have no computational significance. However, proper indentation (with tabs and  blanks) and extra empty lines greatly improves the readability of the program. This is extremely important for others (and yourself three days later) to understand your programs. </p>

<p>For example, the following one-line hello-world program works. But can you read and understand the program?</p>

<pre class="example">
public class Hello{public static void main(String[] args){System.out.println(&quot;Hello, world!&quot;);}}
</pre>

<p><span class="lead">Braces</span>: Java's convention is to place the beginning brace at the end of the line, and to align the ending brace with the start of the statement. Pair-up the { } properly.  Unbalanced { } is one of the most common syntax errors for beginners.</p>

<p><span class="lead">Indentation</span>: Indent each <em>level</em> of the body of a block by an extra 3 or 4 spaces according to the hierarchy of the block. Don't use tab because tab-spaces is editor-dependent.</p>


<pre class="example">
<span class="comment">/**
 * Recommended Java programming style (Documentation comments about the class)
 */</span>
public class <em><strong>ClassName</strong></em> {      <span class="comment">// Place the beginning brace at the end of the current line</span>
   public static void main(String[] args) {  <span class="comment">// Indent the body by an extra 3 or 4 spaces for each level</span>
   
      <span class="comment">// Use empty line liberally to improve readability</span>
      <span class="comment">// Sequential statements</span>
      <em>statement-1</em>;
      <em>statement-2</em>;
   
      <span class="comment">// A if-else statement</span>
      if (<em>test</em>) {
         <em>true-statements</em>;
      } else {
         <em>false-statements</em>;
      }
      
      <span class="comment">// A loop statement</span>
      <em>init</em>;
      while (<em>test</em>) {
         <em>body-statements</em>;
         <em>update</em>;
      }
   }
}   <span class="comment">// Ending brace aligned with the start of the statement</span></pre>

<p><span class="lead">&quot;Code is read much more often than it is written.&quot;</span> Hence, you have to make sure that your code is readable (by others and yourself 3 days later), by following convention and recommended coding style.</p>


<h3>Variables and Types</h3>

<h4>Variables - Name, Type and Value</h4>

<p>Computer programs manipulate (or process) data. A <em>variable</em> is used to <em>store a piece of data</em> for processing. It is called <em>variable</em> because you can change the value stored.</p>

<p>More precisely, a <em>variable</em> is a <em>named</em> storage location, that stores a <em>value</em> of a particular data <em>type</em>. In other words, a <em>variable</em> has a <em>name</em>, a <em>type</em> and stores a <em>value</em>.</p>

<ul>

<li>A variable has a <em>name</em> (aka <em>identifier</em>), e.g., <code>radius</code>, <code>area</code>, <code>age</code>, <code>height</code> and <code>numStudents</code>. The name is needed to <em>uniquely</em> identify and reference each variable. You can use the <em>name</em> to assign a value to the variable (e.g., <code>radius = 1.2</code>), and to retrieve the value stored (e.g., <code>radius*radius*3.1419265</code>).</li>

<li>A variable has a  <em>data type</em>. The frequently-used Java <em>data types</em> are:
  <ul>
<li><code>int</code>: meant for integers (whole numbers) such as <code>123</code> and <code>-456</code>.</li>

<li><code>double</code>: meant for floating-point number (real numbers) having an optional decimal point and fractional part, such as <code>3.1416</code>, <code>-55.66</code>, <code>1.2e3</code>, or <code>-4.5E-6</code>, where <code>e</code> or <code>E</code> denotes exponent of base <code>10</code>.</li>

<li><code>String</code>: meant for texts such as <code>&quot;Hello&quot;</code> and  <code>&quot;Good Morning!&quot;</code>. <code>String</code>s are enclosed within a pair of double quotes.</li>

<li><code>char</code>: meant for a single character, such as <code>'a'</code>, <code>'8'</code>. A <code>char</code> is enclosed by a pair of single quotes.</li>
</ul></li>

<li>In Java, you need to declare the <em>name</em> and the <em>type</em> of a variable before using a variable. For examples,
<pre class="example">
int sum;         <span class="comment">// Declare an &quot;int&quot; variable named &quot;sum&quot;</span>
double average;  <span class="comment">// Declare a &quot;double&quot; variable named &quot;average&quot;</span>
String message;  <span class="comment">// Declare a &quot;String&quot; variable named &quot;message&quot;</span>
char grade;      <span class="comment">// Declare a &quot;char&quot; variable named &quot;grade&quot;</span></pre>
</li>
<li>A variable can store a <em>value</em> of the declared data <em>type</em>. It is important to take note that a variable in most programming languages is associated with a type, and can only store value of that particular type. For example, an <code>int</code> variable can store an integer value such as <code>123</code>, but NOT floating-point number such as <code>12.34</code>, nor string such as <code>&quot;Hello&quot;</code>.</li>

<li>The concept of <em>type</em> was introduced in the early programming languages to <em>simplify</em> interpretation of data made up of binary sequences (<code>0</code>'s and <code>1</code>'s). The type determines the size and layout of the data, the range of its values, and the set of operations that can be applied.</li>
</ul>

<p>The following diagram illustrates three types of variables: <code>int</code>, <code>double</code> and <code>String</code>. An <code>int</code> variable stores an integer (or whole number or fixed-point number); a <code>double</code> variable stores a floating-point number (or real number); a <code>String</code> variable stores texts.</p>

<img src="images/JavaBasics_Variable.png" alt="variable" width="504" height="283" class="image-left" />

<h4>Identifiers (or Names)</h4>

<p>An <em>identifier</em> is needed to <em>name</em> a variable (or any other entity such as a method or a class). Java imposes the following <em>rules on identifiers</em>:</p>

<ul>
<li>An identifier is a sequence of characters, of any length, comprising uppercase and lowercase letters <code>(a-z, A-Z)</code>, digits <code>(0-9)</code>, underscore (<code>_</code>), and dollar sign (<code>$</code>).</li>

<li>White space (blank, tab, newline) and other special characters (such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,  <code>@</code>, <code>&amp;</code>, commas, etc.) are not allowed. Take note that blank and dash (<code>-</code>) are not allowed, i.e., &quot;<code>max value</code>&quot; and &quot;<code>max-value</code>&quot; are not valid names. (This is because blank creates two tokens and dash crashes with minus sign!)</li>

<li>An identifier must begin with a letter  <code>(a-z, A-Z)</code> or underscore (<code>_</code>). It cannot begin with a digit <code>(0-9)</code> (because that could confuse with a number). Identifiers begin with dollar sign (<code>$</code>) are reserved for system-generated entities.</li>

<li>An identifier cannot be a reserved keyword or a reserved literal (e.g., <code>class</code>, <code>int</code>, <code>double</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>true</code>, <code>false</code>, <code>null</code>).</li>

<li>Identifiers are case-sensitive. A <code>rose</code> is NOT a <code>Rose</code>, and is NOT a <code>ROSE</code>.</li>
</ul>

<p>Examples: <code>abc</code>, <code>_xyz</code>, <code>$123</code>, <code>_1_2_3</code> are valid identifiers. But <code>1abc</code>, <code>min-value</code>, <code>surface area</code>, <code>ab@c</code> are NOT valid identifiers.</p>

<p><span class="line-heading color-new">Caution</span>: Programmers don't use <em>blank</em> character in any names (filename, project name, variable name, etc.). It is either not supported (e.g., in Java and C/C++), or will pose you many more challenges.</p>

<h5>Variable Naming Convention</h5>

<p>A variable name is a noun, or a noun phrase made up of several  words with no spaces between words. The first word is in lowercase, while the remaining words are initial-capitalized. For examples, <code>radius</code>, <code>area</code>, <code>fontSize</code>, <code>numStudents</code>, <code>xMax</code>, <code>yMin</code>,  <code>xTopLeft</code>, <code>isValidInput</code>, and <code>thisIsAVeryLongVariableName</code>. This convention is also known as <em>camel-case</em>.</p>

<h5>Recommendations</h5>

<ol>
<li>It is important to choose a name that is <em>self-descriptive</em> and closely reflects the meaning of the variable, e.g., <code>numberOfStudents</code> or <code>numStudents</code>, but not <code>n</code> or <code>x</code>, to store the number of students. It is alright to use abbreviations.</li>

<li>Do not use <em>meaningless</em> names like <code>a</code>, <code>b</code>, <code>c</code>, <code>i</code>, <code>j</code>, <code>k</code>, <code>n</code>, <code>i1</code>, <code>i2</code>, <code>i3</code>, <code>j99</code>, <code>exercise85</code> (what is the purpose of this exercise?), and <code>example12</code> (What is this example about?).</li>

<li>Avoid <em>single-letter</em> names like <code>i</code>, <code>j</code>, <code>k</code>, <code>a</code>, <code>b</code>, <code>c</code>, which are easier to type but often meaningless. Exceptions are common names like <code>x</code>, <code>y</code>, <code>z</code> for coordinates, <code>i</code> for index. Long names are harder to type, but self-document your program. (I suggest you spend sometimes practicing your typing.)</li>

<li>Use <em>singular</em> and <em>plural</em> nouns  prudently to differentiate between singular and plural variables.  For example, you may use the variable <code>row</code> to refer to a single row number and the variable <code>rows</code>  to refer to many rows (such as an array of rows - to be discussed later).</li>
</ol>

<h4>Variable Declaration</h4>

<p>To use a variable in your program, you need to first <em>introduce</em> it by <em>declaring</em> its <em>name</em> and <em>type</em>, in one of the following syntaxes. The act of declaring a variable allocates a storage of size capable of holding a value of the type.</p>

<table class="table-zebra code">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>

<tr>
<td><span class="comment">// Declare a variable of a specified type</span><br>
<em>type identifier</em>;</td>
<td>int sum;<br>
double average;<br>
String statusMsg;</td>
</tr>

<tr>
<td><span class="comment">// Declare multiple variables of the SAME type,<br>
//  separated by commas</span><br>
<em>type identifier1</em>, <em>identifier2</em>, ..., <em>identifierN</em>;</td>
<td>int number, count;<br>
double sum, difference, product, quotient;<br>
String helloMsg, gameOverMsg;<br></td>
</tr>

<tr>
<td><span class="comment">// Declare a variable and assign an initial value</span><br>
<em>type identifier</em> = <em>initialValue</em>;</td>
<td>int magicNumber = 99;<br>
double pi = 3.14169265;<br>
String helloMsg = &quot;hello,&quot;;<br></td>
</tr>
<tr>
<td><span class="comment">// Declare multiple variables of the SAME type,<br>
//  with initial values</span><br>
<em>type identifier1</em> = <em>initValue1</em>, ..., <em>identifierN</em> = <em>initValueN</em>;</td>
<td>int sum = 0, product = 1;<br>
double height = 1.2, length = 3.45;<br>
String greetingMsg = &quot;hi!&quot;, quitMsg = &quot;bye!&quot;;</td>
</tr>
</table>

<p>Take note that:</p>

<ul>
<li>A variable is declared with a <em>type</em>. Once the <em>type</em> of a variable is declared, it can only store a value belonging to that particular type. For example, an <code>int</code> variable can hold only integer (such as <code>123</code>), and NOT floating-point number (such as <code>-2.17</code>) or text string (such as <code>&quot;Hello&quot;</code>).</li>

<li>Each variable can only be declared once because identifier shall be unique.</li>

<li>You can declare a variable anywhere inside the program, as long as it is declared before being used.</li>

<li> The type of a variable cannot be changed inside the program, once it is declared.</li>
<li>A variable declaration statement begins with a <em>type</em>, and works for only that type. In other words, you cannot declare variables of two different types in a single declaration statement.</li>
<li>Java is a <em>statically-typed</em> language. This means that the type is resolved at compile time and never changes.</li>
</ul>

<h4>Constants (<code>final</code> variables)</h4>

<p>Constants are <em>non-modifiable</em> (<em>immutable</em>) variables, declared with keyword <code>final</code>. You can only assign values to final variables ONCE. Their values cannot be changed during program execution. For examples:</p>

<pre class="example">
<span class="new">final</span> double PI = 3.14159265;  <span class="comment">// Declare and initialize the constant</span>

<span class="new">final</span> int SCREEN_X_MAX = 1280;
<span class="error">SCREEN_X_MAX = 800;</span>  <span class="comment">//<span class="error">compilation error: cannot assign a value to final variable</span>
</span>
<span class="comment">// You can only assign value to final variables ONCE</span>
<span class="new">final</span> int SCREEN_Y_MIN;
SCREEN_Y_MIN = 0;   <span class="comment">// First assignment</span>
<span class="error">SCREEN_Y_MIN = 10;</span>  <span class="comment">//</span><span class="error">compilation error: variable might already have been assigned</span></pre>

<p><span class="lead">Constant Naming Convention:</span> Use uppercase words, joined with underscore. For example, <code>MIN_VALUE</code>, <code>MAX_SIZE</code>, and <code>INTEREST_RATE_6_MTH</code>.</p>

<h4>Expressions</h4>

<p>An <em>expression</em> is a combination of <em>operators</em> (such as <code>'+'</code> and  <code>'-'</code>) and <em>operands</em> (variables or literals), that can be <em>evaluated to yield a single value of a certain type</em>.</p>
<img src="images/expression.png" alt="expression" width="372" height="145" class="image-left">

<p>For example,</p>

<pre class="example">
<span class="comment">// &quot;int&quot; literals</span>
((1 + 2) * 3 / 4) % 6   <span class="comment">// This expression is evaluated to an &quot;int&quot; value</span>
<span class="comment">
// &quot;double&quot; literals</span>
3.45 + 6.7              <span class="comment">// This expression is evaluated to a &quot;double&quot; value</span>

<span class="comment">// Assume that variables sum and number are &quot;int&quot;</span>
sum + number * number   <span class="comment">// evaluates to an &quot;int&quot; value</span>

<span class="comment">// Assume that variables principal and interestRate are &quot;double&quot;</span>
principal * (1.0 + interestRate)  <span class="comment">// evaluates to a &quot;double&quot; value</span></pre>

<h4>Assignment (<code>=</code>)</h4>

<p>An <em>assignment statement</em> evaluates the RHS (Right-Hand Side) and assigns the resultant value to the variable of the LHS (Left-Hand Side).</p>

<p>The syntax for assignment statement is:</p>

<table class="table-zebra code">
<col style="width:60%" />
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>

<tr>
<td><span class="comment">// Assign the RHS literal value to the LHS variable</span><br>
<em>variable</em> = <em>literalValue</em>;</td>
<td>
int number;<br>
number = 9;</td>
</tr>
<tr>
<td><span class="comment">// Evaluate the RHS expression and assign the result to the LHS variable</span><br>
<em>variable</em> = <em>expression</em>;</td>
<td>int sum = 0, number = 8;<br>
sum = sum + number;</td>
</tr>
</table>

<p>The assignment statement should be interpreted this way: The <em>expression</em> on the RHS is first evaluated to produce a resultant value (called <em>r-value</em> or right-value). The <em>r-value</em> is then assigned to the variable on the left-hand-side (LHS) or <em>l-value</em>. Take note that you have to first evaluate the RHS, before assigning the resultant value to the LHS. For examples,</p>

<pre class="example">
int number;
number = 8;           <span class="comment">// Assign RHS literal value of 8 to the LHS variable number</span>
number = number + 1;  <span class="comment">// Evaluate the RHS expression (number + 1),
                      //  and assign the resultant value back to the LHS variable number</span>

<span class="error">8 = number;</span>           <span class="comment">// Invalid in Programming, LHS shall be a variable</span>
<span class="error">number + 1 = sum;</span>     <span class="comment">// Invalid in Programming, LHS shall be a variable</span></pre>

<h5><code>'='</code> is Assignment, NOT Equality</h5>

<img class="image-float-right" src="images/x_plus_one.gif" alt="x_plus_one.gif"  />
<p>In Java, the equal symbol <code>'='</code> is known as the <em>assignment operator</em>. The meaning of <code>'='</code> in programming is different from Mathematics. It denotes <em>assignment of the RHS value to the LHS variable</em>, NOT <em>equality of the RHS and LHS</em>. The RHS shall be a literal value or an expression that evaluates to a value; while the LHS must be a variable. </p>

<p>Note that <code>x = x + 1</code> is valid (and often used) in programming. It evaluates the RHS expression <code>x + 1</code> and assigns the resultant value to the LHS variable <code>x</code>. On the other hand, <code>x = x + 1</code> is illegal in Mathematics.</p>
<p> While <code>x + y = 1</code> is allowed in Mathematics, it is invalid in programming because the LHS of an assignment statement shall be a variable.</p>
<p> Some programming languages use symbol &quot;<code>:=</code>&quot;,  &quot;<code>-&gt;</code>&quot; or &quot;<code>&lt;-</code>&quot; as the assignment operator to avoid confusion with equality.</p>

<h3>Primitive Types and <code>String</code></h3>

<p>In Java, there are two broad categories of data <em>types</em>:</p>
<ol>
<li>Primitive types (e.g., <code>int</code>, <code>double</code>),</li>
<li>Reference types (e.g., objects and arrays).</li>
</ol>

<p>We shall describe the primitive types here. We will cover the reference types (classes and objects) in the later chapters on &quot;Object-Oriented Programming&quot;.</p>
<h4>Built-in Primitive Types</h4>

<table class="table-zebra">
<tr>
  <th>TYPE</th>
  <th colspan="2">DESCRIPTION</th>
</tr>
<tr>
  <td class="lead-code">byte</td>
  <td rowspan="4"><span class="lead">Integer</span></td>
  <td>8-bit signed integer<br>
  The range is <code>[-2<sup>7</sup>, 2<sup>7</sup>-1] = [-128, 127]</code></td>
</tr>
<tr>
  <td class="lead-code">short</td>
  <td>16-bit signed integer<br>
  The range is <code>[-2<sup>15</sup>, 2<sup>15</sup>-1] = [-32768, 32767]</code></td>
</tr>
<tr>
  <td class="lead-code">int</td>
  <td>32-bit signed integer<br>
  The range is <code>[-2<sup>31</sup>, 2<sup>31</sup>-1] = [-2147483648, 2147483647]</code> (&asymp;9 digits, &plusmn;2G)</td>
</tr>
<tr>
  <td class="lead-code">long</td>
  <td>64-bit signed integer<br>
  The range is <code>[-2<sup>63</sup>, 2<sup>63</sup>-1] = [-9223372036854775808, 9223372036854775807]</code> (&asymp;19 digits)</td>
</tr>
<tr>
  <td class="lead-code">float</td>
  <td rowspan="2"><span class="lead">Floating-Point <br>
    Number</span><br>
  F x 2<sup>E</sup></td>
  <td>32-bit single precision floating-point number<br>
  (<code>&asymp;</code>6-7 significant decimal digits, in the range of <code>&plusmn;[1.4x10<sup>-45</sup>, 3.4028235x10<sup>38</sup>]</code>)</td>
</tr>
<tr>
  <td class="lead-code">double</td>
  <td>64-bit double precision floating-point number<br>
  (<code>&asymp;</code>14-15 significant decimal digits, in the range of <code>&plusmn;[4.9x10<sup>-324</sup>, 1.7976931348623157x10<sup>308</sup>]</code>)</td>
</tr>
<tr>
  <td class="lead-code">char</td>
  <td colspan="2"><span class="lead">Character</span><br>
  Represented in 16-bit Unicode <code>'\u0000'</code> to <code>'\uFFFF'</code>.<br>  
  Can be treated as integer in the range of <code>[0, 65535]</code> in arithmetic operations.<br>
  (Unlike C/C++, which uses 8-bit ASCII code.)</td>
</tr>
<tr>
  <td class="lead-code">boolean</td>
  <td colspan="2"><span class="lead">Binary</span><br>
  Takes a  literal value of either <code>true</code> or <code>false</code>.<br>
  The size of <code>boolean</code> is not defined in the Java specification, but requires at least one bit. <br>
  <code>boolean</code>s are used in <em>test</em> in decision and loop, not applicable for arithmetic operations.<br>
  (Unlike C/C++, which uses integer <code>0</code> for false, and non-zero for true.)</td>
</tr>
</table>

<img class="image-float-right" src="images/Type_Primitive.gif" alt="primitive types" />

<p>Primitive type are built-into the language for maximum efficiency, in terms of both space and computational efficiency.</p>
<p>Java has eight <em>primitive types</em>, as listed in the above table:</p>

<ul>
<li>There are four integer types: 8-bit <code>byte</code>, 16-bit <code>short</code>, 32-bit <code>int</code>  and 64-bit <code>long</code>. They are <em>signed integers</em> in <em>2's complement representation</em>, and can hold a zero, positive and negative integer value of the various ranges as shown in the table.</li>

<li>There are two floating-point types: 32-bit single-precision <code>float</code> and 64-bit double-precision <code>double</code>. They are represented in scientific notation of <code>Fx2<sup>E</sup></code> where the fraction (<code>F</code>)  and exponent (<code>E</code>) are stored separately (as specified by the IEEE 754 standard). Take note that not all real numbers can be represented by <code>float</code> and <code>double</code>. This is  because there are infinite real numbers even in a small range of say <code>[1.0, 1.1]</code>, but there is a finite number of patterns in a n-bit representation. Most of the floating-point values are approximated to their nearest representation.</li>

<li>The type <code>char</code> represents a single character, such as <code>'0'</code>, <code>'A'</code>, <code>'a'</code>. In Java, <code>char</code> is represented using 16-bit Unicode (in UCS-2 format) to support internationalization (<em>i18n</em>). A <code>char</code> can be treated as an integer in the range of <code>[0, 65535]</code> in arithmetic operations. For example, character <code>'0'</code> is <code>48</code> (decimal) or <code>30H</code> (hexadecimal); character <code>'A'</code> is <code>65</code> (decimal) or <code>41H</code> (hexadecimal); character <code>'a'</code> is <code>97</code> (decimal) or <code>61H</code> (hexadecimal).</li>

<li>Java introduces a new <em>binary </em>type called &quot;<code>boolean</code>&quot;, which takes a  literal value of either <code>true</code> or <code>false</code>. <code>boolean</code>s are used in <em>test</em> in decision and loop. They are not applicable to arithmetic operations (such as addition and multiplication).</li>
</ul>

<h4>Integers vs. Floating-Point Numbers</h4>

<p>In computer programming, integers (such as 123, -456) and floating-point numbers (such as 1.23, -4.56, 1.2e3, -4.5e-6) are TOTALLY different.</p>
<ol>
<li>Integers and floating-point numbers are <em>represented</em> and <em>stored</em> differently.</li>
<li>Integers and floating-point numbers are <em>operated</em> differently.</li>
</ol>

<h5>How Integers and Floating-Point Numbers are Represented and Stored in Computer Memory?</h5>

<img src="images/DataRep_Integers.png" alt="DataRep_Integers.png" width="547" height="172" class="image-left" />

<p>Integers are represented in a so called <em>2's complement</em> scheme as illustrated. The most-significant bit is called <em>Sign Bit</em> (<code>S</code>), where <code>S=0</code> represents positive integer and <code>S=1</code> represents negative integer. The remaining bits represent the magnitude of the integers. For positive integers, the magnitude is the same as the binary number, e.g., if <code>n=16</code> (<code>short</code>), <code>0000000000000010</code> is <code>+2<sub>10</sub></code>. Negative integers require 2's complement conversion.</p>

<img src="images/DataRep_FloatingPoint.png" alt="DataRep_Integers.png" width="642" height="146" class="image-left" />


<p>Floating-point numbers are represented in scientific form of <code>Fx2<sup>E</sup></code>, where Fraction (<code>F</code>) and Exponent (<code>E</code>) are stored separately. For example, to store <code>12.75<sub>10</sub></code>; first convert to binary of <code>1100.11<sub>2</sub></code>; then normalize to <code>1.10011<sub>2</sub> x 2<sup>3</sup></code>; we have <code>F=1.1011</code> and <code>E=3<sub>10</sub>=11<sub>2</sub></code> which are then stored with some scaling.</p>

<p>For details, read &quot;<a href="DataRepresentation.html">Data Representation - Integers, Floating-Point Numbers and Characters</a>&quot;.</p>

<h5>How Integers and Floating-Point Numbers are Operated?</h5>
<p>Integers and floating-point numbers are operated differently using different hardware circuitry. Integers are processed in CPU (Central Processing Unit), while floating-point numbers are processed in FPU (Floating-point Co-processor Unit).</p>
<p>Integer operations are straight-forward. For example, integer addition is carried out as illustrated:</p>
<img src="images/Addition_Integers.png" alt="Addition Integers" width="153" height="112" class="image-left" />

<p>On the other hand, floating-point addition is complex, as illustrated:</p>
<img src="images/Addition_FloatingPoint.png" alt="Addition FloatingPoint" width="366" height="171" class="image-left" />

<p>It is obvious that integer operations (such as addition) is much faster than floating-point operations.</p>
<p>Furthermore, integer are precise. All numbers within the range can be represented accurately. For example, a 32-bit <code>int</code> can represent ALL integers from <code>-2147483648</code> to <code>+2147483647</code> with no gap in between. On the other hand, floating-point are NOT precise, but close approximation. This is because there are infinite floating-point numbers in any interval (e.g., between 0.1 to 0.2). Not ALL numbers can be represented using a finite precision (32-bit <code>float</code> or 64-bit <code>double</code>).</p>

<h5>You need to treat integers and Floating-point numbers as two DISTINCT types in programming!</h5>
<h5>Use integer if possible (it is faster, precise and uses fewer bits). Use floating-point number only if a fractional part is required.</h5>

<h4>Data Representation</h4>

<p>Read &quot;<a href="DataRepresentation.html">Data Representation - Integers, Floating-Point Numbers and Characters</a>&quot; if you wish to understand how the numbers and characters are represented inside the computer memory.</p>
<p>In brief,  It is important to take note that <code>char</code> <code>'1'</code> is different from <code>int</code> <code>1</code>, <code>byte</code> <code>1</code>, <code>short</code> <code>1</code>, <code>float</code> <code>1.0</code>, <code>double</code> <code>1.0</code>, and <code>String</code> <code>&quot;1&quot;</code>. They are represented differently in the computer memory, with different precision and interpretation. They are also processed differently. For examples:</p>
<ul>
<li><code>byte</code> <code>1</code> is <code>&quot;00000001&quot;</code> (8-bit).</li>
<li><code>short</code> <code>1</code> is <code>&quot;00000000 00000001&quot;</code> (16-bit).</li>
<li><code>int</code> <code>1</code> is <code>&quot;00000000 00000000 00000000 00000001&quot;</code> (32-bit).</li>
<li><code>long</code> <code>1</code> is <code>&quot;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001&quot;</code> (64-bit).</li>
<li><code>float</code> <code>1.0</code> is <code>&quot;0 01111111 0000000 00000000 00000000&quot;</code> (32-bit).</li>
<li><code>double</code> <code>1.0</code> is <code>&quot;0 01111111111 0000 00000000 00000000 00000000 00000000 00000000 00000000&quot;</code> (64-bit).</li>
<li><code>char</code> <code>'1'</code> is <code>&quot;00000000 00110001&quot;</code> (16-bit) (Unicode number 49).</li>
<li><code>String</code> <code>&quot;1&quot;</code> is a complex object (many many bits).</li>
</ul>

<p> There is a subtle difference between <code>int</code> <code>0</code> and <code>double</code> <code>0.0</code> as they have different bit-lengths and internal representations.</p>

<p>Furthermore, you MUST know the type of a value before you can interpret a value. For example, this bit-pattern <code>&quot;00000000 00000000 00000000 00000001&quot;</code> cannot be interpreted unless you know its type (or its representation).</p>



<h4>Maximum/Minimum Values of Primitive Number Types</h4>
<p>The following program can be used to print the <em>maximum</em>, <em>minimum</em> and <em>bit-length</em> of the primitive types. For example, the maximum, minimum and bit-size of <code>int</code> are kept in built-in constants <code>INTEGER.MIN_VALUE</code>, <code>INTEGER.MAX_VALUE</code>, <code>INTEGER.SIZE</code>.</p>

<pre class="example">
<span class="comment">/**
 * Print the minimum, maximum and bit-length of all primitive types (except boolean)
 */</span>
public class PrimitiveTypesMinMaxBitLen {
   public static void main(String[] args) {
      <span class="comment">/* int (32-bit signed integer) */</span>
      System.out.println(&quot;int(min) = &quot; + Integer.MIN_VALUE);
      <span class="comment">//<span class="output">int(min) = -2147483648</span></span>
      System.out.println(&quot;int(max) = &quot; + Integer.MAX_VALUE);
      <span class="comment">//<span class="output">int(max) = 2147483647</span></span>
      System.out.println(&quot;int(bit-length) = &quot; + Integer.SIZE);
      <span class="comment">//<span class="output">int(bit-length) = 32</span></span>

      <span class="comment">/* byte (8-bit signed integer) */</span>
      System.out.println(&quot;byte(min) = &quot; + Byte.MIN_VALUE);
      <span class="comment">//<span class="output">byte(min) = -128</span></span>
      System.out.println(&quot;byte(max) = &quot; + Byte.MAX_VALUE);
      <span class="comment">//<span class="output">byte(max) = 127</span></span>
      System.out.println(&quot;byte(bit-length) = &quot; + Byte.SIZE);
      <span class="comment">//<span class="output">byte(bit-length) = 8</span></span>

      <span class="comment">/* short (16-bit signed integer) */</span>
      System.out.println(&quot;short(min) = &quot; + Short.MIN_VALUE);
      <span class="comment">//<span class="output">short(min) = -32768</span></span>
      System.out.println(&quot;short(max) = &quot; + Short.MAX_VALUE);
      <span class="comment">//<span class="output">short(max) = 32767</span></span>
      System.out.println(&quot;short(bit-length) = &quot; + Short.SIZE);
      <span class="comment">//<span class="output">short(bit-length) = 16</span></span>

      <span class="comment">/* long (64-bit signed integer) */</span>
      System.out.println(&quot;long(min) = &quot; + Long.MIN_VALUE);
      <span class="comment">//<span class="output">long(min) = -9223372036854775808</span></span>
      System.out.println(&quot;long(max) = &quot; + Long.MAX_VALUE);
      <span class="comment">//<span class="output">long(max) = 9223372036854775807</span></span>
      System.out.println(&quot;long(bit-length) = &quot; + Long.SIZE);
      <span class="comment">//<span class="output">long(bit-length) = 64</span></span>

      <span class="comment">/* char (16-bit character or 16-bit unsigned integer) */</span>
      System.out.println(&quot;char(min) = &quot; + (int)Character.MIN_VALUE);
      <span class="comment">//<span class="output">char(min) = 0</span></span>
      System.out.println(&quot;char(max) = &quot; + (int)Character.MAX_VALUE);
      <span class="comment">//<span class="output">char(max) = 65535</span></span>
      System.out.println(&quot;char(bit-length) = &quot; + Character.SIZE);
      <span class="comment">//<span class="output">char(bit-length) = 16</span></span>

      <span class="comment">/* float (32-bit floating-point) */</span>
      System.out.println(&quot;float(min) = &quot; + Float.MIN_VALUE);
      <span class="comment">//<span class="output">float(min) = 1.4E-45</span></span>
      System.out.println(&quot;float(max) = &quot; + Float.MAX_VALUE);
      <span class="comment">//<span class="output">float(max) = 3.4028235E38</span></span>
      System.out.println(&quot;float(bit-length) = &quot; + Float.SIZE);
      <span class="comment">//<span class="output">float(bit-length) = 32</span></span>

      <span class="comment">/* double (64-bit floating-point) */</span>
      System.out.println(&quot;double(min) = &quot; + Double.MIN_VALUE);
      <span class="comment">//<span class="output">double(min) = 4.9E-324</span></span>
      System.out.println(&quot;double(max) = &quot; + Double.MAX_VALUE);
      <span class="comment">//<span class="output">double(max) = 1.7976931348623157E308</span></span>
      System.out.println(&quot;double(bit-length) = &quot; + Double.SIZE);
      <span class="comment">//<span class="output">double(bit-length) = 64</span></span>

      <span class="comment">/* No equivalent constants for boolean type */</span>
   }
}</pre>

<h4>One More Important Type - <code>String</code></h4>

<p>Beside the 8 primitive types, another important and frequently-used type is <code>String</code>. A <code>String</code> is a sequence of characters (texts) such as <code>&quot;Hello, world&quot;</code>. <code>String</code> is not a primitive type (this will be  elaborated later).</p>
<p>In Java, a <code>char</code> is a single character enclosed by single quotes (e.g., <code>'A'</code>, <code>'0'</code>, <code>'$'</code>); while a <code>String</code> is a sequence of characters enclosed by double quotes (e.g., <code>&quot;Hello&quot;</code>).</p>
<p>For example,</p>

<pre class="example">
String greetingMsg = &quot;hello, world&quot;;  <span class="comment">// String is enclosed in double-quotes</span>
char gender = 'm';       <span class="comment">// char is enclosed in single-quotes</span>
String statusMsg = &quot;&quot;;   <span class="comment">// an empty String</span></pre>

<h4>Choice of Data Types for Variables</h4>
<p>As a programmer, YOU need to decide on the type of the variables to be used in your programs. Most of the times, the decision is intuitive. For example, use an integer type for counting and whole number; a floating-point type for number with fractional part, <code>String</code> for text message, <code>char</code> for a single character, and <code>boolean</code> for binary outcomes.</p>
<p>It is important to take note that your programs will have data of DIFFERENT types.</p>

<h5>Rules of Thumb for Choosing Data Types</h5>

<ul>
<li>For numbers, use an integer type if possible. Use a floating-point type only if the number contains a fractional part. Although floating-point numbers includes integers (e.g., <code>1.0</code>, <code>2.0</code>, <code>3.0</code>), floating-point numbers are approximation (not precise) and require more resources (computational and storage) for operations.</li>
<li>Although there are 4 integer types: 8-bit <code>byte</code>, 16-bit <code>short</code>, 32-bit <code>int</code> and 64-bit <code>long</code>, we shall use <code>int</code> for integers in general. Use <code>byte</code>, <code>short</code>, and <code>long</code> only if you have a good reason to choose that particular precision.</li>
<li>Among there are two floating-point types: 32-bit <code>float</code> and 64-bit <code>double</code>, we shall use <code>double</code> in general. Use <code>float</code> only if you wish to conserve storage and do not need the precision of <code>double</code>.</li>
<li><code>char</code>, <code>boolean</code> and <code>String</code> have their specific usage.</li>
</ul>

<p><span class="lead">Example (Variable Names and Types):</span> Paul has bought a new notebook of &quot;idol&quot; brand, with a processor speed of 2.66GHz, 8 GB of RAM, 500GB hard disk, with a 15-inch monitor, for $1760.55. He has chosen service plan 'C' among plans 'A', 'B', 'C', and 'D', plus on-site servicing but did not choose extended warranty. Identify the data types and name the variables.</p>

<p>The possible variable names and types are:</p>

<pre class="example">
String name = &quot;Paul&quot;;
String brand = &quot;idol&quot;;
double processorSpeedInGHz = 2.66; <span class="comment">// or float</span>
double ramSizeInGB = 8;            <span class="comment">// or float</span>
int harddiskSizeInGB = 500;        <span class="comment">// or short</span>
int monitorInInch = 15;            <span class="comment">// or byte</span>
double price = 1760.55;
char servicePlan = 'C';
boolean onSiteService = true;
boolean extendedWarranty = false;</pre>

<p><span class="lead">Exercise (Variable Names and Types):</span> You are asked to develop a software for a college. The system shall maintain information about students. This includes name, address, phone number, gender, date of birth, height, weight, degree pursued (e.g., B.Sc., B.A.), year of study, average GPA, with/without tuition grant, is/is not a scholar. Each student is assigned a unique 8-digit number as id. <br>
  You are required to identify the variables, assign a suitable name to each variable and choose an appropriate type. Write the variable declaration statements as in the above example.</p>


<h4>Literals for Primitive Types and <code>String</code></h4>

<p>A <em>literal</em>, or <em>literal constant</em>, is a <em>specific constant value</em>, such as <code>123</code>, <code>-456</code>, <code>3.14</code>16, <code>-1.2E3</code>, <code>4.5e-6</code>, <code>'a'</code>, <code>&quot;Hello&quot;</code>, that is used in the program source. It can be assigned directly to a variable; or used  as part of an expression. They are called <em>literals</em> because they literally and explicitly identify their values. We call it <em>literal</em> to distinguish it from a <em>variable</em>.</p>

<h5>Integer (<code>int</code>, <code>long</code>, <code>short</code>, <code>byte</code>) literals</h5>

<p>A whole number literal, such as <code>123</code> and <code>-456</code>, is treated as an <code>int</code> by default. For example,</p>

<pre class="example">
int number = -123;
int sum = 1234567890;     <span class="comment">// This value is within the range of int</span>
<span class="error">int bigSum = 8234567890;</span>  <span class="comment">// error: this value is outside the range of int</span>
<span class="error">int intRate = 6%;</span>         <span class="comment">// error: no percent sign</span>
<span class="error">int pay = $1234;</span>          <span class="comment">// error: no dollar sign</span>
<span class="error">int product = 1,234,567;</span>  <span class="comment">// error: no grouping commas</span></pre>

<p>An <code>int</code> literal may precede with a plus (<code>+</code>) or minus (<code>-</code>) sign, followed by digits. No commas or special symbols (e.g., <code>$</code>, <code>%</code>, or space) is allowed (e.g., <code>1,234,567</code>, <code>$123</code> and <code>12%</code> are invalid).</p>

<p>You can use a prefix <code>'0'</code> (zero) to denote an integer literal value in octal, and prefix <code>'0x'</code> (or <code>'0X'</code>) for a value in hexadecimal, e.g.,</p>

<pre class="example">
int number1 = 1234;   <span class="comment">// The usual decimal</span>
int number2 = 01234;  <span class="comment">// Octal 1234, Decimal 2322</span>
int number3 = 0017;   <span class="comment">// Octal 17, Decimal 15</span>
int number4 = 0x1abc; <span class="comment">// Hexadecimal 1ABC, decimal 15274</span></pre>

<p>From JDK 7, you can use prefix '<code>0b</code>' or '<code>0B</code>' to specify an integer literal value in binary. You are also permitted to use underscore (<code>_</code>) to break the digits into groups to improve the readability. But you must start and end the literal with a digit, not underscore. For example,</p>

<pre class="example">
<span class="comment">// JDK 7</span>
int number1 = 0b01010000101000101101000010100010;
int number2 = 0b0101_0000_1010_0010_1101_0000_1010_0010;  <span class="comment">// break the bits with underscore</span>
int number3 = 2_123_456;  <span class="comment">// break the decimal digits with underscore</span>
<span class="error">int number4 = _123_456;</span>   <span class="comment">// error: cannot begin or end with underscore</span></pre>

<p>A <code>long</code> literal outside the <code>int</code> range requires a suffix <code>'L'</code> or <code>'l'</code> (avoid lowercase <code>'l'</code>, which could be confused with the number one <code>'1'</code>), e.g., <code>123456789012L</code>, <code>-9876543210l</code>. For example,</p>

<pre class="example">
long sum = 123;                <span class="comment">// Within the &quot;int&quot; range, no need for suffix 'L'</span>
long bigSum = 1234567890123L;  <span class="comment">// Outside &quot;int&quot; range, suffix 'L' needed</span></pre>

<p>No suffix is needed for <code>byte</code> and <code>short</code> literals. But you can only use  values in the permitted range. For example,</p>

<pre class="example">
byte smallNumber1 = 123;        <span class="comment">// This is within the range of byte [-128, 127]</span>
<span class="error">byte smallNumber2 = -1234;</span>     <span class="comment"> // error: this value is out of range</span>

short midSizeNumber1 = -12345;  <span class="comment">// This is within the range of short [-32768, 32767]</span>
<span class="error">short midSizeNumber2 = 123456;</span>  <span class="comment">// error: this value is out of range</span></pre>

<h5>Floating-point (<code>double</code>, <code>float</code>) literals</h5>

<p>A literal number with a decimal point, such as <code>55.66</code> and <code>-33.44</code>, is treated as a <code>double</code> by default. You can also express them in scientific notation, e.g., <code>1.2e3</code>, <code>-5.5E-6</code>, where <code>e</code> or <code>E</code> denotes the exponent in base of 10. You could precede the fractional part or exponent with a plus (<code>+</code>) or minus (<code>-</code>) sign. Exponent values are restricted to integer. There should be no space or other characters in the number.</p>
<p>You are reminded that floating-point numbers are stored in scientific form of <code>Fx2<sup>E</sup></code>, where <code>F</code> (Fraction) and <code>E</code> (Exponent) are stored separately.</p>

<p>You can <em>optionally</em> use suffix <code>'d'</code> or <code>'D'</code> to denote <code>double</code> literals.</p>

<p>You MUST use a suffix of <code>'f'</code> or <code>'F'</code> for <code>float</code> literals, e.g., <code>-1.2345F</code>. For example,</p>

<pre class="example">
<span class="error">float average = 55.66;</span>    <span class="comment">// error: RHS is a double. Need suffix 'f' for float.</span>
float average = 55.66F;   <span class="comment">// float literal needs suffix 'f' or 'F'</span>

<span class="error">float rate = 1.2e-3;</span>    <span class="comment">// error: RHS is a double. Need suffix 'f' for float.</span>
float rate = 1.2e-3f;   <span class="comment">// float literal needs suffix 'f' or 'F'</span></pre>

<h5>Character (<code>char</code>) Literals and Escape Sequences</h5>

<p>A printable <code>char</code> literal (such as letters, digits and special symbols) is written by enclosing the character with a pair of <em>single quotes</em>, e.g., <code>'A'</code>, <code>'z'</code>, <code>'0'</code>, <code>'9'</code>, <code>'$'</code>, and <code>'@'</code>. Special <code>char</code> literals (such as tab, newline) are represented using so-called <em>escape sequences</em> (to be described later).</p>
<p> In Java, <code>char</code>s are represented using 16-bit Unicode. Printable characters for English letters (<code>a-z</code>, <code>A-Z</code>), digits (<code>0-9</code>) and symbols (<code>+</code>, <code>-</code>, <code>@</code>, etc.) are assigned to code numbers 32-126 (20H-7EH), as tabulated below (arranged in decimal and hexadecimal).</p>

<table class="table-zebra code" style="width:60%;text-align:center">
  <tr>
    <th>Dec</th>
    <th>0</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
    <th>8</th>
    <th>9</th>
  </tr>
  <tr>
    <th>3</th>
    <td class="tr-alt">&nbsp;</td>
    <td class="tr-alt">&nbsp;</td>
    <td>SP</td>
    <td>!</td>
    <td>&quot;</td>
    <td>#</td>
    <td>$</td>
    <td>%</td>
    <td>&amp;</td>
    <td>'</td>
  </tr>
  <tr>
    <th>4</th>
    <td>(</td>
    <td>)</td>
    <td>*</td>
    <td>+</td>
    <td>,</td>
    <td>-</td>
    <td>.</td>
    <td>/</td>
    <td><span class="lead-code">0</span></td>
    <td><span class="lead-code">1</span></td>
  </tr>
  <tr>
    <th>5</th>
    <td><span class="lead-code">2</span></td>
    <td><span class="lead-code">3</span></td>
    <td><span class="lead-code">4</span></td>
    <td><span class="lead-code">5</span></td>
    <td><span class="lead-code">6</span></td>
    <td><span class="lead-code">7</span></td>
    <td><span class="lead-code">8</span></td>
    <td><span class="lead-code">9</span></td>
    <td>:</td>
    <td>;</td>
  </tr>
  <tr>
    <th>6</th>
    <td>&lt;</td>
    <td>=</td>
    <td>&gt;</td>
    <td>?</td>
    <td>@</td>
    <td><span class="lead-code">A</span></td>
    <td>B</td>
    <td>C</td>
    <td>D</td>
    <td>E</td>
  </tr>
  <tr>
    <th>7</th>
    <td>F</td>
    <td>G</td>
    <td>H</td>
    <td>I</td>
    <td>J</td>
    <td>K</td>
    <td>L</td>
    <td>M</td>
    <td>N</td>
    <td>O</td>
  </tr>
  <tr>
    <th>8</th>
    <td>P</td>
    <td>Q</td>
    <td>R</td>
    <td>S</td>
    <td>T</td>
    <td>U</td>
    <td>V</td>
    <td>W</td>
    <td>X</td>
    <td>Y</td>
  </tr>
  <tr>
    <th>9</th>
    <td>Z</td>
    <td>[</td>
    <td>\</td>
    <td>]</td>
    <td>^</td>
    <td>_</td>
    <td>`</td>
    <td><span class="lead-code">a</span></td>
    <td>b</td>
    <td>c</td>
  </tr>
  <tr>
    <th>10</th>
    <td>d</td>
    <td>e</td>
    <td>f</td>
    <td>g</td>
    <td>h</td>
    <td>i</td>
    <td>j</td>
    <td>k</td>
    <td>l</td>
    <td>m</td>
  </tr>
  <tr>
    <th>11</th>
    <td>n</td>
    <td>o</td>
    <td>p</td>
    <td>q</td>
    <td>r</td>
    <td>s</td>
    <td>t</td>
    <td>u</td>
    <td>v</td>
    <td>w</td>
  </tr>
  <tr>
    <th>12</th>
    <td>x</td>
    <td>y</td>
    <td>z</td>
    <td>{</td>
    <td>|</td>
    <td>}</td>
    <td>~</td>
    <td class="tr-alt">&nbsp;</td>
    <td class="tr-alt">&nbsp;</td>
    <td class="tr-alt">&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>
<table class="table-zebra code" style="width:80%;text-align:center">
  <tr>
    <th>Hex</th>
    <th>0</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
    <th>8</th>
    <th>9</th>
    <th>A</th>
    <th>B</th>
    <th>C</th>
    <th>D</th>
    <th>E</th>
    <th>F</th>
  </tr>
  <tr>
    <th>2</th>
    <td>SP</td>
    <td>!</td>
    <td>&quot;</td>
    <td>#</td>
    <td>$</td>
    <td>%</td>
    <td>&amp;</td>
    <td>'</td>
    <td>(</td>
    <td>)</td>
    <td>*</td>
    <td>+</td>
    <td>,</td>
    <td>-</td>
    <td>.</td>
    <td>/</td>
  </tr>
  <tr>
    <th>3</th>
    <td><span class="lead-code">0</span></td>
    <td><span class="lead-code">1</span></td>
    <td><span class="lead-code">2</span></td>
    <td><span class="lead-code">3</span></td>
    <td><span class="lead-code">4</span></td>
    <td><span class="lead-code">5</span></td>
    <td><span class="lead-code">6</span></td>
    <td><span class="lead-code">7</span></td>
    <td><span class="lead-code">8</span></td>
    <td><span class="lead-code">9</span></td>
    <td>:</td>
    <td>;</td>
    <td>&lt;</td>
    <td>=</td>
    <td>&gt;</td>
    <td>?</td>
  </tr>
  <tr>
    <th>4</th>
    <td>@</td>
    <td><span class="lead-code">A</span></td>
    <td>B</td>
    <td>C</td>
    <td>D</td>
    <td>E</td>
    <td>F</td>
    <td>G</td>
    <td>H</td>
    <td>I</td>
    <td>J</td>
    <td>K</td>
    <td>L</td>
    <td>M</td>
    <td>N</td>
    <td>O</td>
  </tr>
  <tr>
    <th>5</th>
    <td>P</td>
    <td>Q</td>
    <td>R</td>
    <td>S</td>
    <td>T</td>
    <td>U</td>
    <td>V</td>
    <td>W</td>
    <td>X</td>
    <td>Y</td>
    <td>Z</td>
    <td>[</td>
    <td>\</td>
    <td>]</td>
    <td>^</td>
    <td>_</td>
  </tr>
  <tr>
    <th>6</th>
    <td>`</td>
    <td><span class="lead-code">a</span></td>
    <td>b</td>
    <td>c</td>
    <td>d</td>
    <td>e</td>
    <td>f</td>
    <td>g</td>
    <td>h</td>
    <td>i</td>
    <td>j</td>
    <td>k</td>
    <td>l</td>
    <td>m</td>
    <td>n</td>
    <td>o</td>
  </tr>
  <tr>
    <th>7</th>
    <td>p</td>
    <td>q</td>
    <td>r</td>
    <td>s</td>
    <td>t</td>
    <td>u</td>
    <td>v</td>
    <td>w</td>
    <td>x</td>
    <td>y</td>
    <td>z</td>
    <td>{</td>
    <td>|</td>
    <td>}</td>
    <td>~</td>
    <td class="tr-alt">&nbsp;</td>
  </tr>
</table>
<p>In Java, a <code>char</code> can be treated as its underlying integer in the range of <code>[0, 65535]</code> in arithmetic operations. In other words, <code>char</code> and integer are <em>interchangeable</em> in arithmetic operations. You can treat a <code>char</code> as an <code>int,</code> you can also assign an integer value in the range of <code>[0, 65535]</code> to a <code>char</code> variable. For example,</p>

<pre class="example">
char letter = 'a';                 <span class="comment">// Same as 97</span>
char anotherLetter = 98;           <span class="comment">// Same as the letter 'b'
                                   // You can assign an integer in the range of [0, 65535] to char</span>
System.out.println(letter);        <span class="comment">// 'a' printed</span>
System.out.println(anotherLetter); <span class="comment">// 'b' printed instead of the number, because the type is char</span>
anotherLetter += 2;                <span class="comment">// 100 or 'd'</span>
System.out.println(anotherLetter); <span class="comment">// 'd' printed</span></pre>


<p>Special characters are represented by so-called <em>escape sequence</em>, which begins with a back-slash (<code>\</code>) followed by a pattern, e.g., <code>\t</code> for tab, <code>\n</code> for newline. The commonly-used escape sequences are:</p>

<table class="table-zebra" style="width:80%">
  <tr>
    <th>Escape <br>
      Sequence</th>
    <th>Description</th>
    <th>Unicode<br>
      (Decimal)</th>
    <th>Unicode<br>
      (Hex)</th>
  </tr>
  <tr>
    <td class="lead-code text-center">\t</td>
    <td>Tab</td>
    <td class="text-center code">9</td>
    <td class="text-center code">0009H</td>
  </tr>
  <tr>
    <td class="lead-code text-center">\n</td>
    <td>Newline (or Line-feed)</td>
    <td class="text-center code">10</td>
    <td class="text-center code">000AH</td>
  </tr>
  <tr>
    <td class="lead-code text-center">\r</td>
    <td>Carriage-return</td>
    <td class="text-center code">13</td>
    <td class="text-center code">000DH</td>
  </tr>
  <tr>
    <td class="lead-code text-center">\&quot;</td>
    <td>Double-quote (Needed to be used inside double-quoted <code>String</code>)</td>
    <td class="text-center">-</td>
    <td class="text-center">-</td>
  </tr>
  <tr>
    <td class="lead-code text-center">\'</td>
    <td>Single-quote (Needed to be used inside single-quoted <code>char</code>, i.e., <code>'\''</code>)</td>
    <td class="text-center">-</td>
    <td class="text-center">-</td>
  </tr>
  <tr>
    <td class="lead-code text-center">\</td>
    <td>Back-slash (Needed as back-slash is given a special meaning)</td>
    <td class="text-center">-</td>
    <td class="text-center">-</td>
  </tr>
  <tr>
    <td class="lead-code text-center">\u<em>hhhh</em></td>
    <td>Unicode number <code><em>hhhh</em></code> (in hex), 
    e.g., <code>\u60a8</code> is 您, <code>\u597d</code> is 好</td>
    <td class="text-center">-</td>
    <td class="text-center code"><em>hhhh</em>H</td>
  </tr>
</table>

<p>For examples,</p>

<pre class="example">
char tabChar = '\t';          <span class="comment">// tab</span>
char anotherTabChar = 9;      <span class="comment">// Code number 9 is tab</span>
char newlineChar = '\n';      <span class="comment">// newline, code number 10</span>
char backSlashChar = '\\';    <span class="comment">// Since back-slash is given a special meaning,
                              // to write a back-slash, use double back-slash</span>
char singleQuoteChar = '\'';  <span class="comment">// Need to use escape sequence to resolve conflict</span>
char doubleQuoteChar = '&quot;';   <span class="comment">// No conflict. No need for escape sequence</span>
System.out.println(&quot;A tab &quot; + tabChar + &quot; before this; end with two newlines!&quot; + newlineChar + newlineChar);</pre>

<h5><code>String</code> Literals and Escape Sequences</h5>

<p>A <code>String</code> is a sequence of characters. A <code>String</code> literal is composed of zero of more characters surrounded by a pair of <em>double quotes</em>. For examples,</p>

<pre class="example">
String directionMsg = &quot;Turn Right&quot;;
String greetingMsg = &quot;Hello&quot;;
String statusMsg = &quot;&quot;;        <span class="comment">// An empty string</span></pre>

<p>You need to use an escape sequence for special  non-printable characters, such as newline (<code>\n</code>) and tab (<code>\t</code>). You also need to use escape sequence for double-quote (<code>\&quot;</code>) and backslash (<code>\\</code>) due to conflict. For examples,</p>

<pre class="example">
String str1 = &quot;hello<span class="new">\t</span>world<span class="new">\n</span>&quot;;    <span class="comment">// tab and newline</span>
String str2 = &quot;a double quoted <span class="new">\&quot;</span>hello<span class="new">\&quot;</span>&quot;;
String str3 = &quot;1 back-slash <span class="new">\\</span>, another 2 back-slashes <span class="new">\\\\</span>&quot;;
String str1 = &quot;A <span class="new">\&quot;</span>string<span class="new">\&quot;</span> nested <span class="new">\\</span>inside<span class="new">\\</span> a string&quot;   <span class="comment">// A &quot;string&quot; nested \inside\ a string</span>
String str2 = &quot;Hello, <span class="new">\u60a8\u597d</span>!&quot;   <span class="comment">// &quot;Hello, 您好!&quot;</span></pre>

<p>Single-quote (<code>'</code>) inside a <code>String</code> does not require an escape sequence because there is no ambiguity, e.g.,</p>

<pre class="example">
String str3 = &quot;Hi, I'm a string!&quot;      <span class="comment">// Single quote OK</span></pre>

<p>It is important to take note that <code>\t</code> or <code>\&quot;</code> is ONE single character, NOT TWO!</p>

<p><span class="lead">Exercise:</span> Write a program to print the following animal picture using <code>System.out.println()</code>. Take note that you need to use escape sequences to print some characters, e.g., <code>\&quot;</code> for <code>&quot;</code>, <code>\\</code> for <code>\</code>.</p>

<pre class="output">
          '__'
          (oo)
  +========\/
 / || %%% ||
*  ||-----||
   &quot;&quot;     &quot;&quot;</pre>

<h5>End-of-Line (EOL)</h5>

<p>Newline (<code>0AH</code>) and Carriage-Return (<code>0DH</code>), represented by the escape sequence <code>\n</code>, and <code>\r</code> respectively, are used as <em>line delimiter</em> (or <em>end-of-line</em>, or <em>EOL</em>) for text files. Take note that Unix and macOS use <code>\n</code> (<code>0AH</code>) as EOL, while Windows use <code>\r\n</code> (<code>0D0AH</code>).</p>

 

<h5><code>boolean</code> Literals</h5>

<p>There are only two <code>boolean</code> literals, i.e., <code>true</code> and <code>false</code>. For example,</p>

<pre class="example">
boolean done = true;
boolean gameOver = false;

boolean isValid;
isValid = false;</pre> 

<h5>Example on Literals</h5>

<pre class="example">
<span class="comment">/**
 * Test literals for various primitive types
 */</span>
public class <strong>LiteralTest</strong> {
   public static void main(String[] args) {
      String name = &quot;Tan Ah Teck&quot;; <span class="comment">// String is double-quoted</span>
      char gender = 'm';           <span class="comment">// char is single-quoted</span>
      boolean isMarried = true;    <span class="comment">// boolean of either true or false</span>
      byte numChildren = 8;        <span class="comment">// Range of byte is [-127, 128]</span>
      short yearOfBirth = 1945;    <span class="comment">// Range of short is [-32767, 32768]. Beyond byte</span>
      int salary = 88000;          <span class="comment">// Beyond the ranges of byte and short</span>
      long netAsset = 8234567890L; <span class="comment">// Need suffix 'L' for long. Beyond int</span>
      double weight = 88.88;       <span class="comment">// With fractional part</span>
      float gpa = 3.88f;           <span class="comment">// Need suffix 'f' for float</span>

      <span class="comment">// println() can be used to print value of any type</span>
      System.out.println(&quot;Name is: &quot; + name);
      <span class="comment">//</span><span class="output">Name is: Tan Ah Teck</span>
      System.out.println(&quot;Gender is: &quot; + gender);
      <span class="comment">//<span class="output">Gender is: m</span></span>
      System.out.println(&quot;Is married is: &quot; + isMarried);
      <span class="comment">//<span class="output">Is married is: true</span></span>
      System.out.println(&quot;Number of children is: &quot; + numChildren);
      <span class="comment">//<span class="output">Number of children is: 8</span></span>
      System.out.println(&quot;Year of birth is: &quot; + yearOfBirth);
      <span class="comment">//<span class="output">Year of birth is: 1945</span></span>
      System.out.println(&quot;Salary is: &quot; + salary);
      <span class="comment">//<span class="output">Salary is: 88000</span></span>
      System.out.println(&quot;Net Asset is: &quot; + netAsset);
      <span class="comment">//<span class="output">Net Asset is: 8234567890</span></span>
      System.out.println(&quot;Weight is: &quot; + weight);
      <span class="comment">//<span class="output">Weight is: 88.88</span></span>
      System.out.println(&quot;GPA is: &quot; + gpa);
      <span class="comment">//<span class="output">GPA is: 3.88</span></span>
   }
}</pre>

<h4><code>var</code> - Local Variable Type Inference (JDK 10)</h4>
<p>JDK 10 introduces a new way to declare variables via a new keyword <code>var</code>, for examples,</p>
<pre class="example">
var v1 = 0;        <span class="comment">// type inferred to &quot;int&quot;</span>
var v2 = 0.0;      <span class="comment">// type inferred to &quot;double&quot;</span>
var v3 = 1.0f;     <span class="comment">// type inferred to &quot;float&quot;</span>
var v4 = '0';      <span class="comment">// type inferred to &quot;char&quot;</span>
var v5 = "hello";  <span class="comment">// type inferred to &quot;String&quot;</span>
<span class="comment">//<span class="error"></span></span><span class="error">var v6;</span>          <span class="comment">//</span><span class="error">compilation error: cannot use 'var' on variable without initializer</span></pre>

<p>Clearly, you need to initialize the variable, so that the compiler can infer its type.</p>

<h3>Basic Operations</h3>

<h4>Arithmetic Operators</h4>

<p>Java supports the following binary/unary arithmetic operations:</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Mode</th>
  <th>Usage</th>
  <th>Description</th>
  <th>Examples</th>
</tr>

<tr>
  <td class="lead-code text-center">+</td>
  <td>Binary<br>
    Unary</td>
  <td><code>x + y<br>
    +x
  </code></td>
  <td>Addition<br>
  Unary positive</td>
  <td><code>1 + 2 &rArr; 3<br>1.1 + 2.2 &rArr; 3.3</code></td>
</tr>

<tr>
  <td class="lead-code text-center">-</td>
  <td>Binary<br>
    Unary</td>
  <td><code>x - y<br>
-x</code></td>
  <td>Subtraction<br  />
  Unary negate</td>
  <td><code>1 - 2 &rArr; -1<br>1.1 - 2.2 &rArr; -1.1</code></td>
</tr>

<tr>
  <td class="lead-code text-center">*</td>
  <td>Binary</td>
  <td><code>x * y</code></td>
  <td>Multiplication</td>
  <td><code>2 * 3 &rArr; 6<br>3.3 * 1.0 &rArr; 3.3</code></td>
</tr>

<tr>
  <td class="lead-code text-center">/</td>
  <td>Binary</td>
  <td><code>x / y</code></td>
  <td>Division</td>
  <td><span class="lead-code">1 / 2 &rArr; 0<br>1.0 / 2.0 &rArr; 0.5</span></td>
</tr>

<tr>
  <td class="lead-code text-center">%</td>
  <td>Binary</td>
  <td><code>x % y</code></td>
  <td>Modulus (Remainder)</td>
  <td><code>5 % 2 &rArr; 1<br> -5 % 2 &rArr; -1<br>5.5 % 2.2 &rArr; 1.1</code></td>
</tr>

</table>

<p>These operators are typically <em>binary infix</em> operators, i.e., they take two operands with the operator in between the operands (e.g., <code>11 + 12</code>). However, <code>'-'</code> and <code>'+'</code> can also be interpreted as <em>unary</em> &quot;negate&quot; and &quot;positive&quot; <em>prefix</em> operator, with the operator in front of the operand. For examples,</p>

<pre class="example">
int number = -9;
number = -number;      <span class="comment">// Unary negate</span>
</pre>

<h4>Arithmetic Expressions</h4>

<p>In programming, the following arithmetic expression:</p>

<img src="images/JavaBasics_ArithmeticExpression.png" alt="JavaBasics_ArithmeticExpression.png" width="282" height="46" class="image-left" />

<p>must be written as <code>(1+2*a)/3 + (4*(b+c)*(5-d-e))/f - 6*(7/g+h)</code>. You cannot omit the multiplication sign (<code>*</code>) as in Mathematics.</p>

<h5>Rules on Precedence</h5>
<p>Like Mathematics:</p>

<ol>
  <li>Parentheses <code>()</code> have the highest precedence and can be used to change the order of evaluation.</li>
  <li>Unary <code>'-'</code> (negate) and <code>'+'</code> (positive) have next higher precedence.</li>
  <li>The multiplication (<code>*</code>), division (<code>/</code>) and modulus (<code>%</code>) have the same precedence. They take precedence over addition (<code>+</code>) and subtraction (<code>-</code>). For example, <code>1+2*3-4/5+6%7</code> is interpreted as <code>1+(2*3)-(4/5)+(6%7)</code>.</li>
<li>Within the same precedence level (i.e., addition/subtraction and multiplication/division/modulus), the expression is evaluated from left to right (called <em>left-associative</em>). For examples, <code>1+2-3+4</code> is evaluated as <code>((1+2)-3)+4</code>, and <code>1*2%3/4</code> is <code>((1*2)%3)/4</code>.</li>
</ol>

<h4>Type Conversion in Arithmetic Operations</h4>

<p>Your program typically contains data of many types, e.g., <code>count</code> and <code>sum</code> are <code>int</code>, <code>average</code> and <code>gpa</code> are <code>double</code>, and <code>message</code> is a <code>String</code>. Hence, it is important to understand how Java handles types in your programs.</p>

<p>The arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) are only applicable to <em>primitive number types</em>: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, and <code>char</code>.<code> </code>They are not applicable to <code>boolean</code>.</p>

<h5>Same-Type Operands of <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code></h5>
<p>If BOTH operands are <code>int</code>, <code>long</code>, <code>float</code> or <code>double</code>, the binary arithmetic operations are carried in that type, and evaluate to a value of that type, i.e.,</p>
<ul>
<li><code>int &oplus; int  &rArr; int</code>, where <code>&oplus;</code> denotes a binary arithmetic operators such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>.</li>
<li><code>long  &oplus; long  &rArr; long</code></li>
<li><code>float  &oplus; float  &rArr; float</code></li>
<li><code>double  &oplus; double  &rArr; double</code></li>
</ul>

<h5><code>int</code> Division</h5>

<p>It is important to take note <code>int</code> division produces an <code>int</code>, i.e., <code>int / int &rArr;</code><code> int</code>, with the result <em>truncated</em>. For example, <code>1/2 &rArr; 0</code> (<code>int</code>), but <code>1.0/2.0 &rArr; 0.5</code> (<code>double / double &rArr; double</code>).</p>

<h5>Same-Type Operands of <code>byte</code>, <code>short</code>, <code>char</code>: Convert to <code>int</code></h5>

<p>If BOTH operands are <code>byte</code>, <code>short</code> or <code>char</code>, the binary operations are carried out in <code>int</code>, and evaluate to a value of <code>int</code>. A <code>char</code> is treated as an integer of its underlying Unicode number in the range of <code>[0, 65535]</code>. That is,</p>
<ul>
<li><code>byte  &oplus; byte  &rArr; int  &oplus; int  &rArr; int</code>, where <code>&oplus;</code> denotes a binary arithmetic operators such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>.</li>
<li><code>short  &oplus; short  &rArr; int  &oplus; int  &rArr; int</code></li>
<li><code>char  &oplus; char  &rArr; int  &oplus; int  &rArr; int</code></li>
</ul>

<p>Take note that NO arithmetic operations are carried out in <code>byte</code>, <code>short</code> or <code>char</code>.</p>
<p>For examples,</p>

<pre class="example">
byte b1 = 5, b2 = 9, b3;
<span class="comment">// byte + byte -&gt; int + int -&gt; int</span>
<span class="error">b3 = b1 + b2;</span>           <span class="comment">// error: RHS is &quot;int&quot;, cannot assign to LHS of &quot;byte&quot;</span>
b3 = (byte)(b1 + b2);   <span class="comment">// Need explicit type casting (to be discussed later)</span></pre>

<p>However, if compound arithmetic operators (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>) (to be discussed later) are used, the result is automatically converted to the LHS. For example,</p>

<pre class="example">
byte b1 = 5, b2 = 9;
b2 += b1;     <span class="comment">// Result in &quot;int&quot;, but automatically converted back to &quot;byte&quot;</span></pre>

<h5>Mixed-Type Arithmetic Operations</h5>

<p>If the two operands belong to <em>different types</em>, the value of the <em>smaller</em> type is promoted automatically to the <em>larger</em> type (known as <em>implicit type-casting</em>). The operation is then carried out in the <em>larger</em> type, and evaluated to a value in the <em>larger</em> type.</p>

<ul>
<li><code>byte</code>, <code>short</code> or <code>char</code> is first promoted to <code>int</code> before comparing with the type of the other operand. (In Java, no operations are carried out in <code>byte</code>, <code>short</code> or <code>char</code>.)</li>

<li>The order of promotion is: <code>int &rArr; long &rArr; float &rArr; double</code>.</li>
</ul>

<p>For examples,</p>

<ol>
<li><code>int / double &rArr; double / double &rArr; double</code>. Hence, <code>1/2 &rArr; 0, 1.0/2.0 &rArr; 0.5, 1.0/2 &rArr; 0.5, 1/2.0 &rArr; 0.5</code></li>

<li><code>9 / 5 * 20.1 &rArr; (9 / 5) * 20.1 &rArr; 1 * 20.1 &rArr; 1.0 * 20.1 &rArr; 20.1</code> (You probably don't expect this answer!)</li>
<li><code>char '0' + int 2 &rArr; int 48 + int 2 &rArr; int 50</code> (Result is an <code>int</code>, need to explicitly cast back to <code>char</code> <code>'2'</code> if desired.)</li>
<li><code>char &oplus; float &rArr; int &oplus; float &rArr; float &oplus; float &rArr; float</code></li>
<li><code>byte &oplus; double &rArr; int &oplus; double &rArr; double &oplus; double &rArr; double</code></li>
</ol>

<h5>Summary: Type-Conversion Rules for Binary Operations</h5>
<p>The type-promotion rules for <em>binary</em> operations can be summarized as follows:</p>

<ol>
<li>If one of the operand is <code>double</code>, the other operand is promoted to <code>double</code>;</li>

<li>else if one of the operand is <code>float</code>, the other operand is promoted to <code>float</code>;</li>

<li>else if one of the operand is <code>long</code>, the other operand is promoted to <code>long</code>;</li>

<li>else both operands are promoted to <code>int</code>.</li>
</ol>

<h5>Summary: Type-Conversion Rules for Unary Operations</h5>

<p>The type-promotion rules for <em>unary</em> operations (e.g., negate <code>'-'</code>) can be summarized as follows:</p>

<ol>
<li>If the operand is <code>double</code>, <code>float</code>, <code>long</code> or <code>int</code>, there is no promotion;</li>

<li>else the operand is <code>byte</code>, <code>short</code>, <code>char</code>, the operand is promoted to <code>int</code>.</li>
</ol>

<h4>More on Arithmetic Operators</h4>

<h5>Modulus (Remainder) Operator</h5>

<p>To evaluate the remainder for negative and floating-point operands, perform repeated subtraction until the <em>absolute</em> value of the remainder is less than the <em>absolute</em> value of the second operand.</p>

<p>For example,</p>

<ul>
<li><code>-5 % 2 &rArr; -3 % 2 &rArr; -1</code></li>
<li><code>5.5 % 2.2 &rArr; 3.3 % 2.2 &rArr; 1.1</code></li>
</ul>

<h5>Exponent?</h5>
<p>Java does not have an exponent operator. (The <code>^</code> operator denotes exclusive-or, NOT exponent). You need to use JDK method <code>Math.exp(x, y)</code> to evaluate <code>x</code> raises to power <code>y</code>; or write your own code.</p>

<h4>Overflow/Underflow</h4>

<p>Study the output of the following program:</p>

<pre class="example">
<span class="comment">/**
 * Illustrate &quot;int&quot; overflow
 */</span>
public class <strong>Overflow<strong>Test</strong></strong> {
   public static void main(String[] args) {
      <span class="comment">// Range of int is [-2147483648, 2147483647]</span>
      int i1 = 2147483647;        <span class="comment">// maximum int</span>
      System.out.println(i + 1);  <span class="comment">//<span class="output">-2147483648</span> (overflow)</span>
      System.out.println(i + 2);  <span class="comment">//<span class="output">-2147483647</span> (overflow)</span>
      System.out.println(i + 3);  <span class="comment">//<span class="output">-2147483646</span> (overflow)</span>
      System.out.println(i * 2);  <span class="comment">//<span class="output">-2</span> (overflow)</span>
      System.out.println(i * i);  <span class="comment">//<span class="output">1</span> (overflow)</span>
      
      int i2 = -2147483648;         <span class="comment">// minimum int</span>
      System.out.println(i2 - 1);   <span class="comment">//<span class="output">2147483647</span> (overflow)</span>
      System.out.println(i2 - 2);   <span class="comment">//<span class="output">2147483646</span></span><span class="comment"> (overflow)</span>
      System.out.println(i2 * i2);  <span class="comment">//<span class="output">0</span></span><span class="comment"> (overflow)</span>
   }
}</pre>

<p>In arithmetic operations, the resultant value <em>wraps around</em> if it exceeds its range (i.e., overflow). Java runtime does NOT issue an error/warning message but produces an <em>incorrect</em> result.</p>

<p>On the other hand, integer division produces a truncated integer and results in so-called <em>underflow</em>. For example, <code>1/2</code> gives <code>0</code>, instead of <code>0.5</code>. Again, Java runtime does NOT issue an error/warning message, but produces an <em>imprecise</em> result.</p>

<p>It is important to take note that <em>checking of overflow/underflow is the programmer's responsibility</em>. i.e., your job!!!</p>

<p>Why computer does not flag overflow/underflow as an error? This is due to the legacy design when the processors were very slow. Checking for overflow/underflow consumes computation power. Today, processors are fast. It is better to ask the computer to check for overflow/underflow (if you design a new language), because few humans expect such results.</p>

<p>To check for arithmetic overflow (known as <em>secure coding</em>) is tedious. Google for &quot;INT32-C. Ensure that operations on signed integers do not result in overflow&quot; @ www.securecoding.cert.org.</p>

<h4>More on Integer vs. Floating-Point Numbers</h4>
<p>Integers (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>) are precise (exact). But <code>float</code> and <code>double</code> are not precise but close approximation. Study the results of the following program:</p>
<pre class="example">
<span class="comment">/**
 * Test preciseness for int/float/double
 */</span>
public class <strong>TestPreciseness</strong> {
   public static void main(String[] args) {
      <span class="comment">// doubles are NOT precise</span>
      System.out.println(2.2 + 4.4);       <span class="comment">//</span><span class="output">6.6000000000000005</span>
      System.out.println(6.6 - 2.2 - 4.4); <span class="comment">//<span class="output">-8.881784197001252E-16</span> (NOT Zero!)</span>
      <span class="comment">// Compare two doubles</span>
      System.out.println((6.6) == (2.2 + 4.4));  <span class="comment">//<span class="output">false</span></span>
 
      <span class="comment">// int is precise, float/double are NOT!</span>
      int i1 = 123456789;
      System.out.println(i1*10); <span class="comment">//<span class="output">1234567890</span> (exact within the range)</span>

      float f1 = 123456789.0f;   <span class="comment">// float keeps 6-7 significant digits</span>
      System.out.println(f1);    <span class="comment">//<span class="output">1.23456792E8</span> (=1234567<span class="error">92</span> close but not exact)</span>
      System.out.println(f1*10); <span class="comment">//<span class="output">1.23456794E9</span> (=1234567<span class="error">940</span>)</span>
   }
}</pre>

<p>Always use <code>int</code> if you do not need the fractional part, although <code>double</code> can also represent <em>most</em> of the integers (e.g., <code>1.0</code>, <code>2.0</code>, <code>3.0</code>). This is because:</p>
<ul>
<li><code>int</code> is more efficient (faster) than <code>double</code> in arithmetic operations.</li>
<li>32-bit <code>int</code> takes less memory space than 64-bit <code>double</code>.</li>
<li><code>int</code> is exact (precise) in representing ALL integers within its range. <code>double</code> is an approximation - NOT ALL integer values can be represented by <code>double</code>.</li>
</ul>
<h4 id="typecasting">Type Casting</h4>

<p>In Java, you will get a compilation &quot;error: incompatible types: possible lossy conversion from <code>double|float|long</code> to <code>int</code>&quot; if you try to assign a <code>double</code>, <code>float</code>, or <code>long</code> value of to an <code>int</code> variable. This is because the fractional part would be truncated and lost. For example,</p>

<pre class="example">
<span class="comment">// Assign a &quot;double&quot; value to an &quot;int&quot; variable</span>
double d = 3.5;
<span class="error">int i = d;</span>        <span class="comment">//</span><span class="error">Compilation error: incompatible types: possible lossy conversion from double to int</span>
<span class="comment">
// Assign a &quot;float&quot; value to an &quot;int&quot; variable</span>
<span class="error">int sum = 55.66f;</span> <span class="comment">//</span><span class="error">Compilation error: incompatible types: possible lossy conversion from float to int</span>
<span class="comment">
// Assign a &quot;long&quot; value to an &quot;int&quot; variable</span>
long lg = 123;
<span class="error">int count = lg;</span>   <span class="comment">//</span><span class="error">Compilation error: incompatible types: possible lossy conversion from long to int</span></pre>

<h5>Explicit Type-Casting and Type-Casting Operator</h5>

<p>To assign the a <code>double</code> value to an <code>int</code> variable, you need to<em> </em>invoke the so-called <em>type-casting operator</em> - in the form of <code>(int)<em>doubleOperand</em></code> - to operate on the <code>double</code> operand and return a <em>truncated</em> value in <code>int</code>. In other words, you tell the compiler you consciously perform the truncation and you are fully aware of the &quot;possible lossy conversion&quot;. You can then assign the truncated <code>int</code> value to the <code>int</code> variable. For example,</p>

<pre class="example">
double d = 3.5;
int i;
i = (int)d;    <span class="comment">// Cast &quot;double&quot; value of 3.5 to &quot;int&quot; 3. Assign the resultant value 3 to i</span>
               <span class="comment">// Casting from &quot;double&quot; to &quot;int&quot; <em>truncates</em>.</span></pre>

<p>Type casting is an operation which takes one operand. It operates on its operand, and returns an equivalent value in the specified type. The syntax is:</p>
<pre class="syntax">
(<em>type</em>)<em>variable</em>    <span class="comment">// e.g., (int)height</span>
(<em>type</em>)<em>literal</em>     <span class="comment">// e.g., (int)55.66</span></pre>

<p>There are two kinds of type-casting in Java:</p>

<ol>
<li><strong>Explicit type-casting</strong> via a type-casting operator, as described above, and</li>

<li><strong>Implicit type-casting</strong> performed by the compiler automatically, if there is no  loss of precision.</li>
</ol>

<h5>Implicit Type-Casting in Assignment</h5>

<p>Explicit type-casting is not required if you assign an <code>int</code> value to a <code>double</code> variable, because there is no   loss of precision. The compiler will perform the type-casting automatically (i.e., implicit type-casting). For example,,</p>

<pre class="example">
int i = 3;
double d;
d = i;           <span class="comment">// OK, no explicit type casting required</span>
                 <span class="comment">// d = 3.0</span>
d = (double)i;   <span class="comment">// Explicit type casting operator used here</span>
double aDouble = 55;   <span class="comment">// Compiler auto-casts int 55 to double 55.0</span>
double nought = 0;     <span class="comment">// Compiler auto-casts int 0 to double 0.0
                       // int 0 and double 0.0 are different.</span></pre>

<p>The following diagram shows the order of implicit type-casting performed by compiler. The rule is to promote the smaller type to a bigger type to prevent loss of precision, known as widening conversion. Narrowing conversion requires explicit type-cast to inform the compiler that you are aware of the possible loss of precision. Take note that <code>char</code> is treated as an integer in the range of <code>[0, 65535]</code>. <code>boolean</code> value cannot be type-casted (i.e., converted to non-<code>boolean</code>).</p>

<img src="images/JavaBasics_ImplicitTypeCastingPrimitives.png" alt="JavaBasics_ImplicitTypeCastingPrimitives.png" width="670" height="179" class="image-left" />

<p><span class="lead">Example</span>: Suppose that you want to find the average (in <code>double</code>) of the running integers from <code>1</code> and <code>100</code>. Study the following code:</p>


<pre class="example">
<span class="comment">/** Compute the average of running numbers 1 to 100 */</span>
public class <strong>Average1To100</strong> {
   public static void main(String[] args) {
      int sum = 0;
      double average;
      for (int number = 1; number &lt;= 100; ++number) {
         sum += number;     <span class="comment"> // Final sum is int 5050</span>
      }
      average = sum / 100;  <span class="comment"> // Won't work (average = 50.0 instead of 50.5)</span>
      System.out.println(&quot;Average is &quot; + average); <span class="comment"> //</span><span class="output">Average is 50.0</span>
   }
}</pre>


<p>The <code>average</code> of <code>50.0</code> is incorrect. This is because both the <code>sum</code> and <code>100</code> are <code>int</code>. The result of <code>int/int</code> is an <code>int</code>, which is then implicitly casted to <code>double</code> and assign to the <code>double</code> variable <code>average</code>.  To get the correct answer, you can do either:</p>

<pre class="example" >
average = (double)sum / 100;     <span class="comment">// Cast sum from int to double before division, double / int -&gt; double / double -&gt; double</span>
average = sum / (double)100;     <span class="comment">// Cast 100 from int to double before division, int / double -&gt; double / double -&gt; double</span>
average = sum / 100.0;           <span class="comment">// int / double -&gt; double / double -&gt; double</span>
average = (double)(sum / 100);   <span class="comment">// Won't work. why?</span></pre>

<h4>Compound Assignment Operators</h4>

<p>Besides the usual simple assignment operator (<code>=</code>) described earlier, Java also provides the so-called <em>compound assignment operator</em>s as listed:</p>

<table class="table-zebra">
<tr>
  <th>Operation</th>
  <th>Mode</th>
  <th>Usage</th>
  <th>Description</th>
  <th>Example</th>
  </tr>
<tr>
  <td class="lead-code text-center">=</td>
  <td>Binary</td>
  <td><code><em>var</em> = <em>expr</em></code></td>
  <td>Assignment<br>
    Assign the LHS value to the RHS variable</td>
  <td><code>x = 5;</code></td>
  </tr>
<tr>
  <td class="lead-code text-center">+=</td>
  <td>Binary</td>
  <td><code><em>var</em> += <em>expr</em></code><br>
    same as:<code> <em>var</em> = <em>var</em> + <em>expr</em></code></td>
  <td>Compound addition and assignment</td>
  <td><code>x += 5;</code><br>
  same as: <code>x = x + 5</code></td>
  </tr>
<tr>
  <td class="lead-code text-center">-=</td>
  <td>Binary</td>
  <td><code><em>var</em> -= <em>expr</em></code><br>
    same as:<code> <em>var</em> = <em>var</em> - <em>expr</em></code></td>
  <td>Compound subtraction and assignment</td>
  <td><code>x -= 5;</code><br>
  same as: <code>x = x - 5</code></td>
  </tr>
<tr>
  <td class="lead-code text-center">*=</td>
  <td>Binary</td>
  <td><code><em>var</em> *= <em>expr</em></code><br>
    same as:<code> <em>var</em> = <em>var</em> * <em>expr</em></code></td>
  <td>Compound multiplication and assignment</td>
  <td><code>x *= 5;</code><br>
  same as: <code>x = x * 5</code></td>
  </tr>
<tr>
  <td class="lead-code text-center">/=</td>
  <td>Binary</td>
  <td><code><em>var</em> /= <em>expr</em></code><br>
    same as:<code> <em>var</em> = <em>var</em> / <em>expr</em></code></td>
  <td>Compound division and assignment</td>
  <td><code>x /= 5;</code><br>
  same as: <code>x = x / 5</code></td>
  </tr>
<tr>
  <td class="lead-code text-center">%=</td>
  <td>Binary</td>
  <td><code><em>var</em> %= <em>expr</em></code><br>
    same as:<code> <em>var</em> = <em>var</em> % <em>expr</em></code></td>
  <td>Compound modulus (remainder) and assignment</td>
  <td><code>x %= 5;</code><br>
  same as: <code>x = x % 5</code></td>
  </tr>
</table>

<p>One subtle difference between simple and compound operators is in <code>byte</code>, <code>short</code>, <code>char</code> binary operations. For examples,</p>
<pre class="example">
byte b1 = 5, b2 = 8, b3;
b3 = (byte)(b1 + b2);    <span class="comment">// byte + byte -&gt; int + int -&gt; int, need to explicitly cast back to &quot;byte&quot;</span>
<span class="error">b3 = b1 + b2;</span>            <span class="comment">// <span class="error">error: RHS is int, cannot assign to byte</span></span>
b1 += b2;                <span class="comment">// implicitly casted back to &quot;byte&quot;</span>

char c1 = '0', c2;
c2 = (char)(c1 + 2);     <span class="comment">// char + int -&gt; int + int -&gt; int, need to explicitly cast back to &quot;char&quot;</span>
<span class="error">c2 = c1 + 2;</span>             <span class="comment">// <span class="error">error: RHS is int, cannot assign to char</span></span>
c1 += 2;                 <span class="comment">// implicitly casted back to &quot;char&quot;</span></pre>

<h4>Increment/Decrement</h4>

<p>Java supports these <em>unary</em> arithmetic operators: increment (<code>++</code>) and decrement (<code>--</code>) for all primitive number types (<code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code> and <code>double</code>, except <code>boolean</code>). The increment/decrement unary operators can be placed before the operand (prefix), or after the operands (postfix). These operators were introduced in C++ to shorthand <code>x=x+1</code> to <code>x++</code> or <code>++x</code>.</p>
<table class="table-zebra">
<tr>
  <th>Operator</th>
  <th>Mode</th>
  <th>Usage</th>
  <th>Description</th>
  <th>Example</th>
  </tr>
<tr>
  <td class="text-center"><span class="lead-code">++</span><br>
    (Increment)
  </td>
  <td>Unary Prefix<br>
    Unary Postfix</td>
  <td><code>++x<br>
x++</code></td>
  <td>Increment the value of the operand by 1.<br>
    <code>x++ </code>or<code> ++x </code>is the same as<code> x += 1 </code>or<code> x = x + 1</code></td>
  <td><code>int x = 5;<br>
  x++; <span class="comment">// x is 6</span><br>
  ++x; <span class="comment">// x is 7</span></code></td>
  </tr>
<tr>
  <td class="text-center"><span class="lead-code">--</span><br>
    (Decrement)
  </td>
  <td>Unary Prefix<br>
Unary Postfix</td>
  <td><code>--x<br>
x--</code></td>
  <td>Decrement the value of the operand by 1.<br>
    <code>x-- </code>or<code> --x </code>is the same as<code> x -= 1 </code>or<code> x = x - 1</code></td>
  <td><code>int y = 6;<br>
  y--; <span class="comment">// y is 5</span><br>
  --y; <span class="comment">// y is 4</span></code></td>
  </tr>
</table>

<p>The increment (<code>++</code>) and decrement (<code>--</code>) operate on its sole operand and store the result back to its operand. For example, <code>++x</code> retrieves x, increment and stores the result back to x.</p>

<p>In Java, there are 4 ways to increment/decrement a variable:</p>
<pre class="example">int x = 5;
<span class="comment">// 4 ways to increment by 1</span>
x = x + 1;  <span class="comment">// x is 6</span>
x += 1;     <span class="comment">// x is 7</span>
x++;        <span class="comment">// x is 8</span>
++x;        <span class="comment">// x is 9</span>
<span class="comment">// 4 ways to decrement by 1</span>
x = x - 1;  <span class="comment">// x is 8</span>
x -= 1;     <span class="comment">// x is 7</span>
x--;        <span class="comment">// x is 6</span>
--x;        <span class="comment">// x is 5</span></pre>

<p>Unlike other unary operator (such as negate (<code>-</code>)) which promotes <code>byte</code>, <code>short</code> and <code>char</code> to <code>int</code>,  the increment and decrement do not promote its operand because there is no such need.</p>

<p>The increment/decrement unary operator can be placed before the operand (prefix), or after the operands (postfix), which may affect the outcome.</p>

<ul>
<li>If these operators are used by themselves (standalone) in a statement (e.g., <code>x++</code>; or <code>++x;</code>), the outcomes are the SAME for pre- and post-operators. See above examples.</li>

<li>If <code>++</code> or <code>--</code> involves another operation in the SAME statement, e.g., <code>y = x++;</code> or <code>y = ++x;</code> where there are two operations in the same statement: assignment and increment, then pre- or post-order is important to specify the order of these two operations, as tabulated below:</li>
</ul>

<table class="table-zebra">
<tr>
  <th width="20%">Operator</th>
  <th width="40%">Description</th>
  <th width="20%">Example</th>
  <th width="20%">Same As</th>
  </tr>
<tr>
  <td class="text-center"><span class="lead-code">++var</span><br>(Pre-Increment)</td>
  <td>  Increment <em>var</em>, and return the incremented <em>var</em><br>for the other operation in the same statement.</td>
  <td><code>y = ++x;</code></td>
  <td><code>x = x + 1;<br>
y = x;</code></td>
  </tr>
<tr>
  <td class="text-center"><span class="lead-code">var++</span><br>(Post-Increment)</td>
  <td>Return the old value of <em>var</em> for the other operation<br>
  in the same statement, then increment <em>var.</em></td>
  <td><code>y = x++;</code></td>
  <td><code>oldX = x; <br>
    x = x + 1; <br>
    y = oldX;</code></td>
  </tr>
<tr>
  <td class="text-center"><span class="lead-code">--var</span><br>(Pre-Decrement)</td>
  <td>Decrement <em>var</em>, and return the decremented <em>var</em><br>
	  for the other operation in the same statement.</td>
  <td><code>y = --x;</code></td>
  <td><code>x = x - 1; <br>
    y = x;</code></td>
  </tr>
<tr>
  <td class="text-center"><span class="lead-code">var--</span><br>(Post-Decrement)</td>
  <td>Return the old value of <em>var</em> for the other operation<br>
	  in the same statement, then decrement <em>var.</em></td>
  <td><code>y = x--;</code></td>
  <td><code>oldX = x; <br>
    x = x - 1; <br>
    y = oldX;</code></td>
  </tr>
</table>

<p>For examples,</p>

<pre class="example">
<span class="comment">// Two operations in the statement: increment and assignment</span>
x = 5;
y = ++x;   <span class="comment">// Increment x (=6), then assign x to y (=6). (++x returns x+1)</span>
x = 5;
y = x++;   <span class="comment">// Assign x to y (=5), then increment x (=6). (x++ returns the oldX)</span>
<span class="comment">// After the operations, x gets the SAME value, but the other operation has different outcomes</span>

<span class="comment">// Two operations in the statement: increment and println()</span>
x = 5;
System.out.println(++x);  <span class="comment">// Increment x (=6), then print x (=6). (++x returns x+1)</span>
x = 5;
System.out.println(x++);  <span class="comment">// Print x (=5), then increment x (=6). (x++ returns the oldX)</span>
</pre>


<p>Notes:</p>
<ul>
<li>Prefix operator (e.g., <code>++i</code>) could be more efficient than postfix operator (e.g., <code>i++</code>)?!</li>
<li>What is <code>i=i++</code>? Try it out!</li>
</ul>

<h4>Relational and Logical Operators</h4>
<p>Very often, you need to compare two values before deciding on the action to be taken, e.g. if mark is more than or equals to 50, print &quot;PASS!&quot;.</p>
<p>Java provides six <em>comparison operators</em> (or <em>relational operators</em>). All these operators are <em>binary</em> operators (that takes two operands) and return a <code>boolean</code> value of either <code>true</code> or <code>false</code>.</p>

<table class="table-zebra">
<tr>
  <th>Operator</th>
  <th>Mode</th>
  <th>Usage</th>
  <th>Description</th>
  <th>Example (x=5, y=8)</th>
</tr>
<tr>
  <td class="lead-code text-center">==</td>
  <td>Binary</td>
  <td><code>x == y</code></td>
  <td>Equal to</td>
  <td><code>(x == y) &rArr; false</code></td>  
</tr>

<tr>
  <td class="lead-code text-center">!=</td>
  <td>Binary</td>
  <td><code>x != y</code></td>
  <td>Not Equal to</td>
  <td><code>(x != y) &rArr; true</code></td>  
</tr>

<tr>
  <td class="lead-code text-center">&gt;</td>
  <td>Binary</td>
  <td><code>x &gt; y</code></td>
  <td>Greater than</td>
  <td><code>(x &gt; y) &rArr; false</code></td>  
</tr>

<tr>
  <td class="lead-code text-center">&gt;=</td>
  <td>Binary</td>
  <td><code>x &gt;= y</code></td>
  <td>Greater than or equal to</td>
  <td><code>(x &gt;= 5) &rArr; true</code></td>  
</tr>

<tr>
  <td class="lead-code text-center">&lt;</td>
  <td>Binary</td>
  <td><code>x &lt; y</code></td>
  <td>Less than</td>
  <td><code>(y &lt; 8) &rArr; false</code></td>  
</tr>

<tr>
  <td class="lead-code text-center">&lt;=</td>
  <td>Binary</td>
  <td><code>x &lt;= y</code></td>
  <td>Less than or equal to</td>
  <td><code>(y &lt;= 8) &rArr; true</code></td>  
</tr>
</table>

<p>Take note that the comparison operators are <em>binary infix</em> operators, that operate on two operands with the operator in between the operands, e.g., <code>x &lt;= 100</code>. It is invalid to write <code>1 &lt; x &lt; 100</code> (non-binary operations). Instead, you need to break out the two binary comparison operations <code>x &gt; 1</code>, <code>x &lt; 100</code>, and join with a logical AND operator, i.e., <code>(x &gt; 1) &amp;&amp; (x &lt; 100)</code>, where <code>&amp;&amp;</code> denotes AND operator.</p>
<p>Java provides four logical operators, which operate on <code>boolean</code> operands only, in descending order of precedence, as follows:</p>

<table class="table-zebra">
  <tr>
    <th>Operator</th>
    <th>Mode</th>
    <th>Usage</th>
    <th>Description</th>
    <th>Example</th>
    </tr>
  <tr>
    <td class="lead-code text-center">!</td>
    <td>Unary</td>
    <td><code>!x</code></td>
    <td>Logical NOT</td>
    <td>&nbsp;</td>
    </tr>
  <tr>
    <td class="lead-code text-center">&amp;&amp;</td>
    <td>Binary</td>
    <td><code>x &amp;&amp; y</code></td>
    <td>Logical AND</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td class="lead-code text-center">||</td>
    <td>Binary</td>
    <td><code>x || y</code></td>
    <td>Logical OR</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td class="lead-code text-center">^</td>
    <td>Binary</td>
    <td><code>x ^ y</code></td>
    <td>Logical Exclusive-OR (XOR)</td>
    <td>&nbsp;</td>
    </tr>
</table>

<p> The truth tables are as follows:</p>

<table class="table-zebra" style="width:30%">
<tr>
<th>NOT <code>(!)</code></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<td class="text-center">Result</td>
<td class="text-center">false</td>
<td class="text-center">true</td>
</tr>
</table>

<br>

<table class="table-zebra" style="width:30%">
<tr>
<th>AND <code>(&amp;&amp;)</code></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<th>true</th>
<td class="text-center">true</td>
<td class="text-center">false</td>
</tr>
<tr>
<th>false</th>
<td class="text-center">false</td>
<td class="text-center">false</td>
</tr>
</table>
<br>

<table class="table-zebra" style="width:30%">
<tr>
<th>OR <code>(||)</code></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<th>true</th>
<td class="text-center">true</td>
<td class="text-center">true</td>
</tr>
<tr>
<th>false</th>
<td class="text-center">true</td>
<td class="text-center">false</td>
</tr>
</table>

<br>

<table class="table-zebra" style="width:30%">
<tr>
<th>XOR <code>(^)</code></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<th>true</th>
<td class="text-center">false</td>
<td class="text-center">true</td>
</tr>
<tr>
<th>false</th>
<td class="text-center">true</td>
<td class="text-center"><span class="lead">false</span></td>
</tr>
</table>

<p><span class="lead">Examples:</span></p>

<pre class="example">
<span class="comment">// Return true if x is between 0 and 100 (inclusive)</span>
(x &gt;= 0) &amp;&amp; (x &lt;= 100)
<span class="comment">// wrong to use 0 &lt;= x &lt;= 100</span>
&nbsp; 
<span class="comment">// Return true if x is outside 0 and 100 (inclusive)</span>
(x &lt; 0) || (x &gt; 100)
<span class="comment">// or</span>
!((x &gt;= 0) &amp;&amp; (x &lt;= 100))
&nbsp;
<span class="comment">// Return true if year is a leap year</span>
<span class="comment">// A year is a leap year if it is divisible by 4 but not by 100, or it is divisible by 400.</span>
((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)</pre>

<p><span class="lead">Exercise:</span> Study the following program, and explain its output.</p>
<pre class="example">
<span class="comment">/**
 * Test relational and logical operators
 */</span>
public class <span class="new">RelationalLogicalOpTest</span> {
   public static void main(String[] args) {
      int age = 18;
      double weight = 71.23;
      int height = 191;
      boolean married = false;
      boolean attached = false;
      char gender = 'm';
      
      System.out.println(!married &amp;&amp; !attached &amp;&amp; (gender == 'm'));  <span class="comment">//<span class="output">true</span></span>
      System.out.println(married &amp;&amp; (gender == 'f'));  <span class="comment">//<span class="output">false</span></span>
      System.out.println((height &gt;= 180) &amp;&amp; (weight &gt;= 65) &amp;&amp; (weight &lt;= 80));  <span class="comment">//<span class="output">true</span></span>
      System.out.println((height &gt;= 180) || (weight &gt;= 90));  <span class="comment">//<span class="output">true</span></span>
   }
}</pre>

<p>Write an expression for all unmarried male, age between 21 and 35, with height above 180, and weight between 70 and 80.</p>

<p><span class="lead">Exercise:</span> Given the <code>year</code>, <code>month</code> (1-12), and <code>day</code> (1-31), write a <code>boolean</code> expression which returns <code>true</code> for dates before October 15, 1582 (Gregorian calendar cut-over date).</p>
<p>Ans: <code>(year &lt; 1582) || (year == 1582 &amp;&amp; month &lt; 10) || (year == 1582 &amp;&amp; month == 10 &amp;&amp; day &lt; 15)</code></p>

<h5>Equality Comparison <code>==</code></h5>

<p>You can use <code>==</code> to compare two integers (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>) and <code>char</code>. But do NOT use <code>==</code> to compare two floating-point numbers (<code>float</code> and <code>double</code>) because they are NOT precise. To compare floating-point numbers, set a threshold for their difference, e.g.,</p>
<pre class="example">
public class <span class="new">FloatComparisonTest</span> {
   public static void main(String[] args) {
      <span class="comment">// floating-point numbers are NOT precise</span>
      double d1 = 2.2 + 4.4;
      double d2 = 6.6;
      System.out.println(d1 == d2);  <span class="comment">//<span class="output">false</span></span>
      System.out.println(d1);        <span class="comment">//<span class="output">6.6000000000000005</span></span>

      <span class="comment">// Set a threshold for comparison with ==</span>
      <span class="new">final double EPSILON = 1e-7</span>;
      System.out.println(Math.abs(d1 - d2) &lt; EPSILON);  <span class="comment">//<span class="output">true</span></span>
   }
}</pre>

<p>You also CANNOT use <code>==</code> to compare two <code>String</code>s because <code>String</code>s are objects. You need to use <code>str1.equals(str2)</code> instead. This will be elaborated later.</p>

<h5>Logical Operator Precedence</h5>

<p>The precedence from highest to lowest is: <code>'!'</code> (unary), <code>'^'</code>, <code>'&amp;&amp;'</code>, <code>'||</code>'. But when in doubt, use parentheses!</p>

<pre class="example">
System.out.println(true || true &amp;&amp; false);    <span class="comment">//<span class="output">true</span> (same as below)</span>
System.out.println(true || (true &amp;&amp; false));  <span class="comment">//<span class="output">true</span></span>
System.out.println((true || true) &amp;&amp; false);  <span class="comment">//<span class="output">false</span></span>
 
System.out.println(false &amp;&amp; true ^ true);     <span class="comment">//<span class="output">false</span> (same as below)</span>
System.out.println(false &amp;&amp; (true ^ true));   <span class="comment">//<span class="output">false</span></span>
System.out.println((false &amp;&amp; true) ^ true);   <span class="comment">//<span class="output">true</span></span></pre>

<h5>Short-Circuit Operations</h5>

<p>The binary AND (<code>&amp;&amp;</code>) and OR (<code>||</code>) operators are known as short-circuit operators, meaning that the right-operand will not be evaluated if the result can be determined by the left-operand. For example, <code>false &amp;&amp; rightOperand </code>gives<code> false </code>and<code> true || rightOperand </code>give<code> true </code>without evaluating the right-operand. This may have adverse consequences if you rely on the right-operand to perform certain operations, e.g. <code>false &amp;&amp; (++i &lt; 5) </code>but<code> ++i </code> will not be evaluated.</p>

<h4><code>String</code> and <code>'+'</code> Concatenation Operator</h4>

<p>In Java, <code>'+'</code> is a special operator. It is <em>overloaded</em>. <em>Overloading</em> means that it carries out different operations depending on the <em>types</em> of its operands.</p>

<ul>
<li>If both operands are numeric (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>), <code>'+'</code> performs the usual <em>addition</em>. For examples,

  <pre class="example">
1 + 2 &rArr; 3   <span class="comment">// int + int &rArr; int</span>
1.2 + 2.2 &rArr; 3.4   <span class="comment">// double + double &rArr; double</span>
1 + 2.2 &rArr; 1.0 + 2.2 &rArr; 3.2  <span class="comment">// int + double &rArr; double + double &rArr; double</span>
'0' + 2 &rArr; 48 + 2 &rArr; 50   <span class="comment">// char + int &rArr; int + int &rArr; int (need to cast back to char '2')</span></pre>
</li>

<li>If both operands are <code>String</code>s, <code>'+'</code> <em>concatenates</em> the two <code>String</code>s and returns the concatenated <code>String</code>. For examples,

  <pre class="example">
&quot;Hello&quot; + &quot;world&quot; &rArr; &quot;Helloworld&quot;
&quot;Hi&quot; + &quot;, &quot; + &quot;world&quot; + &quot;!&quot; &rArr; &quot;Hi, world!&quot;</pre></li>

<li>If one of the operand is a <code>String</code> and the other is numeric, the numeric operand will be converted to <code>String</code> and the two <code>String</code>s concatenated, e.g.,

<pre class="example">
&quot;The number is &quot; + 5 &rArr; &quot;The number is &quot; + &quot;5&quot; &rArr; &quot;The number is 5&quot;
&quot;The average is &quot; + average + &quot;!&quot; (suppose average=5.5) &rArr; &quot;The average is &quot; + &quot;5.5&quot; + &quot;!&quot; &rArr; &quot;The average is 5.5!&quot;
&quot;How about &quot; + a + b (suppose a=1, b=1) &rArr; &quot;How about 1&quot; + b &rArr; &quot;How about 11&quot; (left-associative)
&quot;How about &quot; + (a + b) (suppose a=1, b=1) &rArr; &quot;How about &quot; + 2 &rArr; &quot;How about 2&quot;</pre>
</li>
</ul>

<p>We use <code>String</code> concatenation operator <code>'+'</code> frequently in the <code>print()</code> and <code>println()</code> to produce the desired output <code>String</code>. For examples,</p>

<pre class="example">
System.out.println(&quot;The sum is: &quot; + sum);   <span class="comment">// Value of &quot;sum&quot; converted to String and concatenated</span>
System.out.println(&quot;The square of &quot; + input + &quot; is &quot; + squareInput);</pre>

<h3>Flow Control</h3>

<p>There are three basic flow control constructs - <em>sequential</em>, <em>conditional</em> (or <em>decision</em>), and <em>loop</em> (or <em>iteration</em>), as illustrated below.</p>

<img src="images/Flowchart_FlowControl.png" alt="structure constructs" width="554" height="215" class="image-left" />

<h4>Sequential Flow Control</h4>

<img class="image-float-right" src="images/flow_sequential.gif" alt="flow_sequential.gif"  />

<p>A program is a sequence of instructions executing one after another in a predictable manner. <em>Sequential</em> flow is the most common and straight-forward, where programming statements are executed in the order that they are written - from top to bottom in a sequential manner.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<h4>Conditional Flow Control</h4>

<p>There are a few types of conditionals, <em>if-then</em>, <em>if-then-else</em>, <em>nested-if</em>, <em>switch-case-default</em>, and <em>conditional expression</em>.</p>


<h5><code>if</code>-then and <code>if</code>-then-<code>else</code></h5>

<table class="table-zebra code">
<tr>
<th>Syntax</th>
<th>Example</th>
<th>Flowchart</th>
</tr>

<tr>
<td><pre><span class="comment">// if-then</span>
<span class="highlight">if (</span><em>booleanTest</em><span class="highlight">) {</span>
   <em>trueBlock</em>;
<span class="highlight">}</span>
<span class="comment">// next statement</span></pre></td>
<td>
<pre>
int mark = 80;
if (mark &gt;= 80) {
   System.out.println(&quot;Well Done!&quot;);
   System.out.println(&quot;Keep it up!&quot;);
}
System.out.println(&quot;Life goes on!);

double temperature = 80.1;
if (temperature &gt; 80) {
   System.out.println(&quot;Too Hot!&quot;);
}
System.out.println(&quot;yummy!&quot;);</pre></td>
<td>
<img src="images/Flowchart_IfThen.png" alt="Flowchart_IfThen.png" width="170" height="172" />
</td>
</tr>
<tr>
<td><pre><span class="comment">// if-then-else</span>
<span class="highlight">if (</span><em>booleanTest</em><span class="highlight">) {</span>
   <em>trueBlock</em>;
<span class="highlight">} else {</span>
   <em>falseBlock</em>;
<span class="highlight">}</span>
<span class="comment">// next statement</span></pre>
</td>
<td>
<pre>
int mark = 50;     <span class="comment">// Assume that mark is [0, 100]</span>
if (mark &gt;= 50) {  <span class="comment">// [50, 100]</span>
   System.out.println(&quot;Congratulation!&quot;);
   System.out.println(&quot;Keep it up!&quot;);
} else {           <span class="comment">// [0, 49]</span>
   System.out.println(&quot;Try Harder!&quot;);
}
System.out.println(&quot;Life goes on!&quot;);

double temperature = 80.1;
if (temperature &gt; 80) {
   System.out.println(&quot;Too Hot!&quot;);
} else {
   System.out.println(&quot;Too Cold!&quot;);
}
System.out.println(&quot;yummy!&quot;);</pre></td>
<td>
<img src="images/Flowchart_IfElse.png" alt="Flowchart_IfElse.png" width="220" height="168" />
</td>
</tr>
</table>

<p><span class="lead">Braces:</span> You could omit the braces <code>{ }</code>, if there is only one statement inside the block. For example,</p>

<pre class="example">
<span class="comment">// if-then</span>
int absValue = -5;
if (absValue &lt; 0) absValue = -absValue;   <span class="comment">// Only one statement in the block, can omit { }</span>
 
int min = 0, value = -5;
if (value &lt; min) {     <span class="comment">// More than one statements in the block, need { }</span>
   min = value;
   System.out.println(&quot;Found new min&quot;);
}
 
<span class="comment">// if-then-else</span>
int mark = 50;
if (mark &gt;= 50) 
   System.out.println(&quot;PASS&quot;);   <span class="comment">// Only one statement in the block, can omit { }</span>
else {                           <span class="comment">// More than one statements in the block, need { }</span>
   System.out.println(&quot;FAIL&quot;);
   System.out.println(&quot;Try Harder!&quot;);
}

<span class="comment">// Harder to read without the braces</span>
int number1 = 8, number2 = 9, absDiff;
if (number1 &gt; number2) absDiff = number1 - number2;
else absDiff = number2 - number1;</pre>

<p>However, I recommend that you keep the braces to improve the readability of your program, even if there is only one statement in the block.</p>

<h5>Nested-<code>if</code></h5>
<table class="table-zebra code">
<tr>
<th>Syntax</th>
<th>Example</th>
<th>Flowchart</th>
</tr>

<tr>
<td><pre><span class="comment">// nested-if</span>
<span class="highlight">if (</span><em>booleanTest1</em><span class="highlight">) {</span>
   <em>block1</em>;
<span class="highlight">} else if (</span><em>booleanTest2</em><span class="highlight">) {</span>
   <em>block2</em>;
<span class="highlight">} else if (</span><em>booleanTest3</em><span class="highlight">) {</span>
   <em>block3</em>;
<span class="highlight">} else if (</span><em>booleanTest4</em><span class="highlight">) {</span>
   ......
<span class="highlight">} else {</span>
   <em>elseBlock</em>;
<span class="highlight">}</span>
<span class="comment">// next statement</span></pre></td>

<td><pre>
int mark = 62;  <span class="comment">// Assume that mark is [0, 100]</span>
if (mark &gt;= 80) {           <span class="comment">// [80, 100]</span>
   System.out.println(&quot;A&quot;);
} else if (mark &gt;= 65) {    <span class="comment">// [65, 79]</span>
   System.out.println(&quot;B&quot;);
} else if (mark &gt;= 50) {    <span class="comment">// [50, 64]</span>
   System.out.println(&quot;C&quot;);
} else {                    <span class="comment">// [0, 49]</span>
   System.out.println(&quot;F&quot;);
}
System.out.println(&quot;Life goes on!&quot;);

double temperature = 61;
if (temperature &gt; 80) {        <span class="comment">// &gt; 80</span>
   System.out.println(&quot;Too Hot!&quot;);
} else if (temperature &gt; 75) { <span class="comment">// (75, 80]</span>
   System.out.println(&quot;Just right!&quot;);
} else {                       <span class="comment">// &lt;= 75</span>
   System.out.println(&quot;Too Cold!&quot;);
}
System.out.println(&quot;yummy!&quot;);</pre></td>
    <td><img src="images/Flowchart_NestedIf.png" alt="Flowchart_NestedIf.png" width="339" height="256" /></td>
  </tr>
</table>

<p>Java does not provide a separate syntax for nested-if (e.g., with keywords like <code>eif</code>, <code>elseif</code>), but supports nested-if with nested if-else statements, which is interpreted as below. Take note that you need to put a space between <code>else</code> and <code>if</code>. Writing <code>elseif</code> causes a syntax error.</p>

<pre class="syntax">
if ( <em>booleanTest1</em> ) {
   <em>block1</em>;
} else {   <span class="comment">// This else-block contains a if-else statement</span>
   if ( <em>booleanTest2</em> ) {
      <em>block2</em>;
   } else {  <span class="comment">// This else-block also contains a if-else statement</span>
      if (<em>booleanTest3</em>) {
         <em>block3</em>;
      } else {  <span class="comment">// This else-block also contains a if-else statement</span>
         if ( <em>booleanTest4</em> ) {
            ......
         } else {
   <em>         elseBlock</em>;
         }
      }
   }
}
<span class="comment">// This alignment is hard to read!</span></pre>
<img src="images/Flowchart_NestedIf_Interpretation.png" alt="Flowchart_NestedIf_Interpretation" width="394" height="278" class="image-left"  />

<p>However, for readability, it is recommended to align the nest-if statement as written in the syntax/examples.</p>

<p>Take note that the blocks are exclusive in a nested-if statement; only one of the blocks will be executed. Also, there are two ways of writing nested-if, for example,</p>

<pre class="example">
<span class="comment">// Assume that mark is [0, 100]</span>
if (mark &gt;= 80) {           <span class="comment">// [80, 100]</span>
   System.out.println(&quot;A&quot;);
} else if (mark &gt;= 65) {    <span class="comment">// [65, 79]</span>
   System.out.println(&quot;B&quot;);
} else if (mark &gt;= 50) {    <span class="comment">// [50, 64]</span>
   System.out.println(&quot;C&quot;);
} else {                    <span class="comment">// [0, 49]</span>
   System.out.println(&quot;F&quot;);
}
<span class="comment">// OR</span>
if (mark &lt; 50) {            <span class="comment">// [0, 49]</span>
   System.out.println(&quot;F&quot;);
} else if (mark &lt; 65) {     <span class="comment">// [50, 64]</span>
   System.out.println(&quot;C&quot;);
} else if (mark &lt; 80) {     <span class="comment">// [65, 79]</span>
   System.out.println(&quot;B&quot;);
} else {                    <span class="comment">// [80, 100]</span>
   System.out.println(&quot;A&quot;);
}</pre>

<h5>Dangling-<code>else</code> Problem</h5>
<p>The &quot;dangling-<code>else</code>&quot; problem can be illustrated as follows:</p>

<pre class="example">
int i = 0, j = 0;
if (i == 0)       <span class="comment">// outer-if</span>
   if (j == 0)    <span class="comment">// inner-if</span>
      System.out.println(&quot;i and j are zero&quot;);
else System.out.println(&quot;xxx&quot;);   <span class="comment">// This else can pair with the inner-if and outer-if?!</span></pre>

<p>The <code>else</code> clause in the above code is syntactically applicable to both the outer-<code>if</code> and the inner-<code>if</code>, causing the dangling-<code>else</code> problem.</p>
<p>Java compiler resolves the dangling-<code>else</code> problem by associating the <code>else</code> clause with the <em>innermost</em>-<code>if</code> (i.e., the <em>nearest</em>-<code>if</code>). Hence, the above code shall be interpreted as:</p>

<pre class="example">
int i = 0, j = 0;
if (i == 0)
   if (j == 0)
      System.out.println(&quot;i and j are zero&quot;);
   else    <span class="comment">// associated with if (j == 0) - the nearest if</span>
      System.out.println(&quot;xxx&quot;);</pre>

<p> Dangling-<code>else</code> can be prevented by applying explicit parentheses. For example, if you wish to associate the <code>else</code> clause with the outer-<code>if</code>, do this:</p>

<pre class="example">
<span class="comment">// Force the else-clause to associate with the outer-if with parentheses
</span>int i = 0, j = 0;
if (i == 0) {
   if (j == 0) 
      System.out.println(&quot;i and j are zero&quot;);
} else {
   System.out.println(&quot;i is not zero&quot;);   <span class="comment">// non-ambiguous for outer-if</span>
}

<span class="comment">// Force the else-clause to associate with the inner-if with parentheses</span>
int i = 0, j = 0;
if (i == 0) {
   if (j == 0) {
      System.out.println(&quot;i and j are zero&quot;);
   } else {
      System.out.println(&quot;i is zero, j is not zero&quot;);   <span class="comment">// non-ambiguous for inner-if</span>
   }
}</pre>


<h5>Nested-<code>if</code> vs. Sequential-<code>if</code></h5>

<p>Study the following code:</p>

<pre class="example">
<span class="comment">// Assume mark is between 0 and 100
// This &quot;sequential-if&quot; works but NOT efficient!
// Try mark = 81, which will run thru ALL the if's.</span>
int mark = 81;
if (mark &gt; 80) {  <span class="comment">// [81, 100]</span>
   grade = 'A';
}
if (mark &gt; 65 &amp;&amp; mark &lt;= 80) {  <span class="comment">// [66, 80]</span>
   grade = 'B';
}
if (mark &gt;= 50 &amp;&amp; mark &lt;= 65) {<span class="comment"> // [50, 65]</span>
   grade = 'C';
}
if (mark &lt; 50) {  <span class="comment">// [0, 49]</span>
   grade = 'F';
}

<span class="comment">// This &quot;nested-if&quot; is BETTER
// Try mark = 81, which only run thru only the first if.</span>
int mark = 81;
if (mark &gt; 80) {   <span class="comment">// [81, 100]</span>
   grade = 'A';
} else if (mark &gt; 65 &amp;&amp; mark &lt;= 80) {  <span class="comment">// [66, 80]</span>
   grade = 'B';
} else if (mark &gt;= 50 &amp;&amp; mark &lt;= 65) { <span class="comment">// [50, 65]</span>
   grade = 'C';
} else {
   grade = 'F';    <span class="comment">// [0, 49]</span>
}

<span class="comment">// This &quot;nested-if&quot; is the BEST with fewer tests</span>
int mark = 81;
if (mark &gt; 80) {         <span class="comment">// [81, 100]</span>
   grade = 'A';
} else if (mark &gt; 65) {  <span class="comment">// [66, 80]</span>
   grade = 'B';
} else if (mark &gt;= 50) { <span class="comment">// [50, 65]</span>
   grade = 'C';
} else {                 <span class="comment">// [0, 49]</span>
   grade = 'F';
}</pre>

<h5><code>switch-case-default</code></h5>

<table class="table-zebra code">
<tr>
<th>Syntax</th>
<th>Example</th>
<th>Flowchart</th>
</tr>

<tr>
<td><pre><span class="comment">// switch-case-default</span>
<span class="highlight">switch (</span><em>selector</em><span class="highlight">) {
   case</span> <em>value1</em><span class="highlight">:</span>
      <em>block1</em>; <span class="highlight">break;
   case</span> <em>value2</em><span class="highlight">:</span>
      <em>block2</em>; <span class="highlight">break;
   case</span> <em>value3</em><span class="highlight">:</span>
      <em>block3</em>; <span class="highlight">break;</span>
   ......
   <span class="highlight">case</span> <em>valueN</em><span class="highlight">:</span>
      <em>blockN</em>; <span class="highlight">break;</span>
   <span class="highlight">default:</span> <span class="comment">// not the above</span>
      <em>defaultBlock</em>;
<span class="highlight">}</span>
<span class="comment">// next statement</span>

<span class="comment">// Selector Types:
// byte, short, int,
// char, String</span></pre></td>
<td><pre>
<span class="comment">// Print number in word</span>
int number = 3;
switch (number) {   <span class="comment">// &quot;int&quot; selector</span>
   case 1:   <span class="comment">// &quot;int&quot; value</span>
      System.out.println(&quot;ONE&quot;); break;
   case 2:
      System.out.println(&quot;TWO&quot;); break;
   case 3:
      System.out.println(&quot;THREE&quot;); break;
   default:
      System.err.println(&quot;OTHER&quot;);
}

<span class="comment">// Select arithmetic operation</span>
char operator = '*';
int num1 = 5, num2 = 8, result;
switch (operator) {   <span class="comment">// &quot;char&quot; selector</span>
   case '+':   <span class="comment">// &quot;char&quot; value</span>
      result = num1 + num2; break;
   case '-': 
      result = num1 - num2; break;
   case '*': 
      result = num1 * num2; break;
   case '/': 
      result = num1 / num2; break;
   default:
      System.out.println(&quot;Unknown operator);
}</pre></td>
    <td><img src="images/Flowchart_SwitchCase.png" alt="Flowchart_SwitchCase.png" width="270" height="294" /></td>
  </tr>
</table>
<p>&quot;<code>switch-case-default</code>&quot; is an alternative to the &quot;nested-<code>if</code>&quot; for <em>fixed-value tests</em> (but not applicable for <em>range tests</em>). You can use an <code>int</code>, <code>byte</code>, <code>short</code>, or <code>char</code> variable as the <em>case-selector</em>, but NOT <code>long</code>, <code>float</code>, <code>double</code> and <code>boolean</code>. JDK 1.7 supports <code>String</code> as the case-selector.</p>
<p>In a <code>switch-case</code> statement, a <code>break</code> statement is needed for each of the cases. If <code>break</code> is missing, execution will flow through the following case, which is typically a mistake. However, we could use this property to handle multiple-value selector. For example,</p>
<pre class="example">
<span class="comment">// Converting Phone keypad letter to digit</span>
char inChar = 'x';
switch (inChar) {
   case 'a': case 'b': case 'c':   <span class="comment">// 'a' and 'b' (without break) fall thru 'c'</span>
      System.out.print(2); break;
   case 'd': case 'e': case 'f':
      System.out.print(3); break;
   case 'g': case 'h': case 'i':
      System.out.print(4); break;
   case 'j': case 'k': case 'l':
      System.out.print(5); break;
   ......
   default:
      System.out.println(&quot;Invalid Input&quot;);
}</pre>

<h5>Conditional Expression ( ... <code>?</code> ... <code>:</code> ... )</h5>

<p>A conditional operator is a ternary (3-operand) operator, in the form of <code><em>booleanExpr</em> ? <em>trueExpr</em> : <em>falseExpr</em></code>. Depending on the <code><em>booleanExpr</em></code>, it evaluates and returns the value of <em><code>trueExpr</code></em> or <code><em>falseExpr</em></code>.</p> 

<table class="table-zebra code">
<tr>
<th>Syntax</th>
<th>Examples</th>
</tr>

<tr>
<td>
<pre>
<span class="comment">// Conditional Expression</span>
<em>booleanExpr</em> <span class="highlight">?</span> <em>trueExpr</em> <span class="highlight">:</span> <em>falseExpr</em>
<span class="comment">  // An expression that returns
  // the value of <em>trueExpr</em>
  // or <em>falseExpr</em></span></pre>
</td>
<td>
<pre>
int num1 = 9, num2 = 8, max;
max = (num1 &gt; num2) ? num1 : num2;  <span class="comment">// RHS returns num1 or num2</span>
<span class="comment">// same as</span>
if (num1 &gt; num2) {
   max = num1;
} else {
   max = num2;
}

int value = -9, absValue;
absValue = (value &gt; 0) ? value : -value;  <span class="comment">// RHS returns value or -value</span>
<span class="comment">// same as</span>
if (value &gt; 0) absValue = value;
else absValue = -value;

int mark = 48;
System.out.println((mark &gt;= 50) ? &quot;PASS&quot; : &quot;FAIL&quot;);  <span class="comment">// Return &quot;PASS&quot; or &quot;FAIL&quot;</span>
<span class="comment">// same as</span>
if (mark &gt;= 50) System.out.println(&quot;PASS&quot;);
else System.out.println(&quot;FAIL&quot;);
</pre></td>
</tr>
</table>

<p>Conditional expression is a short-hand for <code>if-else</code>. But you should use it only for <em>one-liner</em>, for readability.</p>


<h4>Exercises on Getting Started and Conditional</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseGetStarted">LINK</a></p>



<h4>Loop Flow Control</h4>

<p>Again, there are a few types of loops: <em>for</em>, <em>while-do</em>, and <em>do-while</em>.</p>

<table class="table-zebra code">

<tr>
<th>Syntax</th>
<th>Example</th>
<th>Flowchart</th>
</tr>

<tr>
<td>
<pre>
<span class="comment">// while-do loop</span>
<span class="highlight">while (</span><em>booleanTest</em><span class="highlight">) {</span>
   <em>body</em>;
<span class="highlight">}</span>
<span class="comment">// next statement</span></pre>
</td>
<td>
<pre>
<span class="comment">// Sum from 1 to upperbound</span>
int sum = 0;
final int UPPERBOUND = 100;
int number = 1;   <span class="comment">// init</span>
while (number &lt;= UPPERBOUND) {
   <span class="comment">// number = 1, 2, 3, ..., UPPERBOUND
   //for each iteration</span>
   sum += number;
   ++number;      <span class="comment">// update</span>
}
System.out.println(&quot;sum is: &quot; + sum);

<span class="comment">// Factorial of n (=1*2*3*...*n)</span>
int n = 5;
int factorial = 1;
int number = 1;   <span class="comment">// init</span>
while (number &lt;= n) {
   <span class="comment">// num = 1, 2, 3, ..., n for each iteration</span>
   factorial *= number;
   ++num;      <span class="comment">// update</span>
}
System.out.println(&quot;factorial is: &quot; + factorial);</pre>
</td>
<td>
<img src="images/Flowchart_While.png" alt="Flowchart_While.png" width="202" height="139" />
</td>
</tr>
<tr>
<td>
<pre>
<span class="comment">// do-while loop</span>
<span class="highlight">do {</span>
   <em>body</em>;
<span class="highlight">} while (</span><em>booleanTest</em><span class="highlight">;</span>
<span class="comment">// next statement</span>
   <span class="comment">// Need a semi-colon to
   // terminate statement</span></pre>
</td>
<td>
<pre>
<span class="comment">// Sum from 1 to upperbound</span>
int sum = 0;
final int UPPERBOUND = 100;
int number = 1;   <span class="comment">// init</span>
do {
   <span class="comment">// number = 1, 2, 3, ..., UPPERBOUND
   // for each iteration</span>
   sum += number;
   ++number;      <span class="comment">// update</span>
} while (number &lt;= UPPERBOUND);
System.out.println(&quot;sum is: &quot; + sum);
 
<span class="comment">// Factorial of n (=1*2*3*...*n)</span>
int n = 5;
int factorial = 1;
int number = 1;   <span class="comment">// init</span>
do {
   <span class="comment">// num = 1, 2, 3, ..., n for each iteration</span>
   factorial *= number;
   ++number;      <span class="comment">// update</span>
} while (number &lt;= n);
System.out.println(&quot;factorial is: &quot; + factorial);</pre>
</td>
<td>
<img src="images/Flowchart_DoWhile.png" alt="Flowchart_DoWhile.png" width="158" height="171" />
</td>
</tr>

<tr>
<td><pre><span class="comment">// for-loop</span>
<span class="highlight">for (</span><em>init</em><span class="highlight">;</span> <em>booleanTest</em><span class="highlight">;</span> <em>update</em><span class="highlight">) {</span>
   <em>body</em>;
<span class="highlight">}</span>
<span class="comment">// next statement</span></pre>
</td>
<td>
<pre>
<span class="comment">// Sum from 1 to upperbound</span>
int sum = 0;
final int UPPERBOUND = 100;
for (int number = 1; number &lt;= UPPERBOUND; ++number) {
   <span class="comment">// num = 1, 2, 3, ..., UPPERBOUND</span>
   sum += number;
}
System.out.println(&quot;sum is: &quot; + sum);

<span class="comment">// Factorial of n (=1*2*3*...*n)</span>
int n = 5;
int factorial = 1;
for (int number = 1; number &lt;= n; ++number) {
   <span class="comment">// number = 1, 2, 3, ..., n</span>
   factorial *= number;
}
System.out.println(&quot;factorial is: &quot; + factorial);</pre>
</td>
<td>
<img src="images/Flowchart_For.png" alt="Flowchart_For.png" width="309" height="180" />
</td>
</tr>

</table>

<p>The difference between <em>while-do</em> and <em>do-while</em> lies in the order of the <em>body</em> and <em>test</em>. In <em>while-do</em>, the <em>test</em> is carried out first. The body will be executed if the <em>test</em> is true and the process repeats.  In <em>do-while</em>, the <em>body</em> is executed and then the<em> <code>test</code></em> is carried out. Take note that the <em>body</em> of <em>do-while</em> is executed at least once (1+); but the body of <em>while-do</em> is possibly zero (0+). Similarly, the for-loop's body could possibly not executed (0+).</p>
<p><em>For-loop</em> is a shorthand for <em>while-do</em> with fewer lines of code. It is the most commonly-used loop especially if the number of repetitions is known. But its syntax is harder to comprehend. Make sure that you understand for-loop by going through the flow-chart and examples.</p>

<h5>Loop's Index/Counter Variable</h5>
<p>A loop is typically controlled by an <em>index or counter</em> variable. For example,</p>
<pre class="example">
<span class="comment">// Sum from 1 to UPPERBOUND using for-loop</span>
int sum = 0
final int UPPERBOUND = 100;
for (int number = 1; number &lt;= UPPERBOUND; ++number) {  <span class="comment">// number = 1, 2, 3, ..., UPPERBOUND for each iteration</span>
   sum += num;
}

<span class="comment">// Sum from 1 to UPPERBOUND using while-loop</span>
int sum = 0
final int UPPERBOUND = 100;
int number = 1;
while (number &lt;= UPPERBOUND) {  <span class="comment">// number = 1, 2, 3, ..., UPPERBOUND for each iteration</span>
   sum += number;
   ++number;
}</pre>

<p>In the above examples, the variable <code>number</code> serves as the <em>index</em> variable, which takes on the values <code>1</code>, <code>2</code>, <code>3</code>, ..., <code>UPPERBOUND</code> for each iteration of the loop. You need to increase/decrease/modify the index variable explicitly (e.g., via <code>++number</code>). Otherwise, the loop becomes an endless loop, as the test <code>(number &lt;= UPPERBOUND)</code> will return the same outcome for the same value of <code>number</code>.</p>
<p>Observe that for-loop is a shorthand of while-loop. Both the for-loop and  while-loop have the same set of statements, but for-loop re-arranges the statements.</p>
<p>For the <code>for</code>-loop, the index variable <code>number</code> is declared inside the loop, and therefore is only available inside the loop. You cannot access the variable after the loop, as It is destroyed after the loop. On the other hand, for the <code>while</code>-loop, the index variable <code>number</code> is available inside and outside the loop.</p>
<p>For the <code>for</code>-loop, you can choose to declare the index variable inside the loop or outside the loop. We recommend that you declare it inside the loop, to keep the life-span of this variable to where it is needed, and not any longer.</p>

<p>[TODO] Animated GIF??</p>

<h5>Code Example: Sum and Average of Running Integers</h5>

<p>The following program sums the running integers from a given lowerbound to an upperbound. Also compute their average.</p>

<pre class="example">
<span class="comment">/**
 * Sum the running integers from lowerbound to an upperbound.
 * Also compute the average.
 */</span>
public class <strong>SumAverageRunningNumbers</strong> {
   public static void main(String[] args) {
      <span class="comment">// Declare variables</span>
      int sum = 0;       <span class="comment">// store the accumulated sum</span>
      final int LOWERBOUND = 1;
      final int UPPERBOUND = 1000;
      double average;

      <span class="comment">// Use a for-loop to accumulate the sum</span>
      for (int number = LOWERBOUND; number &lt;= UPPERBOUND; ++number) {
         <span class="comment">// number = LOWERBOUND, LOWERBOUND+1, LOWERBOUND+2, ..., UPPERBOUND for each iteration</span>
         sum += number;
      }
      average = (double)sum / (UPPERBOUND - LOWERBOUND + 1);   <span class="comment">// need to cast int to double first</span>
      <span class="comment">// Print results</span>
      System.out.println("The sum from &quot; + LOWERBOUND + &quot; to &quot; + UPPERBOUND + &quot; is: " + sum);
      <span class="comment">//<span class="output">The sum from 1 to 1000 is: 500500</span></span>
      System.out.println("The average is: " + average);
      <span class="comment">//<span class="output">The average is: 500.5</span></span>

      <span class="comment">// Sum only the ODD numbers</span>
      int count = 0;     <span class="comment">// counts of odd numbers</span>
      sum = 0;           <span class="comment">// reset sum for accumulation again</span>
      <span class="comment">// Adjust the LOWERBOUND to the next odd number if it is a even number</span>
      final int ADJUSTED_LOWERBOUND = LOWERBOUND % 2 == 0 ? LOWERBOUND+1 : LOWERBOUND;
      <span class="comment">// Use a for-loop to accumulate the sum with step size of 2</span>
      for (int number = ADJUSTED_LOWERBOUND; number &lt;= UPPERBOUND; number += 2) {
         <span class="comment">// number = ADJUSTED_LOWERBOUND, ADJUSTED_LOWERBOUND+2, ADJUSTED_LOWERBOUND+4,
         //   ..., UPPERBOUND for each iteration</span>
         ++count;
         sum += number;
      }
      average = (double)sum / count;
      System.out.println("The sum of odd numbers is: " + sum);
      <span class="comment">//<span class="output">The sum of odd numbers is: 250000</span></span>
      System.out.println("The average of odd numbers is: " + average);
      <span class="comment">//<span class="output">The average of odd numbers is: 500.0</span></span>
   }
}</pre>

<h5>Using <code>boolean</code> Flag for Loop Control</h5>

<p>Besides using an index variable for loop control, another common way to control the loop is via a <code>boolean</code> flag.</p>

<p><span class="lead">Example:</span> Below is an example of using <em>while-do</em> with a <code>boolean</code> flag. The <code>boolean</code> flag is initialized to <code>false</code> to ensure that the loop is entered.</p>

<pre class="example">
<span class="comment">// Game loop</span>
boolean gameOver = false;
while (!gameOver) {
   <span class="comment">// play the game</span>
   ......
   <span class="comment">// Update the game state 
   // Set gameOver to true if appropriate to exit the game loop</span>
   if ( ...... ) {
      gameOver = true;    <span class="comment">// exit the loop upon the next iteration test</span>
   }
}</pre>

<p><span class="lead">Example:</span> Suppose that your program prompts user for a number between <code>1</code> to <code>10</code>, and checks for valid input. A do-while loop with a <code>boolean</code> flag could be more appropriate as it prompts for input at least once, and repeat again and again if the input is invalid.</p>
<pre class="example">
<span class="comment">// Input with validity check</span>
boolean isValid = false;
int number;
do {
  <span class="comment">// prompt user to enter an int between 1 and 10</span>
  ......
  <span class="comment">// if the number entered is valid, set done to exit the loop</span>
  if (number &gt;= 1 &amp;&amp; number &lt;= 10) {
     isValid = true;    <span class="comment">// exit the loop upon the next iteration test</span>
     <span class="comment">// Do the operations</span>
     ......
  } else {
     <span class="comment">// Print error message and repeat (isValid remains false)</span>
     ......
  }
} while (!isValid);     <span class="comment">// Repeat for invalid input</span></pre> 

<h5><code>for</code>-loop with Comma Separator</h5>

<p>You could place more than one statement in the <em>init</em> and <em>update</em>, separated with commas. For example,</p>

<pre class="example">
<span class="comment">// for (<em>init</em>; <em>test</em>; <em>update</em>) { ...... }</span>
for (int row = 0, col = 0; row &lt; SIZE; ++row, ++col) {
   <span class="comment">// Process diagonal elements (0,0), (1,1), (2,2),... </span>
   ......
}</pre>

<p>The <em>test</em>, however, must be a boolean expression that returns a boolean <code>true</code> or <code>false</code>.</p>

<h4>Terminating Program</h4>

<p><span class="lead"><code>System.exit(int <em>exitCode</em>)</code></span>: You could invoke the method <code>System.exit(int <em>exitCode</em>)</code> to terminate the program and return the control to the Java Runtime.  By convention, return code of zero indicates normal termination; while a non-zero <code>exitCode</code> indicates <em>abnormal termination</em>. For example,</p>

<pre class="example">
if (errorCount &gt; 10) {
   System.out.println(&quot;too many errors&quot;);
   System.exit(1);  <span class="comment">// Terminate the program with abnormal exit code of 1</span>
}</pre>

<p><span class="lead">The <code>return</code> statement</span>: You could also use a &quot;<code>return</code>&quot; statement in the <code>main()</code> method to terminate the <code>main()</code> and return control back to the Java Runtime.
 For example,</p>

<pre class="example">
public static void <strong>main</strong>(String[] args) {
   ...
   if (errorCount &gt; 10) {
      System.out.println(&quot;too many errors&quot;);
      return;  <span class="comment">// Terminate and return control to Java Runtime from main()</span>
   }
   ...
}</pre>

<h4>Exercises on Decision and Loop</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseDecisionLoop">LINK</a></p>


<h3>Input/Output</h3>

<h4>Formatted Output via &quot;<code>printf()</code>&quot; (JDK 5)</h4>

<p><code>System.out.print()</code> and <code>println()</code> do not provide output formatting, such as controlling the number of spaces to print an <code>int</code> and the number of decimal places for a <code>double</code>.</p>

<p>Java SE 5 introduced a new method called <code>printf()</code> for <em>formatted</em> output (which is modeled after C Language's <code>printf()</code>). <code>printf()</code> takes the following form:</p>

<pre class="syntax">printf(<em>formattingString</em>, <em>arg1</em>, <em>arg2</em>, <em>arg3</em>, ... );</pre>

<p><em>Formatting-string</em> contains both <em>normal texts</em> and the so-called <em>Format Specifier</em>s. Normal texts (including white spaces) will be printed as they are. Format specifiers, in the form of &quot;<code>%[<em>flags</em>][<em>width</em>]<em>conversionCode</em></code>&quot;, will be substituted by the arguments following the <code><em>formattingString</em></code>, usually in a one-to-one and sequential manner. A format specifier begins with a <code>'%'</code> and ends with the <code><em>conversionCode</em></code>, e.g., <code>%d</code> for integer, <code>%f</code> for floating-point number (<code>float</code> and <code>double</code>), <code>%c</code> for <code>char</code> and <code>%s</code> for <code>String</code>. An optional <code><em>width</em></code> can be inserted in between to specify the field-width. Similarly, an optional <code><em>flags</em></code> can be used to control the alignment, padding and others. For examples,</p>

<ul>
<li><code>%d, %&alpha;d</code>: integer printed in &alpha; spaces (&alpha; is optional), right-aligned. If &alpha; is omitted, the number of spaces is the length of the integer.</li>

<li><code>%s, %&alpha;s</code>: String printed in &alpha; spaces (&alpha; is optional), right-aligned. If &alpha; is omitted, the number of spaces is the length of the string (to fit the string).</li>

<li><code>%f, %&alpha;.&beta;f, %.&beta;f</code>: Floating point number (<code>float</code> and <code>double</code>) printed in &alpha; spaces with &beta; decimal digits (&alpha; and &beta; are optional). If &alpha; is omitted, the number of spaces is the length of the floating-point number.</li>

<li><code>%n</code>: a system-specific new line (Windows uses <code>&quot;\r\n&quot;</code>, Unix and macOS <code>&quot;\n&quot;</code>).</li>
</ul>

<h5>Examples:</h5>

<table class="table-zebra code">
<tr>
<th>Example</th>
<th>Output</th>
</tr>
<tr>
<td><pre><span class="comment">// Without specifying field-width</span>
System.out.printf(&quot;Hi,|<span class="new">%s</span>|<span class="new">%d</span>|<span class="new">%f</span>|,@xyz<span class="new">%n</span>&quot;, &quot;Hello&quot;, 123, 45.6);</pre></td>
<td><pre>Hi,|Hello|123|45.600000|,@xyz</pre></td>
</tr>

<tr>
<td><pre>
<span class="comment">// Specifying the field-width and decimal places for double</span>
System.out.printf(&quot;Hi,|<span class="new">%6s</span>|<span class="new">%6d</span>|<span class="new">%6.2f</span>|,@xyz<span class="new">%n</span>&quot;, &quot;Hello&quot;, 123, 45.6);</pre></td>
<td><pre>Hi,| Hello|   123| 45.60|,@xyz</pre></td>
</tr>
<tr>
<td><pre><span class="comment">// Various way to format integers:
// flag '-' for left-align, '0' for padding with 0</span>
System.out.printf(&quot;Hi,|<span class="new">%d</span>|<span class="new">%5d</span>|<span class="new">%-5d</span>|<span class="new">%05d</span>|,@xyz<span class="new">%n</span>&quot;, 111, 222, 333, 444);</pre></td>
<td><pre>Hi,|111|  222|333  |00444|,@xyz</pre></td>
</tr>
<tr>
<td><pre><span class="comment">// Various way to format floating-point numbers:
// flag '-' for left-align</span>
System.out.printf(&quot;Hi,|<span class="new">%f</span>|<span class="new">%7.2f</span>|<span class="new">%.2f</span>|<span class="new">%-7.2f</span>|,@xyz<span class="new">%n</span>&quot;, 11.1, 22.2, 33.3, 44.4);</pre></td>
<td><pre>Hi,|11.100000|  22.20|33.30|44.40  |,@xyz</pre></td>
</tr>

<tr>
<td><pre><span class="comment">// To print a '%', use %% (as % has special meaning)</span>
System.out.printf(&quot;The rate is: <span class="new">%.2f%%</span>.<span class="new">%n</span>&quot;, 1.2);</pre></td>
<td><pre>The rate is: 1.20%.</pre></td>
</tr>
</table>

<p>Take note that <code>printf()</code> does not advance the cursor to the next line after printing.  You need to explicitly print a newline character (via <code>%n</code>) at the end of the formatting-string to advance the cursor to the next line, if desires, as shown in the above examples.</p>

<p>There are many more format specifiers in Java. Refer to JDK Documentation for the detailed descriptions (@ <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Formatter.html">https://docs.oracle.com/javase/10/docs/api/java/util/Formatter.html</a> for JDK 10).</p>

<p>(Also take note that <code>printf()</code> take a variable number of arguments (or <em>varargs</em>), which is a new feature introduced in JDK 5 in order to support <code>printf()</code>)</p>

<h4>Input From Keyboard via &quot;<code>Scanner</code>&quot; (JDK 5)</h4>

<p>Java, like all other languages, supports three standard input/output streams: <code>System.in</code> (standard input device), <code>System.out</code> (standard output device), and <code>System.err</code> (standard error device). The <code>System.in</code> is defaulted to be the keyboard; while <code>System.out</code> and <code>System.err</code> are defaulted to the display console. They can be <em>re-directed</em>  to other devices, e.g., it is quite common to redirect <code>System.err</code> to a disk file to save these error message.</p>

<p>You can read input from keyboard via <code>System.in</code> (standard input device).</p>

<p>JDK 5 introduced a new class called <code>Scanner</code> in package <code>java.util</code> to simplify <em>formatted input</em> (and a new method <code>printf()</code> for formatted output described earlier). 
You can construct a <code>Scanner</code> to <em>scan</em> input from <code>System.in</code> (keyboard), and use methods such as <code>nextInt()</code>, <code>nextDouble()</code>, <code>next()</code> to <em>parse</em> the next <code>int</code>, <code>double</code> and <code>String</code> token (delimited by white space of blank, tab and newline).</p>

<pre class="example">
<span class="new">import java.util.Scanner;</span>    <span class="comment">// Needed to use the Scanner</span>
<span class="comment">/**
 * Test input scanner
 */</span>
public class <strong>ScannerTest</strong> {
   public static void main(String[] args) {
      <span class="comment">// Declare variables</span>
      int num1;
      double num2;
      String str;
	  
      <span class="comment">// Read inputs from keyboard </span>
      <span class="comment">// Construct a Scanner named &quot;in&quot; for scanning System.in (keyboard)</span>
      <span class="new">Scanner in = new Scanner(System.in);</span>
      System.out.print(&quot;Enter an integer: &quot;);  <span class="comment">// Show prompting message</span>
      num1 = <span class="new">in.nextInt()</span>;         <span class="comment">// Use nextInt() to read an int</span>
      System.out.print(&quot;Enter a floating point: &quot;);  <span class="comment">// Show prompting message</span>
      num2 = <span class="new">in.nextDouble()</span>;      <span class="comment">// Use nextDouble() to read a double</span>
      System.out.print(&quot;Enter a string: &quot;);  <span class="comment">// Show prompting message</span>
      str  = <span class="new">in.next()</span>;            <span class="comment">// Use next() to read a String token, up to white space</span>
      <span class="new">in.close();</span>   <span class="comment">// Scanner not longer needed, close it</span>

      <span class="comment">// Formatted output via printf()</span>
      System.out.printf(&quot;%s, Sum of %d &amp; %.2f is %.2f%n&quot;, str, num1, num2, num1+num2);
   }
}</pre>

<p>You can also use method <code>nextLine()</code> to read in the entire line, including white spaces, but excluding the terminating newline.</p>

<pre class="example">
<span class="comment">/**
 * Test Scanner's nextLine()
 */</span>
import java.util.Scanner;    <span class="comment">// Needed to use the Scanner</span>
public class <strong>ScannerNextLineTest</strong> {
   public static void main(String[] args) {
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter a string (with space): &quot;);
      <span class="comment">// Use nextLine() to read entire line including white spaces, 
      //   but excluding the terminating newline.</span>
      String str = <span class="new">in.nextLine()</span>;        
      in.close();
      System.out.printf(&quot;%s%n&quot;, str);
   }
}</pre>

<p>Try not to mix <code>nextLine()</code> and <code>nextInt()|nextDouble()|next()</code> in a program (as you may need to flush the newline from the input buffer).</p>

<p>The <code>Scanner</code> supports many other input formats. Check the JDK documentation page, under module <code>java.base</code> &rArr; package <code>java.util</code> &rArr; class <code>Scanner</code> &rArr; Method (@ <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Scanner.html">https://docs.oracle.com/javase/10/docs/api/java/util/Scanner.html</a> for JDK 10).</p>


<h4>Code Example: Prompt User for Two Integers and Print their Sum</h4>

<p>The following program prompts user for two integers and print their sum. For examples,</p>

<pre class="output">
Enter first integer: <span class="new">8</span>
Enter second integer: <span class="new">9</span>
The sum is: 17</pre>

<pre class="example">
import java.util.Scanner;   <span class="comment">// For keyboard input</span>
<span class="comment">/**
 * 1. Prompt user for 2 integers
 * 2. Read inputs as &quot;int&quot;
 * 3. Compute their sum in &quot;int&quot;
 * 4. Print the result
 */</span>
public class <span class="new">Add2Integer</span> {  <span class="comment">// Save as &quot;Add2Integer.java&quot;</span>
   public static void main (String[] args) {
      <span class="comment">// Declare variables</span>
      int number1, number2, sum;
 
      <span class="comment">// Put up prompting messages and read inputs as &quot;int&quot;</span>
      Scanner in = new Scanner(System.in);  <span class="comment">      // Scan the keyboard for input</span>
      System.out.print(&quot;Enter first integer: &quot;);  <span class="comment">// No newline for prompting message</span>
      number1 = in.nextInt();                     <span class="comment">// Read next input as &quot;int&quot;</span>
      System.out.print(&quot;Enter second integer: &quot;);
      number2 = in.nextInt();
      in.close();

      <span class="comment">// Compute sum</span>
      sum = number1 + number2;

      <span class="comment">// Display result</span>
      System.out.println(&quot;The sum is: &quot; + sum);   <span class="comment">// Print with newline</span>
   }
}</pre>

<h4>Code Example: Income Tax Calculator</h4>
<p>The progressive income tax rate is mandated as follows:</p>

<table class="table-zebra code" style="width:60%;text-align:center">
<tr>
<th>Taxable Income</th>
<th>Rate (%)</th>
</tr>

<tr>
<td>First $20,000</td>
<td>0</td>
</tr>

<tr>
<td>Next $20,000</td>
<td>10</td>
</tr>

<tr>
  <td>Next $20,000</td>
  <td>20</td>
</tr>

<tr>
  <td>The remaining</td>
  <td>30</td>
</tr>
</table>

<p>For example, suppose that the taxable income is <code>$85000</code>, the income tax payable is <code>$20000*0% + $20000*10% + $20000*20% + $25000*30%</code>.</p>

<p>Write a program called <code>IncomeTaxCalculator</code> that reads the taxable income (in <code>int</code>). The program shall calculate the income tax payable (in <code>double</code>); and print the result rounded to 2 decimal places.</p>

<pre class="output">
Enter the taxable income: $<span class="new">41234</span>
The income tax payable is: $2246.80

Enter the taxable income: $<span class="new">67891</span>
The income tax payable is: $8367.30

Enter the taxable income: $<span class="new">85432</span>
The income tax payable is: $13629.60

Enter the taxable income: $<span class="new">12345</span>
The income tax payable is: $0.00</pre>

<pre class="example">
import java.util.Scanner;   <span class="comment">// For keyboard input</span>
<span class="comment">/**
 * 1. Prompt user for the taxable income in integer.
 * 2. Read input as &quot;int&quot;.
 * 3. Compute the tax payable using nested-if in &quot;double&quot;.
 * 4. Print the values rounded to 2 decimal places.
 */</span>
public class <span class="new">IncomeTaxCalculator</span> {
   public static void main(String[] args) {
      <span class="comment">// Declare constants first (variables may use these constants)</span>
      final double TAX_RATE_ABOVE_20K = 0.1;
      final double TAX_RATE_ABOVE_40K = 0.2;
      final double TAX_RATE_ABOVE_60K = 0.3;

      <span class="comment">// Declare variables</span>
      int taxableIncome;
      double taxPayable;

      <span class="comment">// Prompt and read inputs as &quot;int&quot;</span>
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter the taxable income: $&quot;);
      taxableIncome = in.nextInt();
      in.close();

      <span class="comment">// Compute tax payable in &quot;double&quot; using a nested-if to handle 4 cases</span>
      if (taxableIncome &lt;= 20000) {         <span class="comment">// [0, 20000]</span>
         taxPayable = 0;
      } else if (taxableIncome &lt;= 40000) {  <span class="comment">// [20001, 40000]</span>
         taxPayable = (taxableIncome - 20000) * TAX_RATE_ABOVE_20K;
      } else if (taxableIncome &lt;= 60000) {  <span class="comment">// [40001, 60000]</span>
         taxPayable = 20000 * TAX_RATE_ABOVE_20K
                      + (taxableIncome - 40000) * TAX_RATE_ABOVE_40K;
      } else {                              <span class="comment">// &gt;=60001</span>
         taxPayable = 20000 * TAX_RATE_ABOVE_20K
                      + 20000 * TAX_RATE_ABOVE_40K
                      + (taxableIncome - 60000) * TAX_RATE_ABOVE_60K;
      }

      <span class="comment">// Alternatively, you could use the following nested-if conditions
      // but the above follows the table data
      //if (taxableIncome &gt; 60000) {          // [60001, ]
      //   ......
      //} else if (taxableIncome &gt; 40000) {   // [40001, 60000]
      //   ......
      //} else if (taxableIncome &gt; 20000) {   // [20001, 40000]
      //   ......
      //} else {                              // [0, 20000]
      //   ......
      //}</span>

      <span class="comment">// Print result rounded to 2 decimal places</span>
      System.out.printf(&quot;The income tax payable is: $%.2f%n&quot;, taxPayable);
   }
}</pre>

<h4>Code Example: Income Tax Calculator with Sentinel</h4>

<p>Based on  the previous example, write a program called <code>IncomeTaxCalculatorSentinel</code> which shall repeat the calculations until user enter <code>-1</code>. For example,</p>

<pre class="output">
Enter the taxable income: $<span class="new">41000</span>
The income tax payable is: $2200.00
Enter the taxable income: $<span class="new">62000</span>
The income tax payable is: $6600.00
Enter the taxable income: $<span class="new">73123</span>
The income tax payable is: $9936.90
Enter the taxable income: $<span class="new">84328</span>
The income tax payable is: $13298.40
Enter the taxable income: $<span class="new">-1</span>
bye!</pre>

<p>The <code>-1</code> is known as the <em>sentinel value</em>. (In programming, a <em>sentinel value</em>, also referred to as a flag value, trip value, rogue value, signal value, or dummy data, is a special value which uses its presence as a condition of termination.)</p>

<pre class="example">
import java.util.Scanner;   <span class="comment">// For keyboard input</span>
<span class="comment">/**
 * 1. Prompt user for the taxable income in integer.
 * 2. Read input as &quot;int&quot;.
 * 3. Compute the tax payable using nested-if in &quot;double&quot;.
 * 4. Print the values rounded to 2 decimal places.
 * 5. Repeat until user enter -1.
 */</span>
public class <span class="new">IncomeTaxCalculatorSentinel</span> {
   public static void main(String[] args) {
      <span class="comment">// Declare constants first (variables may use these constants)</span>
      final double TAX_RATE_ABOVE_20K = 0.1;
      final double TAX_RATE_ABOVE_40K = 0.2;
      final double TAX_RATE_ABOVE_60K = 0.3;
      final int SENTINEL = -1;    <span class="comment">// Terminating value for input</span>

      <span class="comment">// Declare variables</span>
      int taxableIncome;
      double taxPayable;

      Scanner in = new Scanner(System.in);
      <span class="comment">// Read the first input to &quot;seed&quot; the while loop</span>
      System.out.print("Enter the taxable income: $");
      taxableIncome = in.nextInt();

      while (taxableIncome != SENTINEL) {
         <span class="comment">// Compute tax payable in &quot;double&quot; using a nested-if to handle 4 cases</span>
         if (taxableIncome &gt; 60000) {
            taxPayable = 20000 * TAX_RATE_ABOVE_20K
                         + 20000 * TAX_RATE_ABOVE_40K
                         + (taxableIncome - 60000) * TAX_RATE_ABOVE_60K;
         } else if (taxableIncome &gt; 40000) {
            taxPayable = 20000 * TAX_RATE_ABOVE_20K
                         + (taxableIncome - 40000) * TAX_RATE_ABOVE_40K;
         } else if (taxableIncome &gt; 20000) {
            taxPayable = (taxableIncome - 20000) * TAX_RATE_ABOVE_20K;
         } else {
            taxPayable = 0;
         }

         <span class="comment">// Print result rounded to 2 decimal places</span>
         System.out.printf("The income tax payable is: $%.2f%n", taxPayable);

         <span class="comment">// Read the next input</span>
         System.out.print("Enter the taxable income: $");
         taxableIncome = in.nextInt();
         <span class="comment">// Repeat the loop body, only if the input is not the SENTINEL value.
         // Take note that you need to repeat these two statements inside/outside the loop!</span>
      }
      System.out.println(&quot;bye!&quot;);
      in.close();  <span class="comment">// Close Scanner</span>
   }
}</pre>

<p>Notes:</p>

<ol>
<li>The <em>coding pattern</em> for handling input with sentinel (terminating) value is as follows:
  <pre class="syntax">
<span class="comment">// Get first input to &quot;seed&quot; the while loop</span>
input = ......;
while (input != SENTINEL) {
    <span class="comment">// Process input</span>
    ......
    ......
    <span class="comment">// Get next input and repeat the loop</span>
    input = ......;    <span class="comment">// Need to repeat these statements</span>
}
......</pre></li>
</ol>

<h4>Code Example: Guess A Number</h4>

<p>Guess a number between 0 and 99.</p>

<pre class="example">
import java.util.Scanner;
<span class="comment">/**
 * Guess a secret number between 0 and 99.
 */</span>
public class <span class="new">NumberGuess</span> {
   public static void main(String[] args) {
      <span class="comment">// Define variables</span>
      final int SECRET_NUMBER;     <span class="comment">// Secret number to be guessed</span>
      int numberIn;         <span class="comment">// The guessed number entered</span>
      int trialNumber = 0;  <span class="comment">// Number of trials so far</span>
      boolean done = false; <span class="comment">// boolean flag for loop control</span>
      Scanner in = new Scanner(System.in);
   
      <span class="comment">// Set up the secret number: Math.random() generates a double in [0.0, 1.0)</span>
      SECRET_NUMBER = (int)(Math.random()*100);

      <span class="comment">// Use a while-loop to repeatedly guess the number until it is correct</span>
      while (!done) {
         ++trialNumber;
         System.out.print(&quot;Enter your guess (between 0 and 99): &quot;);
         numberIn = in.nextInt();
         if (numberIn == SECRET_NUMBER) {
            System.out.println(&quot;Congratulation&quot;);
            done = true;
         } else if (numberIn &lt; SECRET_NUMBER) {
            System.out.println(&quot;Try higher&quot;);
         } else {
            System.out.println(&quot;Try lower&quot;);
         }
      }
      System.out.println(&quot;You got in &quot; + trialNumber + &quot; trials&quot;);
      in.close();
   }
}</pre>

<p>Notes:</p>

<ol>
<li>The above program uses a <code>boolean</code> flag to control the loop, in the following <em>coding pattern</em>:
<pre class="syntax">boolean done = false;

while (!done) {
   if (......) {
       done = true;   <span class="comment">// exit the loop upon the next iteration</span>
       .....
   }
   ......   <span class="comment">// done remains false. repeat loop</span>
}</pre>
</li>
</ol>

<h4>Exercises on Decision/Loop with Input</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseDecisionLoopInput">LINK</a></p>



<h4>Input from Text File via &quot;<code>Scanner</code>&quot; (JDK 5)</h4>

<p>Other than  scanning <code>System.in</code> (keyboard), you can connect your <code>Scanner</code> to scan any input sources, such as <em>a disk file</em> or <em>a network socket</em>, and use the same set of methods <code>nextInt()</code>, <code>nextDouble()</code>, <code>next()</code>, <code>nextLine()</code> to parse the next <code>int</code>, <code>double</code>, <code>String</code> and line.  For example,</p>

<pre class="example">
Scanner in = new Scanner(new File(&quot;in.txt&quot;));  <span class="comment">// Construct a Scanner to scan a text file</span>
<span class="comment">// Use the same set of methods to read from the file</span>
int anInt = in.nextInt();         <span class="comment">// next String</span>
double aDouble = in.nextDouble(); <span class="comment">// next double</span>
String str = in.next();           <span class="comment">// next int</span>
String line = in.nextLine();      <span class="comment">// entire line</span></pre>

<p>To open a file via <code>new File(<em>filename</em>)</code>, you need to handle the so-called <code>FileNotFoundException</code>, i.e., the file that you are trying to open cannot be found. Otherwise, you cannot compile your program. There are two ways to handle this exception: <em>throws</em> or <em>try-catch</em>.</p>

<pre class="example">
<span class="comment">/**
 * Input from File.
 * Technique 1: Declare &quot;throws FileNotFoundException&quot; in the enclosing main() method
 */</span>
import java.util.Scanner;               <span class="comment">// Needed for using Scanner</span>
<span class="new">import java.io.File;</span>                    <span class="comment">// Needed for file operation</span>
<span class="new">import java.io.FileNotFoundException;</span>   <span class="comment">// Needed for file operation</span>
public class <span class="new">TextFileScannerWithThrows</span> {
   public static void main(String[] args)
          <span class="new">throws FileNotFoundException</span> {  <span class="comment">// Declare &quot;throws&quot; here</span>
      int num1;
      double num2;
      String name;
      <span class="new">Scanner in = new Scanner(new File(&quot;in.txt&quot;));</span>  <span class="comment">// Scan input from text file</span>
      num1 = in.nextInt();      <span class="comment">// Read int</span>
      num2 = in.nextDouble();   <span class="comment">// Read double</span>
      name = in.next();         <span class="comment">// Read String</span>
      System.out.printf(&quot;Hi %s, the sum of %d and %.2f is %.2f%n&quot;, name, num1, num2, num1+num2);
      in.close();
   }
}</pre>

<p>To run the above program, create a text file called <code>in.txt</code> containing:</p>

<pre class="output">
1234
55.66
Paul</pre>

<pre class="example">
<span class="comment">/**
 * Input from File.
 * Technique 2: Use try-catch to handle exception
 */</span>
import java.util.Scanner;               <span class="comment">// Needed for using Scanner</span>
import java.io.File;                    <span class="comment">// Needed for file operation</span>
import java.io.FileNotFoundException;   <span class="comment">// Needed for file operation</span>
public class <span class="new">TextFileScannerWithCatch</span> {
   public static void main(String[] args) {
      int num1;
      double num2;
      String name;
      <span class="new">try {</span>                                <span class="comment">// try these statements</span>
         <span class="new">Scanner in = new Scanner(new File(&quot;in.txt&quot;));</span>
         num1 = in.nextInt();      <span class="comment">// Read int</span>
         num2 = in.nextDouble();   <span class="comment">// Read double</span>
         name = in.next();         <span class="comment">// Read String</span>
         System.out.printf(&quot;Hi %s, the sum of %d and %.2f is %.2f%n&quot;, name, num1, num2, num1+num2);
         in.close();
      <span class="new">} catch (FileNotFoundException ex) {</span>  <span class="comment">// catch and handle the exception here</span>
         ex.printStackTrace();              <span class="comment">// print the stack trace</span>
      <span class="new">}</span>
   }
}</pre>

<h4>Formatted Output to Text File</h4>

<p>Java SE 5.0 also introduced a so-called <code>Formatter</code> for formatted output (just like <code>Scanner</code> for formatted input). A <code>Formatter</code> has a method called <code>format()</code>. The <code>format()</code> method has the same syntax as <code>printf()</code>, i.e., it could use format specifiers to specify the format of the arguments. Again, you need to handle the <code>FileNotFoundException</code>.</p>

<pre class="example">
<span class="comment">/**
 * Output to File.
 * Technique 1: Declare &quot;throws FileNotFoundException&quot; in the enclosing main() method
 */</span>
import java.io.File;
import java.util.Formatter;             <span class="comment">// &lt;== note</span>
import java.io.FileNotFoundException;   <span class="comment">// &lt;== note</span>
public class <span class="new">TextFileFormatterWithThrows</span> {
   public static void main(String[] args)
         <span class="new">throws FileNotFoundException</span> {   <span class="comment">// &lt;== note</span>
      <span class="comment">// Construct a Formatter to write formatted output to a text file</span> 
      <strong></strong><span class="new">Formatter out = new Formatter(new File(&quot;out.txt&quot;));</span>
      <span class="comment">// Write to file with format() method (similar to printf())</span>
      int num1 = 1234;
      double num2 = 55.66;
      String name = &quot;Paul&quot;;
      <span class="new">out.format(&quot;Hi %s,%n&quot;, name);
      out.format(&quot;The sum of %d and %.2f is %.2f%n&quot;, num1, num2, num1 + num2);
      out.close();</span>                 <span class="comment">// Close the file</span>
      System.out.println(&quot;Done&quot;);  <span class="comment">// Print to console</span>
   }
}</pre>

<p>Run the above program, and check the outputs in text file &quot;<code>out.txt</code>&quot;.</p>

<pre class="example">
<span class="comment">/**
 * Output to File.
 * Technique 2: Use try-catch to handle exception
 */</span>
import java.io.File;
import java.util.Formatter;           <span class="comment">// &lt;== note</span>
import java.io.FileNotFoundException; <span class="comment">// &lt;== note</span>

public class <span class="new">TextFileFormatterWithCatch</span> {
   public static void main(String[] args) {
      <span class="new">try {</span>    <span class="comment">// try the following statements</span>
         <span class="comment">// Construct a Formatter to write formatted output to a text file</span>
         <span class="new">Formatter out = new Formatter(new File(&quot;out.txt&quot;));</span>
         <span class="comment">// Write to file with format() method (similar to printf())</span>
         int num1 = 1234;
         double num2 = 55.66;
         String name = &quot;Pauline&quot;;
         <span class="new">out.format(&quot;Hi %s,%n&quot;, name);</span><strong>
         </strong><span class="new">out.format(&quot;The sum of %d and %.2f is %.2f%n&quot;, num1, num2, num1 + num2);</span><strong>
         </strong><span class="new">out.close();</span>                <span class="comment">// Close the file</span>
         System.out.println(&quot;Done&quot;); <span class="comment">// Print to console</span>
      <span class="new">} catch (FileNotFoundException ex) {</span>  <span class="comment">// catch the exception here</span>
         ex.printStackTrace();       <span class="comment">// Print the stack trace</span>
      <span class="new">}</span>
   }
}</pre>


<h4>Input via a Dialog Box</h4>

<img class="image-float-right" src="images/JavaBasics_InputViaJOptionPane.gif" alt="Input via JOptionPane" />

<p>You can also get inputs from users via a graphical dialog box, using the <code>JOptionPane</code> class.  For example, the following program prompts the user to enter the radius of a circle, and computes the area.</p>
	
<pre data-line="10"><code class="language-java line-numbers">/**
 * Input via a Dialog box
 */
import javax.swing.JOptionPane;   // Needed to use JOptionPane
public class JOptionPaneTest {
   public static void main(String[] args) {
      String radiusStr;
      double radius, area;
      // Read input String from dialog box
      radiusStr = JOptionPane.showInputDialog("Enter the radius of the circle");
      radius = Double.parseDouble(radiusStr);   // Convert String to double
      area = radius*radius*Math.PI;
      System.out.println("The area is " + area);
   }
}</code></pre>

<p>Dissecting the Program:</p>

<ul>
<li>In Line 4, the <code>import</code> statement is needed to use the <code>JOptionPane</code>.</li>

<li>In Line 10, we use the method <code>JOptionPane.showInputDialog(promptMessage)</code> to prompt users for an input, which returns the input as a <code>String</code>.</li>

<li>Line 11 converts the input <code>String</code> to a <code>double</code>, using the method <code>Double.parseDouble()</code>.</li>
</ul>

<h4><code>java.io.Console</code> (JDK 1.6)</h4>

<p>Java SE 6 introduced a new <code>java.io.Console</code> class to simplify character-based input/output to/from the system console. BUT, the <code>Console</code> class does not run under IDE (such as Eclipse/NetBeans)!!!</p>

<p>To use the new <code>Console</code> class, you first use <code>System.console()</code> to retrieve the  <code>Console</code> object corresponding to the current system console.</p>

<pre class="example">
Console con = System.console();</pre>

<p>You can then use methods such as <code>readLine()</code> to read a line. You can optionally include a prompting message with format specifiers (e.g., <code>%d</code>, <code>%s</code>) in the prompting message.</p>

<pre class="example">
String inLine = con.readLine();
String msg = con.readLine(&quot;Enter your message: &quot;);        <span class="comment">// readLine() with prompting message</span>
String msg = con.readLine(&quot;%s, enter message: &quot;, name);   <span class="comment">// Prompting message with format specifier</span></pre>

<p>You can use <code>con.printf()</code> for formatted output with format specifiers such as <code>%d</code>, <code>%s</code>.
You can also connect the <code>Console</code> to a <code>Scanner</code> for formatted input, i.e., parsing primitives such as <code>int</code>, <code>double</code>, for example,</p>

<pre class="example">
Scanner in = new Scanner(con.reader());  <span class="comment">// Use Scanner to scan the Console</span>
<span class="comment">// Use the Scanner's methods such as nextInt(), nextDouble() to parse primitives</span> 
int anInt = in.nextInt();
double aDouble = in.nextDouble();
String str = in.next();
String line = in.nextLine();</pre>

<h5>Example:</h5>

<pre class="example">
<span class="comment">/*
 * Testing java.io.Console class
 */</span>
<span class="new">import java.io.Console;</span>
import java.util.Scanner;
public class <span class="new">ConsoleTest</span> {
   public static void main(String[] args) {
      <span class="new">Console con = System.console();</span>   <span class="comment">// Retrieve the Console object</span>
      <span class="comment">// Console class does not work in Eclipse/NetBeans</span>
      if (con == null) {
          System.err.println(&quot;Console Object is not available.&quot;);
          System.exit(1);
      }
   
      <span class="comment">// Read a line with a prompting message</span>
      String name = <span class="new">con.readLine(&quot;Enter your Name: &quot;)</span>;
      <span class="new">con.printf(&quot;Hello %s%n&quot;, name);</span>
      <span class="comment">// Use the console with Scanner for parsing primitives</span>
      <span class="new">Scanner in = new Scanner(con.reader());</span>
      con.printf(&quot;Enter an integer: &quot;);
      int anInt = <span class="new">in.nextInt();</span>
      con.printf(&quot;The integer entered is %d%n&quot;, anInt);
      con.printf(&quot;Enter a floating point number: &quot;);
      double aDouble = <span class="new">in.nextDouble();</span>
      con.printf(&quot;The floating point number entered is %f%n&quot;, aDouble);
      in.close();
   }
}</pre>

<p>The <code>Console</code> class also provides a secure mean for password entry via method <code>readPassword()</code>. This method disables input echoing and keep the password in a <code>char[]</code> instead of a <code>String</code>. The <code>char[]</code> containing the password can be and should be overwritten, removing it from memory as soon as it is no longer needed. (Recall that <code>String</code>s are immutable and cannot be overwritten. When they are longer needed, they will be garbage-collected at an unknown instance.)</p>

<pre class="example">
import java.io.Console;
import java.util.Arrays;
<span class="comment">/**
 * Inputting password via Console
 */</span>
public class <span class="new">ConsolePasswordTest</span> {
   static String login;
   static <span class="new">char[] password</span>;
   
   public static void main(String[] args) {
      Console con = System.console();
      if (con == null) {
         System.err.println(&quot;Console Object is not available.&quot;);
         System.exit(1);
      }
   
      login = con.readLine(&quot;Enter your login Name: &quot;);
      <span class="new">password = con.readPassword(&quot;Enter your password: &quot;);</span>
      if (checkPassword(login, password)) {
         <span class="new">Arrays.fill(password, ' ')</span>;  <span class="comment">// Remove password from memory</span>
         <span class="comment">// Continue ...</span>
   
      }
   }
   
   static boolean checkPassword(String login, char[] password) {
       return true;
   }
}</pre>

<h3>Writing Correct and Good Programs</h3>

<p>It is important to write programs that produce the correct results.  It is also important to write programs that others (and you yourself three days later) can understand, so that the programs can be maintained. I call these programs good programs - a good program is more than a correct program.</p>

<p>Here are the suggestions:</p>

<ul>
<li>Follow established convention so that everyone has the same basis of understanding. To program in Java, you MUST read the &quot;<a href="http://www.oracle.com/technetwork/java/codeconv-138413.html">Code Convention for the Java Programming Language</a>&quot;.</li>

<li>Format and layout of the source code with appropriate indents, white spaces and white lines. Use 3 or 4 spaces for indent, and blank lines to separate sections of code.</li>

<li>Choose good names that are self-descriptive and meaningful, e.g., <code>row</code>, <code>col</code>, <code>size</code>, <code>xMax</code>, <code>numStudents</code>. Do not use meaningless names, such as <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>. Avoid single-alphabet names (easier to type but often meaningless), except common names likes x, <code>y</code>, <code>z</code> for coordinates and <code>i</code> for index.</li>

<li>Provide comments to explain the important as well as salient concepts. Comment your code liberally.</li>

<li>Write your program documentation while writing your programs.</li>

<li>Avoid <em>unstructured</em> constructs, such as <code>break</code> and <code>continue</code>, which are hard to follow.</li>

<li> Use &quot;mono-space&quot; fonts (such as Consolas, Courier New, Courier) for writing/displaying your program.</li>
</ul>

<p>It is estimated that over the lifetime of a program, 20 percent of the effort will go into the original creation and testing of the code, and 80 percent of the effort will go into the subsequent maintenance and enhancement. Writing good programs which follow standard conventions is critical in the subsequent maintenance and enhancement!!!</p>

<h4>Programming Errors: Compilation, Runtime and Logical Errors</h4>

<p>There are generally three classes of programming errors:</p>

<ol>
<li><em>Compilation Error</em> (or <em>Syntax Error</em>): The program cannot compile. This can be fixed easily by checking the compilation error messages. For examples,
  <pre class="example">
<span class="comment">// System instead of Sys</span>
Sys.out.print(&quot;Hello&quot;);
<span class="error">error: package Sys does not exist<br>Sys.out.print(&quot;Hello&quot;);
   ^</span>
   
<span class="comment">// Missing semi-colon</span>
System.out.print(&quot;Hello&quot;)
<span class="error">error: ';' expected<br>System.out.print(&quot;Hello&quot;)<br>                         ^</span></pre>
</li>

<li><em>Runtime Error</em>: The program can compile, but fail to run successfully. This can also be fixed easily, by checking the runtime error messages. For examples,
  <pre class="example">
<span class="comment">// Divide by 0 Runtime error</span>
int count = 0, sum = 100, average;
average = sum / count;
<span class="error">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span>

<span class="comment">// Wrong conversion code, %d for integer</span>
System.out.printf(&quot;The sum is: %d%n&quot;, 1.23);
<span class="error">Exception in thread &quot;main&quot; java.util.IllegalFormatConversionException: d != java.lang.Double</span></pre>
</li>

<li><em>Logical Error</em>: The program can compile and run, but produces incorrect results (always or sometimes). This is the hardest error to fix as there is no error messages - you have to rely on checking the output. It is easy to detect if the program always produces wrong output. It is extremely hard to fix if the program produces the correct result most of the times, but incorrect result sometimes. For example,

  <pre class="example">
<span class="comment">// Can compile and run, but give wrong result – sometimes!</span>
if (mark &gt; 50) {
   System.out.println(&quot;PASS&quot;);
} else {
   System.out.println(&quot;FAIL&quot;);
}</pre>
This kind of errors is very serious if it is not caught before production. Writing good programs helps in minimizing and detecting these errors. A good <em>testing strategy</em> is needed to ascertain the correctness of the program. <em>Software testing</em> is an advanced topics which is beyond our current scope.</li>
</ol>

<h4>Debugging Programs</h4>

<p>Here are the common debugging techniques:</p>

<ol>
<li>Stare at the screen! Unfortunately, nothing will pop-up even if you stare at it extremely hard.</li>

<li>Study the error messages! Do not close the console when error occurs and pretending that everything is fine. This helps most of the times.</li>

<li>Insert print statements at appropriate locations to display the intermediate results. It works for simple toy program, but it is neither effective nor efficient for complex program.</li>

<li>Use a graphic debugger. This is the most effective means. Trace program execution step-by-step and watch the value of variables and outputs.</li>

<li>Advanced tools such as profiler (needed for checking memory leak and method usage).</li>

<li>Perform program testing to wipe out the logical errors. &quot;Write test first, before writing program&quot;.</li>
</ol>

<h4>Exercises on Decision/Loop with Input</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseDebugging">LINK</a></p>


<h4>Testing Your Program for Correctness</h4>

<p>How to ensure that your program always produces correct result, 100% of the times? It is impossible to try out all the possible outcomes, even for a simple program for adding two integers (because there are too many combinations of two integers). Program testing usually involves a set of representative test cases, which are designed to catch all <em>classes</em> of errors.  Program testing is beyond the scope of this writing.</p>


<h3>More on Loops - Nested-Loops, <code>break</code> &amp; <code>continue</code></h3>

<h4>Nested Loops</h4>

<p>Nested loops are needed to process 2-dimensional (or N-dimensional) data, such as printing 2D patterns. A nested-for-loop takes the following form:</p>

<pre class="example">
for (...; ...; ...) {     <span class="comment">// outer loop</span>
   <span class="comment">// Before running the inner loop</span>
   ......
   for (...; ...; ...) {  <span class="comment">// inner loop</span>
      ......
   }
   <span class="comment">// After running the inner loop</span>
   ......
} </pre>

<img src="images/Flowchart_NestedForLoop.png" alt="Flowchart_NestedForLoop.png" width="564" height="301" class="image-left"  />

<h4>Code Examples: Print Square Pattern</h4>

<p>The following program prompt user for the size of the pattern, and print a square pattern using nested-loops. For example,</p>

<pre class="output">
Enter the size: 5
* * * * *
* * * * *
* * * * *
* * * * *
* * * * *</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for the size; and print Square pattern
 */
public class PrintSquarePattern {
   public static void main (String[] args) {
      // Declare variables
      final int SIZE;    // size of the pattern to be input

      // Prompt user for the size and read input as "int"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter the size: ");
      SIZE = in.nextInt();
      in.close();

      // Use nested-loop to print a 2D pattern
      // Outer loop to print ALL the rows
      for (int row = 1; row &lt;= SIZE; row++) {
         // Inner loop to print ALL the columns of EACH row
         for (int col = 1; col &lt;= SIZE; col++) {
            System.out.print("* ");
         }
         // Print a newline after all the columns
         System.out.println();
      }
   }
}</code></pre>

<p>This program contains two <em>nested</em> for-loops. The inner loop is used to print a row of &quot;<code>* </code>&quot;, which is followed by printing a newline. The outer loop repeats the inner loop to print all the rows.</p>

<h5>Coding Pattern: Print 2D Patterns</h5>
<p>The <em>coding pattern</em> for printing 2D patterns is as follows. I  recommend using <code>row</code> and <code>col</code> as the loop variables which is self-explanatory, instead of <code>i</code> and <code>j</code>, <code>x</code> and <code>y</code>.</p>

<pre class="syntax">
for (int row = 1; row &lt;= ROW_SIZE; row++) {   <span class="comment">// outer loop for rows</span>
   ......  <span class="comment">// before each row</span>
   for (int col = 1; col &lt;= COL_SIZE; col++) {   <span class="comment">// inner loop for columns</span>
      if (......) {
         System.out.print(......);    <span class="comment">// without newline</span>
      } else {
         System.out.print(......);
      }
   }
   ......  <span class="comment">// after each row</span>
   System.out.println();  <span class="comment">// Print a newline after all the columns</span>
}</pre>


<h4>Code Examples: Print Checker Board Pattern</h4>

<p>Suppose that you want to print this pattern  instead (in program called <code>PrintCheckerPattern</code>):</p>

<pre class="output">
Enter the size: 6
* * * * * *
 * * * * * *
* * * * * *
 * * * * * *
* * * * * *
 * * * * * *</pre>

<p>You need to print an additional space for even-number rows.  You could do so by adding the following statement before the inner loop.</p>
<pre  class="example">
if ((row % 2) == 0) {   <span class="comment">// print a leading space for even-numbered rows</span>
   System.out.print(&quot; &quot;);
}</pre>


<h4>Code Example: Print Multiplication Table</h4>

<p>The following program prompts user for the size, and print the multiplication table as follows:</p>

<pre class="output">
Enter the size: 10
 * |   1   2   3   4   5   6   7   8   9  10
--------------------------------------------
 1 |   1   2   3   4   5   6   7   8   9  10
 2 |   2   4   6   8  10  12  14  16  18  20
 3 |   3   6   9  12  15  18  21  24  27  30
 4 |   4   8  12  16  20  24  28  32  36  40
 5 |   5  10  15  20  25  30  35  40  45  50
 6 |   6  12  18  24  30  36  42  48  54  60
 7 |   7  14  21  28  35  42  49  56  63  70
 8 |   8  16  24  32  40  48  56  64  72  80
 9 |   9  18  27  36  45  54  63  72  81  90
10 |  10  20  30  40  50  60  70  80  90 100</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for the size and print the multiplication table.
 */
public class PrintTimeTable {
   public static void main(String[] args) {
      // Declare variables
      final int SIZE;   // size of table to be input

      // Prompt for size and read input as "int"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter the size: ");
      SIZE = in.nextInt();
      in.close();

      // Print header row
      System.out.print(" * |");
      for (int col = 1; col &lt;= SIZE; ++col) {
         System.out.printf("%4d", col);
      }
      System.out.println();  // End row with newline
      // Print separator row
      System.out.print("----");
      for (int col = 1; col &lt;= SIZE; ++col) {
         System.out.printf("%4s", "----");
      }
      System.out.println();  // End row with newline

      // Print body using nested-loops
      for (int row = 1; row &lt;= SIZE; ++row) {  // outer loop
         System.out.printf("%2d |", row);      // print row header first
         for (int col = 1; col &lt;= SIZE; ++col) {  // inner loop
            System.out.printf("%4d", row*col);
         }
         System.out.println();  // print newline after all columns
      }
   }
}</code></pre>

<p><span class="lead">TRY:</span></p>
<ol>

<li>Write programs called <code>PrintPattern1x</code>, which prompts user for the size and prints each these patterns.
  <pre class="output">
 # * # * # * # *    # # # # # # # #    # # # # # # # #    1                                1
# * # * # * # *     # # # # # # #        # # # # # # #    2 1                            1 2
 # * # * # * # *    # # # # # #            # # # # # #    3 2 1                        1 2 3
# * # * # * # *     # # # # #                # # # # #    4 3 2 1                    1 2 3 4
 # * # * # * # *    # # # #                    # # # #    5 4 3 2 1                1 2 3 4 5
# * # * # * # *     # # #                        # # #    6 5 4 3 2 1            1 2 3 4 5 6
 # * # * # * # *    # #                            # #    7 6 5 4 3 2 1        1 2 3 4 5 6 7
# * # * # * # *     #                                #    8 7 6 5 4 3 2 1    1 2 3 4 5 6 7 8
     (a)                  (b)                (c)                (d)                (e)</pre>
<em>Hints</em>:<br>
The equations for major and opposite diagonals are <code>row = col </code>and<code> row + col = size + 1</code>. Decide on what to print above and below the diagonal. </li>

<li>Write programs called <code>PrintPattern2x</code>, which prompts user for the size and prints each of these patterns.
  <pre class="output">
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
#           #        #                          #          #       #        # #       # #
#           #          #                      #              #   #          #   #   #   #
#           #            #                  #                  #            #     #     #
#           #              #              #                  #   #          #   #   #   #
#           #                #          #                  #       #        # #       # #
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
     (a)                 (b)               (c)                (d)                (e)</pre>
</li>
</ol>

<h4>Exercises on Nested Loops with Input</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseNestedLoop">LINK</a></p>

<h4><code>break</code> and <code>continue</code> - Interrupting Loop Flow</h4>

<p>The <code><strong>break</strong></code> statement breaks out and exits the current (innermost) loop.</p>

<p>The <code><strong>continue</strong></code> statement aborts the current iteration and continue to the next iteration of the current (innermost) loop.</p>

<p><code>break</code> and <code>continue</code> are poor structures as they are hard to read and hard to follow.  Use them only if absolutely necessary.</p>

<h5>Endless loop</h5>

<p><code>for ( ; ; ) { <em>body</em> }</code> is known as an <em>empty for-loop</em>, with empty statement for initialization, test and post-processing. The body of the empty for-loop will execute continuously (infinite loop). You need to use a <code>break</code> statement to break out the loop.</p>
<p>Similar, <code>while (true) {  <em>body</em> }</code> and <code>do { <em>body</em> } while (true)</code> are endless loops.</p>

<pre class="example">
for (;;) {
   ......    <span class="comment">// Need break inside the loop body</span>
}

while (true) {
   ......   <span class="comment">// Need break inside the loop body</span>
}

do {
   ......   <span class="comment">// Need break inside the loop body</span>
} while (true);</pre>

<p>Endless loop is typically a mistake especially for new programmers. You need to break out the loop via a <code>break</code> statement inside the loop body..</p>



<p><span class="lead">Example (<code>break</code>):</span> The following program lists the non-prime numbers between 2 and an upperbound.</p>

<pre class="example">
<span class="comment">/**
 * List all non-prime numbers between 2 and an upperbound
 */</span>
public class <span class="new">NonPrimeList</span> {
   public static void main(String[] args) {
      final int UPPERBOUND = 100;
      for (int number = 2; number &lt;= UPPERBOUND; ++number) {
         <span class="comment">// Not a prime, if there is a factor between 2 and sqrt(number)</span>
         int maxFactor = (int)Math.sqrt(number);
         for (int factor = 2; factor &lt;= maxFactor; ++factor) {
            if (number % factor == 0) {   <span class="comment">// Factor?</span>
               System.out.println(number + &quot; is NOT a prime&quot;);
               break;   <span class="comment">// A factor found, no need to search for more factors</span>
            }
         }
      }
   }
}</pre>

<p>Let's rewrite the above program to list all the primes instead. A <code>boolean</code> flag called <code>isPrime</code> is used to indicate whether the current <code>number</code> is a prime. It is then used to control the printing.</p>

<pre class="example">
<span class="comment">/**
 * List all prime numbers between 2 and an upperbound
 */</span>
public class <span class="new">PrimeListWithBreak</span> {
   public static void main(String[] args) {
      final int UPPERBOUND = 100;
      for (int number = 2; number &lt;= UPPERBOUND; ++number) {
         <span class="comment">// Not a prime, if there is a factor between 2 and sqrt(number)</span>
         int maxFactor = (int)Math.sqrt(number);
         boolean isPrime = true;  <span class="comment">// boolean flag to indicate whether number is a prime</span>
         for (int factor = 2; factor &lt;= maxFactor; ++factor) {
            if (number % factor == 0) {   <span class="comment">// Factor?</span>
               isPrime = false;   <span class="comment">// number is not a prime</span>
               break;   <span class="comment">// A factor found, no need to search for more factors</span>
            }
         }
         if (isPrime) System.out.println(number + &quot; is a prime&quot;);
      }
   }
}</pre>

<p>Let's rewrite the above program without using <code>break</code> statement. A <code>while</code> loop is used (which is controlled by the <code>boolean</code> flag) instead of <code>for</code> loop with <code>break</code>.</p>

<pre class="example">
<span class="comment">/**
 * List all prime numbers between 2 and an upperbound
 */</span>
public class <span class="new">PrimeList</span> {
   public static void main(String[] args) {
      final int UPPERBOUND = 100;
      for (int number = 2; number &lt;= UPPERBOUND; ++number) {
         <span class="comment">// Not prime, if there is a factor between 2 and sqrt of number</span>
         int maxFactor = (int)Math.sqrt(number);
         boolean isPrime = true;
         int factor = 2;
         while (isPrime &amp;&amp; factor &lt;= maxFactor) {
            if (number % factor == 0) {   <span class="comment">// Factor of number?</span>
                isPrime = false;
            }
            ++factor;
         }
         if (isPrime) System.out.println(number + &quot; is a prime&quot;);
      }
   }
}</pre>

<p><span class="lead">Example (<code>continue</code>):</span></p>

<pre class="example">
<span class="comment">// Sum 1 to upperbound, exclude 11, 22, 33,...
</span>final int UPPERBOUND = 100;
int sum = 0;
for (int number = 1; number &lt;= UPPERBOUND; ++number) {
   if (number % 11 == 0) continue;  <span class="comment">// Skip the rest of the loop body, continue to the next iteration
</span>   sum += number;
}
<span class="comment">
// It is better to re-write the loop as:</span>
for (int number = 1; number &lt;= UPPERBOUND; ++number) {
   if (number % 11 != 0) sum += number;
}</pre>

<p><span class="lead">Example (<code>break</code> and <code>continue</code>):</span> Study the following program.</p>

<pre class="example">
<span class="comment">/**
 * A mystery series created using break and continue
 */</span>
public class <span class="new">MysterySeries</span> {
   public static void main(String[] args) {
      int number = 1;
      while(true) {
         ++number;
         if ((number % 3) == 0) continue;
         if (number == 133) break;
         if ((number % 2) == 0) {
            number += 3;
         } else {
            number -= 3;
         }
         System.out.print(number + &quot; &quot;);
      }
   }
}
<span class="comment">// Can you figure out the output?
// break and continue are hard to read, use it with great care!</span></pre>

<h5>Labeled <code>break</code></h5>

<p>In a nested loop, the <code>break</code> statement breaks out the innermost loop and continue into the outer loop. At times, there is a need to break out all the loops (or multiple loops). This is clumsy to achieve with <code>boolean</code> flag, but can be done easily via the so-called labeled <code>break</code>. You can add a <code>label</code> to a loop in the form of <code><em>labelName</em>: <em>loop</em></code>. For example,</p>

<pre class="example">
level1:          <span class="comment">// define a label for the level-1 loop</span>
for (.....) {
level2:          <span class="comment">// define a label for the level-2 loop</span>
   for (.....) {
      for (......) {  <span class="comment">// level-3 loop</span>
         if (...) break level1;  <span class="comment">// break all loops, continue after the loop</span>
         if (...) break level2:  <span class="comment">// continue into the next statement of level-1 loop</span>
         ......
      }
   }
}</pre>

<h5>Labeled <code>continue</code></h5>

<p>In a nested loop, similar to labeled <code>break</code>, you can use labeled continue to continue into a specified loop. For example,</p>

<pre class="example">
level1:          <span class="comment">// define a label (with : suffix) for the level-1 loop</span>
for (.....) {
level2:          <span class="comment">// define a label (with : suffix) for the level-2 loop</span>
   for (.....) {
      for (......) {  <span class="comment">// level-3 loop</span>
         if (...) continue level1;  <span class="comment">// continue the next iteration of level-1 loop</span>
         if (...) continue level2:  <span class="comment">// continue the next iteration of level-2 loop</span>
         ......
      }
   }
}</pre>

<p>Again, labeled <code>break</code> and <code>continue</code> are not structured and hard to read. Use them only if absolutely necessary.</p>

<p><span class="lead">Example (Labeled <code>break</code>):</span> Suppose that you are searching for a particular number in a 2D array.</p>
	
<pre><code class="language-java line-numbers">public class TestLabeledBreak {
   public static void main(String[] args) {
      int[][] testArray = {
         {1, 2, 3, 4},
         {4, 3, 1, 4},
         {9, 2, 3, 4}
      };
 
      final int MAGIC_NUMBER = 8;
      boolean found = false;
      mainLoop:
      for (int i = 0; i &lt; testArray.length; ++i) {
         for (int j = 0; j &lt; testArray[i].length; ++j) {
            if (testArray[i][j] == MAGIC_NUMBER) {
               found = true;
               break mainLoop;
            }
         }
      }
      System.out.println("Magic number " + (found ? "found" : "NOT found"));
   }
}</code></pre>

<h3><code>String</code> and <code>char</code>   operations</h3>

<h4><code>char</code> Arithmetic Operations</h4>

<p>Recall that:</p>

<ul>
<li>In Java, each <code>char</code> is represented by a 16-bit Unicode number. For examples,<code> char</code> <code>'0'</code> is represented by code number <code>48</code> (<code>30H</code>), <code>char</code> <code>'1'</code> by <code>49</code> (<code>31H</code>), <code>char</code> <code>'A'</code> by <code>65</code> (<code>41H</code>). <code>char</code> <code>'a'</code> by <code>97</code> (<code>61H</code>). Take note that <code>char</code> <code>'0'</code> is NOT <code>int 0</code>, <code>char</code> <code>'1'</code> is NOT <code>int 1</code>.</li>
<li><code>char</code>s can take part in arithmetic operations. A <code>char</code> is treated as its underlying <code>int</code> (in the range of <code>[0, 65535]</code>) in arithmetic operations. In other words, <code>char</code> and <code>int</code> are interchangeable. <code>char '0' &hArr; int 48</code>, <code>char '1' &hArr; int 49</code>, <code>char 'A' &hArr; int 65</code>, <code>char 'a' &hArr; int 97</code>. For examples,
  <pre class="example">char c1 = '0';     <span class="comment">// Code number 48</span>
char c2 = 'A';     <span class="comment">// Code number 65</span>
char c3;

<span class="comment">// char &lt;-&gt; int (interchangeable)</span>
System.out.println((int)c1);   <span class="comment">// Print int 48</span>
System.out.println((int)c2);   <span class="comment">// Print int 65</span>
c3 = 97;                       <span class="comment">// Code number for 'a'</span>
System.out.println(c3);        <span class="comment">// Print char 'a'</span>
System.out.println((char)97);  <span class="comment">// Print char 'a'</span></pre>
</li>
<li>In arithmetic operations, <code>char</code> (and <code>byte</code>, and <code>short</code>) is first converted to <code>int</code>. In Java, arithmetic operations are only carried out in <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>; NOT in <code>byte</code>, <code>short</code>, and <code>char</code>.</li>
<li>Hence, <code>char &oplus; char &rArr; int &oplus; int &rArr; int</code>, where <code>&oplus;</code> denotes an binary arithmetic operation (such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>). You may need to explicitly cast the resultant <code>int</code> back to <code>char</code>. For examples,

<pre class="example">
char c1 = '0';     <span class="comment">// Code number 48</span>
char c2 = 'A';     <span class="comment">// Code number 65</span>
char c3;

<span class="comment">// char + char -&gt; int + int -&gt; int</span>
<span class="error">//c3 = c1 + c2;</span>           <span class="comment">// error: RHS evaluated to &quot;int&quot;, cannot assign to LHS of &quot;char&quot;</span>
c3 = (char)(c1 + c2);     <span class="comment">// Need explicit type casting, return char 'q' (code number 113)</span>
System.out.println(c3);       <span class="comment">// Print 'q', as c3 is a char</span>
System.out.println(c1 + c2);  <span class="comment">// Print int 113</span>
System.out.println((char)(c1 + c2));  <span class="comment">// Print char 'q'</span></pre>
</li>
<li>Similar, <code>char &oplus; int &rArr; int &oplus; int &rArr; int</code>. You may need to explicitly cast the resultant <code>int</code> back to <code>char</code>. For examples,
  <pre class="example">char c1 = '0';     <span class="comment">// Code number 48</span>
char c2 = 'A';     <span class="comment">// Code number 65</span>
char c3;

<span class="comment">// char + int -&gt; int + int -&gt; int</span>
<span class="error">//c3 = c1 + 5;</span>            <span class="comment">// error: RHS evaluated to &quot;int&quot;, cannot assign to LHS of &quot;char&quot;</span>
c3 = (char)(c1 + 5);      <span class="comment">// Need explicit type casting, return char '5' (code number 53)</span>
System.out.println(c3);      <span class="comment">// Print '5', as c3 is a char</span>
System.out.println(c1 + 5);  <span class="comment">// Print int 53</span>

<span class="comment">// Print the code number for 'a' to 'z'
</span>for (int codeNum = 'a'; codeNum &lt;= 'z'; ++codeNum) {
   System.out.println((char)codeNum + &quot;: &quot; + codeNum);
}</pre>
</li>

<li>However, for compound operators (such as <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>), the evaluation is carried out in <code>int</code>, but the result is casted back to the LHS automatically. For examples,
  <pre class="example">char c4 = '0';           <span class="comment">// Code number 48</span>
c4 += 5;                 <span class="comment">// Automatically cast back to char '5'</span>
System.out.println(c4);  <span class="comment">// Print char '5'</span></pre>
</li>
<li>For increment (<code>++</code>) and decrement (<code>--</code>) of <code>char</code> (and <code>byte</code>, and <code>short</code>), there is no promotion to <code>int</code>. For examples,
<pre class="example"><span class="comment">// Print char '0' to '9' via increment</span>
for (char c = '0'; c &lt;= '9'; ++c) {   <span class="comment">// ++c remains as &quot;char&quot;</span>
   System.out.println(c);
}</pre>
</li>

</ul>

<h4>Converting <code>char</code> to <code>int</code></h4>

<p>You can convert <code>char</code> <code>'0'</code> to <code>'9'</code> to <code>int</code> <code>0</code> to <code>9</code> by subtracting the <code>char</code> with the base <code>'0'</code>, e.g., <code>'8' - '0' &rArr; 8</code>.</p>
<p>That is, suppose <code>c</code> is a <code>char</code> between <code>'0'</code> and <code>'9'</code>, <code><strong>(c - '0')</strong></code> is the corresponding <code>int</code> <code>0</code> to <code>9</code>.</p>
<p>The following program illustrates how to convert a hexadecimal character (<code>0-9</code>, <code>A-F</code> or <code>a-f</code>) to its decimal equivalent (<code>0-15</code>), by subtracting the appropriate base <code>char</code>.</p>

<pre class="example">
<span class="comment">// Converting a hex char (0-9|A-F|a-f) to its equivalent decimal (0-15)</span>
char hexChar = 'a';
int dec;

if (hexChar &gt;= '0' &amp;&amp; hexChar &lt;= '9') {
   dec = hexChar - '0';        <span class="comment">// int 0-9</span>
} else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') {
   dec = hexChar - 'A' + 10;   <span class="comment">// int 10-15</span>
} else if (hexChar &gt;= 'a' &amp;&amp; hexChar &lt;= 'f') {
   dec = hexChar - 'a' + 10;   <span class="comment">// int 10-15</span>
} else {
   dec = -1;   <span class="comment">// to overcome variable have not been initialized error</span>
   System.out.println(&quot;Invalid hex char&quot;);
}
System.out.println(hexChar + ": " + dec);
</pre>




<h4><code>String</code> Operations</h4>

<p>The most commonly-used <code>String</code> methods are as follows, suppose that <code>str</code>, <code>str1</code>, <code>str2</code> are <code>String</code> variables:</p>

<ul>
<li><code><strong>str.length()</strong></code>: return the length of the <code>str</code>.</li>

<li><code><strong>str.charAt(int index)</strong></code>: return the <code>char</code> at the <code>index</code> position of the <code>str</code>. Take note that <code>index</code> begins at <code>0</code>, and up to <code>str.length()-1</code>.</li>

<li><strong><code>str1.equals(str2)</code></strong>: for comparing the contents of <code>str1</code> and <code>str2</code>. Take note that you cannot use <code>&quot;str1 == str2&quot;</code> to compare two <code>String</code>s. This is because &quot;<code>==</code>&quot; is only applicable to primitive types, but <code>String</code> is not a primitive type.</li>
</ul>

<p>For examples,</p>

<pre class="example">
String str = &quot;Java is cool!&quot;;
System.out.println(str.length());       <span class="comment">// return int 13</span>
System.out.println(str.charAt(2));      <span class="comment">// return char 'v'</span>
System.out.println(str.charAt(5));      <span class="comment">// return char 'i'</span>
&nbsp;
<span class="comment">// Comparing two Strings</span>
String anotherStr = &quot;Java is COOL!&quot;;
<span class="comment"></span>System.out.println(str.equals(anotherStr));           <span class="comment">// return boolean false</span>
System.out.println(str.equalsIgnoreCase(anotherStr)); <span class="comment">// return boolean true</span>
System.out.println(anotherStr.equals(str));           <span class="comment">// return boolean false</span>
System.out.println(anotherStr.equalsIgnoreCase(str)); <span class="comment">// return boolean true</span>
<span class="comment">// (str == anotherStr) to compare two Strings is WRONG!!!</span></pre>

<p>To check all the available methods for <code>String</code>, open JDK Documentation &rArr; Select &quot;API documentation&quot; &rArr; Click &quot;FRAMES&quot; (top menu) &rArr; From &quot;Modules&quot; (top-left pane), select &quot;<code>java.base</code>&quot; &rArr; From &quot;<code>java.base</code> Packages&quot; (top-left pane), select &quot;<code>java.lang</code>&quot; &rArr; From &quot;Classes&quot; (bottom-left pane), select &quot;<code>String</code>&quot; &rArr; choose &quot;SUMMARY&quot; &quot;METHOD&quot; (right pane) (@ <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/String.html">https://docs.oracle.com/javase/10/docs/api/java/lang/String.html</a> for JDK 10).</p>
<p>For examples,</p>

<pre class="example">
String str = &quot;Java is cool!&quot;;
System.out.println(str.length());            <span class="comment">// return int 13</span>
System.out.println(str.charAt(2));           <span class="comment">// return char 'v'</span>
System.out.println(str.substring(0, 3));     <span class="comment">// return String &quot;Jav&quot;</span>
System.out.println(str.indexOf('a'));        <span class="comment">// return int 1</span>
System.out.println(str.lastIndexOf('a'));    <span class="comment">// return int 3</span>
System.out.println(str.endsWith(&quot;cool!&quot;));   <span class="comment">// return boolean true</span>
System.out.println(str.toUpperCase());       <span class="comment">// return a new String &quot;JAVA IS COOL!&quot;</span>
System.out.println(str.toLowerCase());       <span class="comment">// return a new String &quot;java is cool!&quot;</span></pre>

<h4>Converting <code>String</code> to Primitive</h4>

<h5><code>String</code> to <code>int/byte/short/long</code></h5>

<p>You could use the JDK built-in methods <code>Integer.parseInt(<em>anIntStr</em>)</code> to convert a <code>String</code> containing a valid integer literal (e.g., &quot;<code>1234</code>&quot;) into an <code>int</code> (e.g., <code>1234</code>). The runtime triggers a <code>NumberFormatException</code> if the input string does not contain a valid integer literal (e.g., &quot;<code>abc</code>&quot;). For example,</p>

<pre class="example">
String inStr = &quot;5566&quot;;
int number = Integer.parseInt(inStr);   <span class="comment">// number &lt;- 5566</span>
<span class="comment">// Input to Integer.parseInt() must be a valid integer literal</span>
<span class="error">//number = Integer.parseInt(&quot;abc&quot;);</span>     <span class="comment">// Runtime Error: NumberFormatException</span></pre>

<p>Similarly, you could use methods <code>Byte.parseByte(<em>aByteStr</em>)</code>, <code>Short.parseShort(<em>aShortStr</em>)</code>, <code>Long.parseLong(<em>aLongStr</em>)</code> to convert a <code>String</code> containing a valid <code>byte</code>, <code>short</code> or <code>long</code> literal to the primitive type.</p>

<h5><code>String</code> to <code>double</code>/<code>float</code></h5>

<p>You could use <code>Double.parseDouble(<em>aDoubleStr</em>)</code> or <code>Float.parseFloat(<em>aFloatStr</em>)</code> to convert a <code>String</code> (containing a floating-point literal) into a <code>double</code> or <code>float</code>, e.g.</p>

<pre class="example">
String inStr = &quot;55.66&quot;;
float aFloat = Float.parseFloat(inStr);         <span class="comment">// aFloat &lt;- 55.66f</span>
double aDouble = Double.parseDouble(&quot;1.2345&quot;);  <span class="comment">// aDouble &lt;- 1.2345</span>
aDouble = Double.parseDouble(&quot;1.2e-3&quot;);         <span class="comment">// aDouble &lt;- 0.0012</span>
<span class="error"><span class="comment">// Input to Integer.parseInt() must be a valid double literal</span>
//aDouble = Double.parseDouble(&quot;abc&quot;);</span>          <span class="comment">// Runtime Error: NumberFormatException</span></pre>

<h5><code>String</code> to <code>char</code></h5>

<p>You can use <code><em>aStr</em>.charAt(<em>index</em>)</code> to extract individual character from a <code>String</code>, where <code><em>index</em></code> begins at <code>0</code> and up to <code>aStr.length()-1</code>, e.g.,</p>

<pre class="example">
<span class="comment">// Extract each char</span>
String msg = &quot;Hello, world&quot;;
char msgChar;
for (int idx = 0; idx &lt; msg.length(); ++idx) {
   msgChar = msg.charAt(idx);
   <span class="comment">// Do something about the extracted char</span>
   .......
}</pre>

<h5><code>String</code> to <code>boolean</code></h5>

<p>You can use method <code>Boolean.parseBoolean(<em>aBooleanStr</em>)</code> to convert string of &quot;<code>true</code>&quot; or &quot;<code>false</code>&quot; to <code>boolean</code> <code>true</code> or <code>false</code>, e.g.,</p>

<pre class="example">
String boolStr = &quot;true&quot;;
boolean done = Boolean.parseBoolean(boolStr);   <span class="comment">// done &lt;- true</span>
boolean valid = Boolean.parseBoolean(&quot;false&quot;);  <span class="comment">// valid &lt;- false</span></pre>

<h4>Converting Primitive to <code>String</code></h4>

<p>To convert a primitive to a <code>String</code>, you can:</p>
<ol>
<li>Use the '<code>+</code>' operator to concatenate the primitive with an <em>empty</em> <code>String &quot;&quot;</code>.</li>
<li>Use the JDK built-in methods <code>String.valueOf(<em>aPrimitive</em>)</code>, which is applicable to all primitives.</li>
<li>Use the <code>toString()</code> methods of the respective wrapper class, such as <code>Integer.toString(<em>anInt</em>)</code>, <code>Double.toString(<em>aDouble</em>)</code>, <code>Character.toString(<em>aChar</em>)</code>, <code>Boolean.toString(<em>aBoolean</em>)</code>, etc.</li>
</ol>
 
<p>For examples,</p>

<pre class="example">
<span class="comment">// Using String concatenation operator '+' with an empty String (applicable to ALL primitive types)</span>
String str1 = 123 + &quot;&quot;;    <span class="comment">// int 123 -&gt; String &quot;123&quot;</span>
String str2 = 12.34 + &quot;&quot;;  <span class="comment">// double 12.34 -&gt; String &quot;12.34&quot;</span>
String str3 = 'c' + &quot;&quot;;    <span class="comment">// char 'c' -&gt; String &quot;c&quot;</span>
String str4 = true + &quot;&quot;;   <span class="comment">// boolean true -&gt; String &quot;true&quot;</span>
 
<span class="comment">// Using String.valueOf(<em>aPrimitive</em>) (applicable to ALL primitive types)</span>
String str5 = String.valueOf(12345);   <span class="comment">// int 12345 -&gt; String &quot;12345&quot;</span>
String str6 = String.valueOf(true);    <span class="comment">// boolean true -&gt; String &quot;true&quot;</span>
String str7 = String.valueOf(55.66);   <span class="comment">// double 55.66 -&gt; String &quot;55.66&quot;</span>
 
<span class="comment">// Using toString() for each primitive type</span>
String str8 = Integer.toString(1234);   <span class="comment">// int 1234 -&gt; String &quot;1234&quot;</span>
String str9 = Double.toString(1.23);    <span class="comment">// double 1.23 -&gt; String &quot;1.23&quot;</span>
String str10 = Character.toString('z'); <span class="comment">// char 'z' -&gt; String &quot;z&quot;</span>
</pre>

<h4>Formatting <code>String</code>s - <code>String.format()</code></h4>

<p>Recall that you can use <code>printf()</code> to create a formatted string and send it to the display console, e.g.,</p>
<pre class="example">
System.out.printf("Hi, %d, %.1f%n", 11, 22.22);   <span class="comment">// Send the formatted String to console</span></pre>

<p>There is a similar function called <code>String.format()</code> which returns the formatted string, instead of sending to the console, e.g.,</p>
<pre class="example">
String str = String.format("%.1f", 1.234);   <span class="comment">// Returns a String &quot;1.2&quot; (for further operations)</span></pre>

<p><code>String.format()</code> has the same form as <code>printf()</code>.</p>


<h4>Code Example: Reverse String</h4>

<p>The following program prompts user a string, and prints the input string in the reverse order. For examples,</p>
<pre class="output">
Enter a String: <strong>abcdefg</strong>
The reverse is: gfedcba</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for a string; and print the input string in reverse order.
 */
public class ReverseString {
   public static void main(String[] args) {
      // Declare variables
      String inStr;   // input String
      int inStrLen;   // length of the input String

      // Prompt and read input as "String"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a String: ");
      inStr = in.next();
      inStrLen = inStr.length();
      in.close();

      System.out.print("The reverse is: ");
      // Use a for-loop to extract each char in reverse order
      for (int inCharIdx = inStrLen - 1; inCharIdx &gt;= 0; --inCharIdx) {
         System.out.print(inStr.charAt(inCharIdx));
      }
      System.out.println();
  }
}</code></pre>

<h4>Code Example: Validating Binary String</h4>

<p>The following program prompts user for a string, and checks if the input is a valid binary string, consisting of <code>'0'</code> and <code>'1'</code> only. For example,</p>

<pre class="output">
Enter a binary string: <strong>1011000</strong>
&quot;1011000&quot; is a binary string

Enter a binary string: <strong>10001900</strong>
&quot;10001900&quot; is NOT a binary string</pre>

<h5>Version 1: With a <code>boolean</code> flag</h5>

<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Check if the input string is a valid binary string.
 */
public class ValidateBinString {
   public static void main(String[] args) {
      // Declare variables
      String inStr;     // The input string
      int inStrLen;     // The length of the input string
      char inChar;      // Each char of the input string
      boolean isValid;  // "is" or "is not" a valid binary string?

      // Prompt and read input as "String"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a binary string: ");
      inStr = in.next();
      inStrLen = inStr.length();
      in.close();

      isValid = true;  // Assume that the input is valid, unless our check fails
      for (int inCharIdx = 0; inCharIdx &lt; inStrLen; ++inCharIdx) {
         inChar = inStr.charAt(inCharIdx);
         if (!(inChar == '0' || inChar == '1')) {
            isValid = false;
            break;  // break the loop upon first error, no need to continue for more errors
                    // If this is not encountered, isValid remains true after the loop.
         }
      }
      System.out.println("\"" + inStr + "\" is " + (isValid ? "" : "NOT ") + "a binary string");
   }
}</code></pre>

<h5>Version 2</h5>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Check if the input string is a valid binary string.
 */
public class ValidateBinStringV2 {
   public static void main(String[] args) {
      // Declare variables
      String inStr;     // The input string
      int inStrLen;     // The length of the input string
      char inChar;      // Each char of the input string

      // Prompt and read input as "String"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a binary string: ");
      inStr = in.next();
      inStrLen = inStr.length();
      in.close();

      for (int inCharIdx = 0; inCharIdx &lt; inStrLen; ++inCharIdx) {
         inChar = inStr.charAt(inCharIdx);
         if (!(inChar == '0' || inChar == '1')) {
            System.out.println("\"" + inStr + "\" is NOT a binary string");
            return;  // exit the program upon the first error detected
         }
      }
      // for-loop completed. No error detected.
      System.out.println("\"" + inStr + "\" is a binary string");
   }
}</code></pre>

<p>This version, although shorter, are harder to read, and harder to maintain.</p>

<h4>Code Example: Binary to Decimal (Bin2Dec)</h4>

<p>The following program prompts user for a binary string, and converts into its equivalent decimal number. For example,</p>
<pre class="output">
Enter a binary string: <strong>10001001</strong>
The equivalent decimal for &quot;10001001&quot; is 137</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for a binary string, and convert into its equivalent decimal number.
 */
public class Bin2Dec {
   public static void main(String[] args) {
      // Declare variables
      String binStr;  // The input binary string
      int binStrLen;  // The length of binStr
      int dec = 0;    // The decimal equivalent, to accumulate from 0
      char binChar;   // Each individual char of the binStr

      // Prompt and read input as "String"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a binary string: ");
      binStr = in.next();
      binStrLen = binStr.length();
      in.close();

      // Process char by char from the right (i.e. Least-significant bit)
      // using exponent as loop index.
      for (int exp = 0; exp &lt; binStrLen ; ++exp) {
         binChar = binStr.charAt(binStrLen - 1 - exp);
         // 3 cases: '1' (add to dec), '0' (valid but do nothing), other (error)
         if (binChar == '1') {
            dec += (int)Math.pow(2, exp);  // cast the double result back to int
         } else if (binChar == '0') {
         } else {
            System.out.println("error: invalid binary string \"" + binStr + "\"");
            return;           // or System.exit(1);
         }
      }

      // Print result
      System.out.println("The equivalent decimal for \"" + binStr + "\" is " + dec);
   }
}</code></pre>

<p>Notes:</p>

<ol>
<li>The conversion formula is:
<pre class="syntax">
binStr = b<sub>n-1</sub>b<sub>n-2</sub>....b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> h<sub>i</sub>∈{0,1} where b<sub>0</sub> is the least-significant bit

dec = b<sub>n-1</sub>&times;2<sup>n-1</sup> + b<sub>n-2</sub>&times;2<sup>n-2</sup> + ... + b<sub>2</sub>&times;2<sup>2</sup> + b<sub>1</sub>&times;2<sup>1</sup> + b<sub>0</sub>&times;2<sup>0</sup></pre>
</li>

<li>We use <code>binStr.charAt(idx)</code> to extract each individual <code>char</code> from the <code>binStr</code>. The <code>idx</code> begins at zero, and increases from left-to-right. On the other hand, the exponent number increases from right-to-left, as illustrated in the following example:
  <pre class="example-light">
binStr             : 1 0 1 1 1 0 0 1
charAt(idx)        : 0 1 2 3 4 5 6 7  (idx increases from the left)
Math.pow(2, exp)   : 7 6 5 4 3 2 1 0  (exp increases from the right)
 
binStr.length() = 8
<strong>idx + exp = binStr.length() - 1</strong></pre>
</li>

<li>This code uses <code>exp</code> as the loop index, and computes the  <code>idx</code> for <code>charAt()</code> using the relationship <code>idx + exp = binStr.length() - 1</code>. You could also use the <code>idx</code> as the loop index (see next example).</li>
<li>We use the built-in function <code>Math.pow(x, y)</code> to compute the exponent, which takes two <code>double</code>s and return a <code>double</code>. We need to explicitly cast the resultant <code>double</code> back to <code>int</code> for <code>dec</code>.</li>
<li>There are 3 cases to handle: <code>'1'</code> (add to <code>dec</code>), <code>'0'</code> (valid but do nothing for multiply by <code>0</code>) and other (error). We can write the nested-if as follows, but that is harder to read:
  <pre class="example">if (binChar == '1') {
   dec += (int)Math.pow(2, exp);  <span class="comment">// cast the double result back to int</span>
} else if (binChar != '0') {
   System.out.println(&quot;error: invalid binary string \&quot;&quot; + binStr + &quot;\&quot;&quot;);
   return;           <span class="comment">// or System.exit(1);</span>
}    <span class="comment">// else (binChar == '0') do nothing</span></pre></li>

<li>You can  use <code>Scanner</code>'s <code>nextInt(int <em>radix</em>)</code> method to read an <code>int</code> in the desired <code><em>radix</em></code>. Try reading a binary number (radix of 2) and print its decimal equivalent. For example,
  <pre class="example">
number = in.nextInt(2);      <span class="comment">// Input in binary e.g., 10110100</span>
System.out.println(number);  <span class="comment">// 180</span></pre>
</li>

</ol>


<h4>Code Example: Hexadecimal to Decimal (Hex2Dec)</h4>

<p>The following program prompts user for a hexadecimal string and converts into its equivalent decimal number. For example,</p>
<pre class="output">
Enter a Hexadecimal string: <strong>10aB</strong>
The equivalent decimal for &quot;10aB&quot; is 4267</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for the hexadecimal string, and convert to its equivalent decimal number
 */
public class Hex2Dec {
   public static void main(String[] args) {
      // Declare variables
      String hexStr;   // The input hexadecimal String
      int hexStrLen;   // The length of hexStr
      int dec = 0;     // The decimal equivalent, to accumulate from 0

      // Prompt and Read input as "String"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a Hexadecimal string: ");
      hexStr = in.next();
      hexStrLen = hexStr.length();
      in.close();

      // Process char by char from the left (most-significant digit)
      for (int charIdx = 0; charIdx &lt; hexStrLen; ++charIdx) {
         char hexChar = hexStr.charAt(charIdx);
         int expFactor = (int)Math.pow(16, hexStrLen - 1 - charIdx);
         // 23 cases: '0'-'9', 'a'-'f', 'A'-'F', other (error)
         if (hexChar == '0') {
            // Valid but do nothing
         } else if (hexChar &gt;= '1' &amp;&amp; hexChar &lt;= '9') {
            dec += (hexChar - '0') * expFactor;   // Convert char '0'-'9' to int 0-9
         } else if (hexChar &gt;= 'a' &amp;&amp; hexChar &lt;= 'f') {
            dec += (hexChar - 'a' + 10) * expFactor;  // Convert char 'a'-'f' to int 10-15
         } else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') {
            dec += (hexChar - 'A' + 10) * expFactor;  // Convert char 'A'-'F' to int 10-15
         } else {
            System.out.println("error: invalid hex string \"" + hexStr + "\"");
            return;   // or System.exit(1);
         }
      }
      System.out.println("The equivalent decimal for \"" + hexStr + "\" is " + dec);
   }
}</code></pre>

<p>Notes:</p>

<ol>
<li>The conversion formula is:
<pre class="syntax">
hexStr = h<sub>n-1</sub>h<sub>n-2</sub>....h<sub>2</sub>b<sub>1</sub>h<sub>0</sub>  h<sub>i</sub>∈{0,..,9,A,..,F} where h<sub>0</sub> is the least-significant digit

dec = h<sub>n-1</sub>&times;16<sup>n-1</sup> + h<sub>n-2</sub>&times;16<sup>n-2</sup> + ... + h<sub>2</sub>&times;16<sup>2</sup> + h<sub>1</sub>&times;16<sup>1</sup> + h<sub>0</sub>&times;16<sup>0</sup></pre>
</li>

<li>In this example, we use the <code>charIdx</code> as the loop index, and compute the exponent via the relationship <code>charIdx + exp = hexStr.length() - 1</code> (See the illustration in the earlier example).</li>
<li>You could write a big <code>switch</code> of 23 <code>case</code>s (<code>0-9</code>, <code>A-F</code>, <code>a-f</code>, and other). But take note how they are reduced to 5 cases.
<ol>
<li>To convert <code>hexChar</code> <code>'1'</code> to <code>'9'</code> to <code>int</code> <code>1</code> to <code>9</code>, we subtract the <code>hexChar</code> by the base <code>'0'</code>.</li>
<li>Similarly, to convert <code>hexChar</code> <code>'a'</code> to <code>'f'</code> (or <code>'A'</code> to <code>'F'</code>) to <code>int</code> <code>10</code> to <code>15</code>, we subtract the <code>hexChar</code> by the base <code>'a'</code> (or <code>'A'</code>) and add <code>10</code>.</li></ol></li>

<li>You may use <code>str.toLowerCase()</code> to convert the input string to lowercase to further reduce the number of cases. But You need to keep the original <code>String</code> for output in this example (otherwise, you could use <code>in.next().toLowerCase()</code> directly).</li>

</ol>

<h4>Exercises on <code>String</code> and <code>char</code> operations</h4>
<p><a href="J2a_BasicsExercises.html#ExerciseStringChar">LINK</a></p>


<h3>Arrays</h3>
<p>Suppose that you want to find the average of the marks for a class of 30 students, you certainly do not want to create 30 variables: <code>mark1</code>, <code>mark2</code>, ..., <code>mark30</code>. Instead, You could use a single variable, called an <em>array</em>, with 30 elements (or items).</p>

<p>An array is <em>an ordered collection of elements of the same type</em>, identified by a pair of square brackets <code>[ ]</code>.  To use an array, you need to:</p>

<ol>
<li><em>Declare</em> the array with a <em>name</em> and a <em>type</em>. Use a plural name for array, e.g., <code>marks</code>, <code>rows</code>, <code>numbers</code>. All elements of the array belong to the same type.</li>

<li><em>Allocate</em> the array using <code>new</code> operator, or through <em>initialization</em>, e.g.,
  <pre class="example">
int[] marks;  <span class="comment">// Declare an int array named &quot;marks&quot;
              // &quot;marks&quot; is assigned to a special value called &quot;null&quot; before allocation</span>
int marks[];  <span class="comment">// Same as above, but the above syntax recommended</span>
marks = new int[5];   <span class="comment">// Allocate 5 elements via the &quot;new&quot; operator</span>
<span class="comment">// Declare and allocate a 20-element array in one statement via &quot;new&quot; operator</span>
int[] factors = new int[20];
<span class="comment">// Declare, allocate a 6-element array thru initialization</span>
int[] numbers = {11, 22, 33, 44, 55, 66}; <span class="comment">// size of array deduced from the number of items</span></pre>
</li>
</ol>

<p>When an array is constructed via the <code>new</code> operator, all the elements are initialized to their default value, e.g., <code>0</code> for <code>int</code>, <code>0.0</code> for <code>double</code>, <code>false</code> for <code>boolean</code>, and <code>null</code> for objects. [Unlike C/C++, which does NOT initialize the array contents.]</p>

<p>When an array is declared but not allocated, it has a special value called <code>null</code>.</p>

<h4>Array Index</h4>

<p>You can refer to an element of an array via an <em>index</em> (or <em>subscript</em>) enclosed within the square bracket <code>[ ]</code>.  Java's array index begins with zero (<code>0</code>). For example, suppose that <code>marks</code> is an <code>int</code> array of 5 elements, then the 5 elements are: <code>marks[0]</code>, <code>marks[1]</code>, <code>marks[2]</code>, <code>marks[3]</code>, and <code>marks[4]</code>.</p>

<pre class="example">
int[] marks = new int[5];   <span class="comment">// Declare &amp; allocate a 5-element int array</span>
<span class="comment">// Assign values to the elements</span>
marks[0] = 95;
marks[1] = 85;
marks[2] = 77;
marks[3] = 69;
marks[4] = 66;
<span class="comment">// Retrieve elements of the array</span>
System.out.println(marks[0]);
System.out.println(marks[3] + marks[4]);</pre>

<h4>Array's <code>length</code></h4>

<p>To create an array, you need to known the <em>length</em> (or <em>size</em>) of the array in advance, and allocate accordingly.  Once an array is created, its length is fixed and cannot be changed during runtime. At times, it is hard to ascertain the length of an array (e.g., how many students?). Nonetheless, you need to estimate the length and allocate an upper bound. Suppose you set the length  to 30 (for a class of students) and there are 31 students, you need to allocate a new array (of length 31), copy the old array to the new array, and delete the old array. In other words, the length of an array cannot be dynamically adjusted during runtime. This  is probably the major drawback of using an array. (There are other structures that can be dynamically adjusted.)</p>

<p>In Java, the length of array is kept in an <em>associated variable</em> called <code>length</code> and can be retrieved using &quot;<code><em>arrayName</em>.length</code>&quot;, e.g.,</p>

<pre class="example">
int[] factors = new int[5];       <span class="comment">// Declare and allocate a 5-element int array</span>
int numFactors = factors.length;  <span class="comment">// numFactor is 5</span></pre>

<img src="images/JavaBasics_array.png" alt="array" width="451" height="172" class="image-float-right" />

<p>The index of an array is between <code>0</code> and <code><em>arrayName</em>.length - 1</code>.</p>

<p>Unlike languages like C/C++, Java performs array <em>index-bound check</em> at the <em>runtime</em>.  In other words, for each reference to an array element, the index is checked against the array's <code>length</code>.  If the index is outside the range of <code>[0, arrayName.length-1]</code>, Java Runtime will signal an exception called <code> ArrayIndexOutOfBoundException</code>. It is important to note that checking array index-bound consumes computation power, which inevitably slows down the processing.  However, the benefits gained in terms of good software engineering out-weight the slow down in speed.</p>

<h4>Array and Loop</h4>

<p>Arrays works hand-in-hand with loops. You can process all the elements of an array via a loop, for example,</p>
	
<pre><code class="language-java line-numbers">/**
 * Find the mean and standard deviation of numbers kept in an array
 */
public class MeanSDArray {
   public static void main(String[] args) {
      // Declare variable
      int[] marks = {74, 43, 58, 60, 90, 64, 70};
      int sum = 0;
      int sumSq = 0;
      double mean, stdDev;
 
      // Compute sum and square-sum using loop
      for (int i = 0; i &lt; marks.length; ++i) {
         sum += marks[i];
         sumSq += marks[i] * marks[i];
      }
      mean = (double)sum / marks.length;
      stdDev = Math.sqrt((double)sumSq / marks.length - mean * mean);
 
      // Print results
      System.out.printf("Mean is: %.2f%n", mean);
      System.out.printf("Standard deviation is: %.2f%n", stdDev);
   }
}</code></pre>

<h4>Enhanced for-loop (or &quot;for-each&quot; Loop) (JDK 5)</h4>

<p>JDK 5 introduces a new loop syntax known as <em>enhanced for-loop</em> (or <em>for-each</em> loop) to facilitate processing of arrays and collections. It takes the following syntax:</p>

<table class="table-zebra code">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>

<tr>
<td>
<pre><span class="highlight">for (</span><em>type item</em> <span class="highlight">:</span> <em>anArray</em><span class="highlight">) {</span>
   <em>body</em>;
<span class="highlight">}</span>
<span class="comment">  // <em>type</em> must be the same as the
  // <em>anArray</em>'s type</span></pre></td>

<td><pre>int[] numbers = {8, 2, 6, 4, 3};
int sum = 0, sumSq = 0;
for (int number : numbers) {   <span class="comment">// for each int number in int[] numbers</span>
   sum += number;
   sumSq += number * number;
}
System.out.println(&quot;The sum is: &quot; + sum);
System.out.println(&quot;The square sum is: &quot; + sumSq);</pre>
</td>
</tr>
</table>

<p>This loop shall be read as &quot;for each element in the array...&quot;. The loop executes once for each element in the array, with the element's value copied into the declared variable. The for-each loop is handy to transverse all the elements of an array. It requires fewer lines of code, eliminates the loop counter and the array index, and is easier to read. However, for array of primitive types (e.g., array of <code>int</code>s), it can <em>read</em> the elements only, and cannot <em>modify</em> the array's contents. This is because each element's value is copied into the loop's variable, instead of working on its original copy.</p>

<p>In many situations, you merely want to transverse thru the array and read each of the elements. For these cases, enhanced for-loop is preferred and recommended over other loop constructs.</p>

<h4>Code Example: Read and Print Array</h4>
<p>The following program prompts user for the length and all the elements of an array, and print the array in the form of <code>[a0, a1, ..., an]</code>. For examples,</p>

<pre class="output">
Enter the number of items: <strong>5</strong>
Enter the value of all items (separated by space): <strong>7 9 1 6 2</strong>
The values are: [7, 9, 1, 6, 2]</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for the length and all the elements of an array; and print [a1, a2, ..., an]
 */
public class ReadPrintArray {
   public static void main(String[] args) {
      // Declare variables
      final int NUM_ITEMS;
      int[] items;   // Declare array name, to be allocated after numItems is known

      Scanner in = new Scanner(System.in);
      // Prompt for a non-negative integer for the number of items;
      // and read the input as "int". No input validation.
      System.out.print("Enter the number of items: ");
      NUM_ITEMS = in.nextInt();

      // Allocate the array
      items = new int[NUM_ITEMS];

      // Prompt and read the items into the "int" array, only if array length &gt; 0
      if (items.length &gt; 0) {
         System.out.print("Enter the value of all items (separated by space): ");
         for (int i = 0; i &lt; items.length; ++i) {
            items[i] = in.nextInt();
         }
      }
      in.close();

      // Print array contents, need to handle first item and subsequent items differently
      System.out.print("The values are: [");
      for (int i = 0; i &lt; items.length; ++i) {
         if (i == 0) {
            // Print the first item without a leading commas
            System.out.print(items[0]);
         } else {
            // Print the subsequent items with a leading commas
            System.out.print(", " + items[i]);
         }
      }
      System.out.println("]");
   }
}</code></pre>

<h5><code>Arrays.toString()</code> (JDK 5)</h5>

<p>JDK 5 provides an built-in methods called <code>Arrays.toString(<em>anArray</em>)</code>, which returns a <code>String</code> in the form <code>[a0, a1, ..., an]</code>. You need to <code>import java.util.Arrays</code>. For examples,</p>

<pre class="example">
<span class="new">import java.util.Arrays;</span>   <span class="comment">// Needed to use Arrays.toString()</span>
<span class="comment">/**
 * Use Arrays.toString() to print an array in the form of [a1, a2, ..., an]
 */</span>
public class <strong>TestArrayToString</strong> {
   public static void main(String[] args) {
      <span class="comment">// Declare and allocate test arrays</span>
      int[] a1 = {6 ,1, 3, 4, 5};   <span class="comment">// Allocate via initialization</span>
      int[] a2 = {};                <span class="comment">// Empty array with length = 0</span>
      double[] a3 = new double[1];  <span class="comment">// One-Element array, init to 0.0</span>

      System.out.println(<span class="new">Arrays.toString(a1)</span>);  <span class="comment">//<span class="output">[6, 1, 3, 4, 5]</span></span>
      System.out.println(<span class="new">Arrays.toString(a2)</span>);  <span class="comment">//<span class="output">[]</span></span>
      System.out.println(<span class="new">Arrays.toString(a3)</span>);  <span class="comment">//<span class="output">[0.0]</span></span>
      a3[0] = 2.2;
      System.out.println(<span class="new">Arrays.toString(a3)</span>);  <span class="comment">//<span class="output">[2.2]</span></span>
   }
}</pre>

<h4>Code Example: Horizontal and Vertical Histograms</h4>
<p>The following program prompts user for the number of students, and the grade of each student. It then print the histogram, in horizontal and vertical forms, as follows:</p>
<pre class="output">
Enter the grade for student 1: 98
Enter the grade for student 2: 100
Enter the grade for student 3: 9
Enter the grade for student 4: 3
Enter the grade for student 5: 56
Enter the grade for student 6: 58
Enter the grade for student 7: 59
Enter the grade for student 8: 87

 0-  9: **
10- 19:
20- 29:
30- 39:
40- 49:
50- 59: ***
60- 69:
70- 79:
80- 89: *
90-100: **

                                      *
   *                                  *                           *
   *                                  *                    *      *
  0-9   10-19  20-29  30-39  40-49  50-59  60-69  70-79  80-89  90-100</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
import java.util.Arrays;   // for Arrays.toString()
/**
 * Print the horizontal and vertical histograms of grades.
 */
public class GradesHistograms {
   public static void main(String[] args) {
      // Declare variables
      int numStudents;
      int[] grades;  // Declare array name, to be allocated after numStudents is known
      int[] bins = new int[10];  // int array of 10 histogram bins for 0-9, 10-19, ..., 90-100

      Scanner in = new Scanner(System.in);
      // Prompt and read the number of students as "int"
      System.out.print("Enter the number of students: ");
      numStudents = in.nextInt();

      // Allocate the array
      grades = new int[numStudents];

      // Prompt and read the grades into the int array "grades"
      for (int i = 0; i &lt; grades.length; ++i) {
         System.out.print("Enter the grade for student " + (i + 1) + ": ");
         grades[i] = in.nextInt();
      }
      in.close();

      // Print array for debugging
      System.out.println(Arrays.toString(grades));

      // Populate the histogram bins
      for (int grade : grades) {
         if (grade == 100) {   // Need to handle 90-100 separately as it has 11 items.
            ++bins[9];
         } else {
            ++bins[grade/10];
         }
      }
      // Print array for debugging
      System.out.println(Arrays.toString(bins));

      // Print the horizontal histogram
      // Rows are the histogram bins[0] to bins[9]
      // Columns are the counts in each bins[i]
      for (int binIdx = 0; binIdx &lt; bins.length; ++binIdx) {
         // Print label
         if (binIdx != 9) {  // Need to handle 90-100 separately as it has 11 items
            System.out.printf("%2d-%3d: ", binIdx*10, binIdx*10+9);
         } else {
            System.out.printf("%2d-%3d: ", 90, 100);
         }
         // Print columns of stars
         for (int itemNo = 0; itemNo &lt; bins[binIdx]; ++itemNo) {  // one star per item
            System.out.print("*");
         }
         System.out.println();
      }

      // Find the max value among the bins
      int binMax = bins[0];
      for (int binIdx = 1; binIdx &lt; bins.length; ++binIdx) {
         if (binMax &lt; bins[binIdx]) binMax = bins[binIdx];
      }

      // Print the Vertical histogram
      // Columns are the histogram bins[0] to bins[9]
      // Rows are the levels from binMax down to 1
      for (int level = binMax; level &gt; 0; --level) {
         for (int binIdx = 0; binIdx &lt; bins.length; ++binIdx) {
            if (bins[binIdx] &gt;= level) {
               System.out.print("   *   ");
            } else {
               System.out.print("       ");
            }
         }
         System.out.println();
      }
      // Print label
      for (int binIdx = 0; binIdx &lt; bins.length; ++binIdx) {
         System.out.printf("%3d-%-3d", binIdx*10, (binIdx != 9) ? binIdx * 10 + 9 : 100);
            // Use '-' flag for left-aligned
      }
      System.out.println();
   }
}</code></pre>

<h5>Notes:</h5>

<ol>
<li>We use two arrays in this exercise, one for storing the grades of the students (of the length <code>numStudents</code>) and the other to storing the histogram counts (of length <code>10</code>).</li>
<li>We use a <code>10</code>-element <code>int</code> arrays called <code>bins</code>, to keep the histogram counts for grades of <code>[0, 9]</code>, <code>[10, 19]</code>, ..., <code>[90, 100]</code>. Take note that there are <code>101</code> grades between <code>[0, 100]</code>, and the last bin has <code>11</code> grades (instead of 10 for the rest). The <code>bins</code>'s index is <code>grade/10</code>, except <code>grade</code> of <code>100</code>.</li>


</ol>


<h4>Code Example: Hexadecimal to Binary (<code>Hex2Bin</code>)</h4>

<p>The following program prompts user for a hexadecimal string and convert it to its binary equivalence. For example,</p>

<pre class="output">
Enter a Hexadecimal string: <strong>1bE3</strong>
The equivalent binary for "1bE3" is "0001101111100011"</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for a hexadecimal string, and print its binary equivalent.
 */
public class Hex2Bin {
   public static void main(String[] args) {
      // Define variables
      String hexStr;     // The input hexadecimal String
      int hexStrLen;     // The length of hexStr
      char hexChar;      // Each char in the hexStr
      String binStr =""; // The equivalent binary String, to accumulate from an empty String
      // Lookup table for the binary sub-string corresponding to Hex digit '0' (index 0) to 'F' (index 15)
      final String[] BIN_STRS =
         {"0000", "0001", "0010", "0011",
          "0100", "0101", "0110", "0111",
          "1000", "1001", "1010", "1011",
          "1100", "1101", "1110", "1111"};

      // Prompt and read input as "String"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a Hexadecimal string: ");
      hexStr = in.next();
      hexStrLen = hexStr.length();
      in.close();

      // Process the string from the left (most-significant hex digit)
      for (int charIdx = 0; charIdx &lt; hexStrLen; ++charIdx) {
         hexChar = hexStr.charAt(charIdx);
         if (hexChar &gt;= '0' &amp;&amp; hexChar &lt;= '9') {
            binStr += BIN_STRS[hexChar - '0'];  // index into the BIN_STRS array and concatenate
         } else if (hexChar &gt;= 'a' &amp;&amp; hexChar &lt;= 'f') {
            binStr += BIN_STRS[hexChar - 'a' + 10];
         } else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') {
            binStr += BIN_STRS[hexChar - 'A' + 10];
         } else {
            System.err.println("error: invalid hex string \"" + hexStr + "\"");
            return;   // or System.exit(1);
         }
      }
      System.out.println("The equivalent binary for \"" + hexStr + "\" is \"" + binStr + "\"");
   }
}</code></pre>

<h5>Notes</h5>

<ol>
<li>We keep the binary string corresponding to hex digit <code>'0'</code> to <code>'F'</code> in an array with indexes of <code>0-15</code>, used as look-up table.</li>
<li>We extract each <code>hexChar</code>, find its array index (<code>0-15</code>), and retrieve the binary string from the array based on the index.
  <ol>
<li>To convert <code>hexChar</code> <code>'1'</code> to <code>'9'</code> to <code>int</code> <code>1</code> to <code>9</code>, we subtract the <code>hexChar</code> by the base <code>'0'</code>.</li>
<li>Similarly, to convert <code>hexChar</code> <code>'a'</code> to <code>'f'</code> (or <code>'A'</code> to <code>'F'</code>) to <code>int</code> <code>10</code> to <code>15</code>, we subtract the <code>hexChar</code> by the base <code>'a'</code> (or <code>'A'</code>) and add <code>10</code>.</li></ol>
</li>
</ol>

<h4>Code Example: Decimal to Hexadecimal (<code>Dec2Hex</code>)</h4>

<p>The following program prompts user for an integer, reads as <code>int</code>, and prints its hexadecimal equivalent. For example,</p>
<pre class="output">
Enter a decimal number: <strong>1234</strong>
The equivalent hexadecimal number is 4D2</pre>

<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Prompt user for an int, and print its equivalent hexadecimal number.
 */
public class Dec2Hex {
   public static void main(String[] args) {
      // Declare variables
      int dec;              // The input decimal number in "int"
      String hexStr = "";   // The equivalent hex String, to accumulate from an empty String
      int radix = 16;       // Hex radix
      final char[] HEX_CHARS =     // Use this array as lookup table for converting 0-15 to 0-9A-F
         {'0','1','2','3', '4','5','6','7', '8','9','A','B', 'C','D','E','F'};
   
      // Prompt and read input as "int"
      Scanner in = new Scanner(System.in);
      System.out.print("Enter a decimal number: ");
      dec = in.nextInt();
      in.close();
   
      // Repeated modulus/division and get the hex digits (0-15) in reverse order
      while (dec &gt; 0) {
         int hexDigit = dec % radix;   // 0-15
         hexStr = HEX_CHARS[hexDigit] + hexStr;  // Append in front of the hex string corresponds to reverse order
         dec = dec / radix;
      }
      System.out.println("The equivalent hexadecimal number is " + hexStr);
   }
}</code></pre>

<h5>Notes</h5>

<ol>
<li>We use modulus/divide algorithm to get the hex digits (<code>0-15</code>) in reserve order. See &quot;Number System Conversion&quot;.</li>
<li>We look up the hex digit <code>'0'-'F'</code> from an array using index <code>0-15</code>.</li>
</ol>


<h4>Exercises on Arrays</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseArray">LINK</a></p>

<h4>Multi-Dimensional Array</h4>

<p>In Java, you can declare an array of arrays. For examples:</p>

<pre class="example">
int grid[][] = new int[12][8];   <span class="comment">// a 12&times;8 grid of int</span>
grid[0][0] = 8;
grid[1][1] = 5;
System.out.println(grid.length);      <span class="comment">// 12</span>
System.out.println(grid[0].length);   <span class="comment">// 8</span>
System.out.println(grid[11].length);  <span class="comment">// 8</span></pre>

<p>In the above example, <code>grid</code> is an array of 12 elements. Each of the elements (<code>grid[0]</code> to <code>grid[11]</code>) is an 8-element <code>int</code> array. In other words, <code>grid</code> is a &quot;12-element array&quot; of &quot;8-element int arrays&quot;. Hence, <code>grid.length</code> gives <code>12</code> and <code>grid[0].length</code> gives <code>8</code>.</p>
	
<pre><code class="language-java line-numbers">public class Array2DTest {
   public static void main(String[] args) {
      int[][] grid = new int[12][8];   // A 12x8 grid, in [row][col] or [y][x]
      final int NUM_ROWS = grid.length;       // 12
      final int NUM_COLS = grid[0].length;    // 8
   
      // Fill in grid
      for (int row = 0; row &lt; NUM_ROWS; ++row) {
         for (int col = 0; col &lt; NUM_COLS; ++col) {
            grid[row][col] = row*NUM_COLS + col + 1;
         }
      }
   
      // Print grid
      for (int row = 0; row &lt; NUM_ROWS; ++row) {
         for (int col = 0; col &lt; NUM_COLS; ++col) {
            System.out.printf("%3d", grid[row][col]);
         }
         System.out.println();
      }
   }
}</code></pre>

<img src="images/Array_MultiDimensional.png" alt="Array_MultiDimensional.png" width="440" height="226" class="image-float-right" />

<p>To be precise, Java does not support multi-dimensional array directly. That is, it does not support syntax like <code>grid[3, 2]</code> like some languages. Furthermore, it is possible that the arrays in an array-of-arrays have different length.</p>

<p>Take note that the right way to view the &quot;array of arrays&quot; is as shown, instead of treating it as a 2D table, even if all the arrays have the same length.</p>

<p>For example,</p>
	
<pre><code class="language-java line-numbers">public class Array2DWithDifferentLength {
   public static void main(String[] args) {
      int[][] grid = {
         {1, 2},
         {3, 4, 5},
         {6, 7, 8, 9}
      };
 
      // Print grid
      for (int y = 0; y &lt; grid.length; ++y) {
         for (int x = 0; x &lt; grid[y].length; ++x) {
            System.out.printf("%2d", grid[y][x]);
         }
         System.out.println();
      }
 
      // Another 2D array
      int[][] grid1 = new int[3][];
      grid1[0] = new int[2];
      grid1[1] = new int[3];
      grid1[2] = new int[4];
 
      // Print grid - all elements init to 0
      for (int y = 0; y &lt; grid1.length; ++y) {
         for (int x = 0; x &lt; grid1[y].length; ++x) {
            System.out.printf("%2d", grid1[y][x]);
         }
         System.out.println();
      }
   }
}</code></pre>

<h3>Methods (Functions)</h3>

<h4>Why Methods?</h4>

<p>At times, a certain portion of code has to be used many times. Instead of re-writing the code many times, it is better to put them into a &quot;subroutine&quot;, and &quot;call&quot; this &quot;subroutine&quot; many time - for ease of maintenance and understanding. Subroutine is  called method (in Java) or function (in C/C++).</p>

<p>The benefits of using methods are:</p>

<ol>
<li><em>Divide and conquer</em>: Construct the program from simple, small pieces or components.  Modularize the program into self-contained tasks.</li>

<li><em>Avoid repeating code</em>: It is easy to copy and paste, but hard to maintain and synchronize all the copies.</li>

<li><em>Software Reuse</em>: You can reuse the methods in other programs, by packaging them into library code (or API).</li>
</ol>

<h4>Using Methods</h4>

<p>Two parties are involved in using a method: a <em>caller</em>, who <em>calls</em> (or <em>invokes</em>) the method, and the <em>method</em> called.</p>
<p>The process is:</p>

<ol>
<li>The caller invokes a method and passes <em>arguments</em> to the method.</li>
<li>The method:
<ol>
<li>receives the arguments passed by the caller,</li>
<li>performs the programmed operations defined in the method's body, and</li>
<li>returns a result back to the caller.</li>
</ol>
</li>
<li>The caller receives the result, and continue its operations.</li>
</ol>

<p><span class="lead">Example:</span> Suppose that we need to evaluate the area of a circle many times, it is better to write a method called <code>getArea()</code>, and re-use it when needed.</p>
	
<pre data-line="6,9,12,17-19"><code class="language-java line-numbers">public class EgMethodGetArea {
   // The entry main method
   public static void main(String[] args) {
      double r = 1.1, area, area2;
      // Call (Invoke) method getArea() and return
      area = getArea(r);
      System.out.println("area is " + area);
      // Call method getArea() again and return
      area2 = getArea(2.2);
      System.out.println("area 2 is " + area2);
      // Call method getArea() one more time and return
      System.out.println("area 3 is " + getArea(3.3));
   }
 
   // Method getArea() Definition.
   // Compute and return the area (in double) of circle given its radius (in double).
   public static double getArea(double radius) {
      return radius * radius * Math.PI;
   }
}</code></pre>

<img src="images/Method.png" alt="Method.png" width="607" height="203" class="image-left" />

<p>The expected outputs are:</p>
<pre class="output">
area is 3.8013271108436504
area 2 is 15.205308443374602
area 3 is 34.21194399759284</pre>

<p>In the above example, a reusable method called <code>getArea()</code> is defined, which receives an argument in <code>double</code> from the caller, performs the calculation, and return a <code>double</code> result to the caller.  In the <code>main()</code>, we invoke <code>getArea()</code> methods thrice, each time with a different parameter.</p>
<p>Take note that there is a transfer of control from the caller to the method called, and from the method back to the caller, as illustrated.</p>

<img src="images/MethodTransferControl.png" alt="Method.png" width="456" height="208" class="image-left" />

<h5>Tracing Method Invocation</h5>

<p>You can trace method operations under Eclipse/NetBeans (Refer to the the Eclipse/NetBeans How-to article):</p>
<ul>
<li><strong>Step Over</strong>: Treat the method call as one single step.</li>
<li><strong>Step Into</strong>: Step into the method, so that you can trace the operations of the method.</li>
<li><strong>Step Out</strong>: Complete the current method and return to the caller.</li>
<li>Set &quot;<strong>Breakpoints</strong>&quot; inside the method, and &quot;resume&quot; running to the next breakpoint.</li>
</ul>


<h5>Method Definition Syntax</h5>

<p>The syntax for method definition is as follows:</p>

<pre class="syntax">
<span class="highlight">public static</span> <em>returnValueTyp</em>e <em>methodName</em><span class="highlight">(</span><em>arg-1-type arg-1</em>, <em>arg-2-type arg-2</em>,... <span class="highlight">) {</span>
   <em>body</em>;
<span class="highlight">}</span></pre>
<pre class="example"><span class="comment">// Examples
// Return circle's area given its radius</span>
public static double <strong>getArea</strong>(double radius) {
   return radius * radius * Math.PI;
}

<span class="comment">// Return maximum among two given integers</span>
public static int <strong>max</strong>(int number1, int number2) {
   if (number1 &gt; number2) {
      return number1;
   } else {
      return number2;
   }
}</pre>

<p>Take note that you need to specify the <em>type</em> of the arguments and the return value in method definition.</p>

<h5>Calling Methods</h5>
<p>To call a method, simply use <code><em>methodName</em>(<em>arguments</em>)</code>. For examples, to call the above methods:</p>
<pre class="example">
<span class="comment">// Calling getArea()</span>
double area1 = getArea(1.1);  <span class="comment">// with literal as argument</span>
double r2 = 2.2;
double area2 = getArea(r2);   <span class="comment">// with variable as argument</span>
double r3 = 3.3;
System.out.println(&quot;Area is: &quot; + area(r3));
<span class="comment">
// Calling max()</span>
int result1 = max(5, 8);
int i1 = 7, i2 = 9;
int result2 = max(i1, i2);
System.out.println(&quot;Max is: &quot; + max(15, 16));</pre>

<p>Take note that you need to specify the <em>type</em> in the method definition, but not during invocation.</p>

<h5>Method Naming Convention</h5>

<p>A method's name shall be a verb or verb phrase (action), comprising one or more words. The first word is in lowercase, while the rest are initial-capitalized (called <em>camel-case</em>).  For example, <code>getArea()</code>, <code>setRadius()</code>, <code>moveDown()</code>, <code>isPrime()</code>, etc.</p>

<p><span class="lead">Another Example:</span></p>

<pre class="example">
<span class="comment">/** Example of Java Method definition and invocation */</span>
public class EgMinMaxMethod {
   <span class="comment">// The entry main() method</span>
   public static void main(String[] args) {
      int a = 6, b = 9, max, min;
      max = max(a, b);  <span class="comment">// invoke method max() with arguments</span>
      min = min(a, b);  <span class="comment">// invoke method min() with arguments</span>
      System.out.println(max + "," + min);
   
      System.out.println(max(5, 8)); <span class="comment">// invoke method max()</span>
      System.out.println(min(5, 8)); <span class="comment">// invoke method min()</span>
   }

   <span class="comment">// The max() method returns the maximum of two given int</span>
   public static int max(int number1, int number2) {
      if (number1 &gt; number2) {
         return number1;
      } else {
         return number2;
      }
   }

   <span class="comment">// The min() method returns the minimum of two given int</span>
   public static int min(int number1, int number2) {
      return (number1 &lt; number2) ? number1 : number2;
   }
}</pre>


<h4>The &quot;<code>return</code>&quot; statement</h4>

<p>Inside the method body, you could use a <code>return</code> statement to return a value (of the <code><em>returnValueType</em></code> declared in the method's signature) to return a value back to the caller. The syntax is:</p>
<pre class="syntax">
return <em>aReturnValue</em>;   <span class="comment">// of <em>returnValueType</em> declared in method's signature</span>
return;                <span class="comment">// return nothing (or void)</span></pre>

<h4>The &quot;<code>void</code>&quot; Return-Type</h4>

<p>Suppose that you need a method to perform certain actions (e.g., printing) without a need to return a value to the caller, you can declare its return-value type as <code>void</code>. In the method's body, you could use a &quot;<code>return;</code>&quot; statement without a return value to return control to the caller. In this case, the <code>return</code> statement is optional. If there is no <code>return</code> statement, the entire body will be executed, and control returns to the caller at the end of the body.</p>

<p>Notice that <code>main()</code> is a method with a return-value type of <code>void</code>. <code>main()</code> is called by the Java runtime, perform the actions defined in the body, and return nothing back to the Java runtime.</p>

<h4>Actual Parameters vs. Formal Parameters</h4>

<p>Recall that a method receives arguments from its caller, performs the actions defined in the method's body, and return a value (or nothing) to the caller.</p>

<p>In the above example, the variable <code>(double radius)</code> declared in the signature of <code>getArea(double radius)</code> is known as <em>formal parameter</em>. Its scope is within the method's body. When the method is invoked by a caller, the caller must supply so-called <em>actual parameter</em>s or <em>arguments</em>, whose value is then used for the actual computation. For example, when the method is invoked via &quot;<code>area1=getArea(radius1)</code>&quot;, <code>radius1</code> is the actual parameter, with a value of <code>1.1</code>.</p>

<h4>Code Example: Magic Number</h4>
<p>The following program contains a <code>boolean</code> method called <code>isMagic(int <em>number</em>)</code>, which returns <code>true</code> if the given <code><em>number</em></code> contains the digit <code>8</code>, e.g., 18, 108, and 1288. The signature of the method is:</p>
<pre class="syntax">public static boolean isMagic(int number);</pre>

<p>It also provides the <code>main()</code> method to test the <code>isMagic()</code>. For example,</p>

<pre class="output">
Enter a positive integer: <strong>1288</strong>
1288 is a magic number

Enter a positive integer: <strong>1234567</strong>
1234567 is not a magic number</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * This program contains a boolean method called isMagic(int number), which tests if the
 * given number contains the digit 8.
 */
public class MagicNumber {
   public static void main(String[] args) {
      // Declare variables
      int number;
      Scanner in = new Scanner(System.in);

      // Prompt and read input as "int"
      System.out.print("Enter a positive integer: ");
      number = in.nextInt();

      // Call isMagic() to test the input
      if (isMagic(number)) {
         System.out.println(number + " is a magic number");
      } else {
         System.out.println(number + " is not a magic number");
      }
      in.close();
   }

   /**
    * Check if the given int contains the digit 8, e.g., 18, 82, 1688.
    * @param  number The given integer
    * @return        true if number contains the digit 8
    * @Precondition  number &gt; 0 (i.e., a positive integer)
    */
   public static boolean isMagic(int number) {
      boolean isMagic = false;   // shall change to true if found a digit 8

      // Extract and check each digit
      while (number &gt; 0) {
         int digit = number % 10;   // Extract the last digit
         if (digit == 8) {
            isMagic = true;
            break;  // only need to find one digit 8
         }
         number /= 10;   // Drop the last digit and repeat
      }
      return isMagic;
   }
}</code></pre>

<p>Take note of the proper <em>documentation comment</em> for the method.</p>

<h4>Code Example: <code>int</code> Array Methods</h4>
<p>The following program contains<code></code> various method for <code>int</code> array with signatures as follows:</p>

<pre class="syntax">
public static void print(int[] array);      <span class="comment">// Print [a1, a2, ...., an]</span>
public static int min(int[] array);         <span class="comment">// Return the min of the array</span>
public static int sum(int[] array);         <span class="comment">// Return the sum of the array</span>
public static double average(int[] array);  <span class="comment">// Return the average of the array</span></pre>

<p>It also contains the main() method to test all the methods. For example,</p>
<pre class="output">
Enter the number of items: <strong>5</strong>
Enter the value of all items (separated by space): <strong>8 1 3 9 4</strong>
The values are: [8, 1, 3, 9, 4]
The min is: 1
The sum is: 25
The average (rounded to 2 decimal places) is: 5.00</pre>
	
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Test various int[] methods.
 */
public class IntArrayMethodsTest {
   public static void main(String[] args) {
      // Declare variables
      final int NUM_ITEMS;
      int[] items;  // Declare array name, to be allocated after numItems is known

      // Prompt for a non-negative integer for the number of items;
      // and read the input as "int". No input validation.
      Scanner in = new Scanner(System.in);
      System.out.print("Enter the number of items: ");
      NUM_ITEMS = in.nextInt();

      // Allocate the array
      items = new int[NUM_ITEMS];

      // Prompt and read the items into the "int" array, if array length &gt; 0
      if (items.length &gt; 0) {
         System.out.print("Enter the value of all items (separated by space): ");
         for (int i = 0; i &lt; items.length; ++i) {
            items[i] = in.nextInt();
         }
      }
      in.close();

      // Test the methods
      System.out.print("The values are: ");
      print(items);
      System.out.println("The min is: " + min(items));
      System.out.println("The sum is: " + sum(items));
      System.out.printf("The average (rounded to 2 decimal places) is: %.2f%n", average(items));
   }

   /**
    * Prints the given int array in the form of [x1, x2, ..., xn]
    * @param  array   The given int array
    * @Postcondition  Print output as side effect
    */
   public static void print(int[] array) {
      System.out.print("[");
      for (int i = 0; i &lt; array.length; ++i) {
         System.out.print((i == 0) ? array[i] : ", " + array[i]);
      }
      System.out.println("]");
   }

   /**
    * Get the min of the given int array
    * @param  array  The given int array
    * @return        The min value of the given array
    */
   public static int min(int[] array) {
      int min = array[0];
      for (int i = 1; i &lt; array.length; ++i) {
         if (array[i] &lt; min) min = array[i];
      }
      return min;
   }

   /**
    * Get the sum of the given int array
    * @param  array  The given int array
    * @return        The sum of the given array
    */
   public static int sum(int[] array) {
      int sum = 0;
      for (int item: array) sum += item;
      return sum;
   }

   /**
    * Get the average of the given int array
    * @param  array  The given int array
    * @return        The average of the given array
    */
   public static double average(int[] array) {
      return (double)(sum(array)) / array.length;
   }
}</code></pre>

<h4>Pass-by-Value for Primitive-Type Parameters</h4>

<p>In Java, when an argument of primitive type is pass into a method, a <em>copy</em> is created and passed into the method. The invoked method works on the <em>cloned copy</em>, and cannot modify the original copy. This is known as <em>pass-by-value</em>.</p>

<p>For example,</p>

<pre><code class="language-java line-numbers">public class PassByValueTest {
   public static void main(String[] args) {
      int number = 8, result;
      System.out.println("In caller, before calling the method, number is: " + number);  // 8
      result = increment(number); // invoke method with primitive-type parameter
      System.out.println("In caller, after calling the method, number is: " + number);   // 8
      System.out.println("The result is " + result);  // 9
   }
 
   // Return number + 1
   public static int increment(int number) {
      System.out.println("Inside method, before operation, number is " + number); // 8
      ++number;  // change the parameter
      System.out.println("Inside method, after operation, number is " + number);  // 9
      return number;
   }
}</code></pre>

<p>Notes:</p>
<ol>
<li>Although there is a variable called <code>number</code> in both the <code>main()</code> and <code>increment()</code> method, there are two distinct copies - one available in <code>main()</code> and another available in <code>increment()</code> - happen to have the same name. You can change the name of either one, without affecting the program.</li>
</ol>

<h4>Pass-by-Reference for Arrays and Objects</h4>

<p>As mentioned, for primitive-type parameters, a cloned copy is made and passed into the method. Hence, the method <em>cannot modify</em> the values in the caller. It is known as pass-by-value.</p>
<p>For arrays (and objects - to be described in the later chapter), the array reference is passed into the method and the method <em>can modify</em> the contents of array's elements. It is known as pass-by-reference. For example,</p>

<pre class="example">
import java.util.Arrays;  <span class="comment">// for Arrays.toString()</span>
public class <strong>PassByReferenceTest</strong> {
   public static void main(String[] args) {
      int[] testArray = {9, 5, 6, 1, 4};
      System.out.println(&quot;In caller, before calling the method, array is: &quot;
            + Arrays.toString(testArray));   <span class="comment">// [9, 5, 6, 1, 4]</span>
      <span class="comment">// Invoke method with an array parameter</span>
      <span class="new">increment(testArray)</span>;
      System.out.println(&quot;In caller, after calling the method, array is: &quot;
            + Arrays.toString(testArray));   <span class="comment">// [10, 6, 7, 2, 5]</span>
   }

   <span class="comment">// Increment each of the element of the given int array</span>
   public static <span class="new">void increment(int[] array)</span> {
      System.out.println(&quot;Inside method, before operation, array is &quot;
           + Arrays.toString(array));   <span class="comment">// [9, 5, 6, 1, 4]</span>
      <span class="comment">// Increment each elements</span>
      for (int i = 0; i &lt; array.length; ++i) ++array[i];
      System.out.println(&quot;Inside method, after operation, array is &quot;
           + Arrays.toString(array));   <span class="comment">// [10, 6, 7, 2, 5]</span>
   }
}</pre>

<h4>Varargs - Method with Variable Number of Formal Arguments (JDK 5)</h4>

<p>Before JDK 5, a method has to be declared with a <em>fixed number of formal arguments</em>.  C-like <code>printf()</code>, which take a <em>variable number of argument</em>, cannot not be implemented.  Although you can use an array for passing a variable number of arguments, it is not neat and requires some programming efforts.</p>

<p>JDK 5 introduces variable arguments (or varargs) and a new syntax &quot;<code><em>Type</em>...</code>&quot;. For example,</p>

<pre class="example">
public PrintWriter printf(String format, Object... args)
public PrintWriter printf(Local l, String format, Object... args)</pre>

<p>Varargs can be used only for the last argument.  The three dots (<code>...</code>) indicate that the last argument may be passed as an array or as a sequence of comma-separated arguments.  The compiler automatically packs the varargs into an array.  You could then retrieve and process each of these arguments inside the method's body as an array. It is possible to pass varargs as an array, because Java maintains the length of the array in an associated variable <code>length</code>.</p><br>

<pre><code class="language-java line-numbers">public class VarargsTest {
   // A method which takes a variable number of arguments (varargs)
   public static void doSomething(String... strs) {
      System.out.print("Arguments are: ");
      for (String str : strs) {
         System.out.print(str + ", ");
      }
      System.out.println();
   }
 
   // A method which takes exactly two arguments
   public static void doSomething(String s1, String s2) {
      System.out.println("Overloaded version with 2 args: " + s1 + ", " + s2);
   }
 
   // Cannot overload with this method - crash with varargs version
   // public static void doSomething(String[] strs)
 
   // Test main() method
   // Can also use String... instead of String[]
   public static void main(String... args) {
      doSomething("Hello", "world", "again", "and", "again");
      doSomething("Hello", "world");
 
      String[] strs = {"apple", "orange"};
      doSomething(strs);  // invoke varargs version
   }
}</code></pre>

<p>Notes:</p>

<ul>
<li>If you define a method that takes a varargs <code>String...</code>, you cannot define an overloaded method that takes a <code>String[]</code>.</li>

<li>&quot;varargs&quot; will be matched <em>last</em> among the overloaded methods.  The <code>varargsMethod(String, String)</code>, which is more specific, is matched before the <code>varargsMethod(String...)</code>.</li>

<li>From JDK 5, you can also declare your <code>main()</code> method as:
<pre class="syntax">
public static void main(String... args) { .... }  <span class="comment">// JDK 5 varargs</span></pre>
</li>
</ul>

<h4>Implicit Type-Casting for Method's Parameters</h4>

<p>A method that takes a <code>double</code> parameter can accept any numeric primitive type, such as <code>int</code> or <code>float</code>. This is because implicit type-casting is carried out. However, a method that take a <code>int</code> parameter cannot accept a <code>double</code> value. This is because the implicit type-casting is always a widening conversion which prevents loss of precision. An explicit type-cast is required for narrowing conversion. Read &quot;<a href="J2_Basics.html#typecasting">Type-Casting</a>&quot; on the conversion rules.</p>


<h4>Method Overloading</h4>
<p>In Java, a method (of a particular method name) can have more than one versions, each version operates on different set of parameters - known as <em>method overloading</em>. The versions shall be differentiated by the numbers, types, or orders of the parameters.</p>

<h5>Example 1</h5>

<pre class="example">
<span class="comment">/** Testing Method Overloading */</span>
public class <strong>AverageMethodOverloading</strong> {
   public static void main(String[] args) {
      System.out.println(average(8, 6));     <span class="comment">// invoke version 1</span>
      System.out.println(average(8, 6, 9));  <span class="comment">// invoke version 2</span>
      System.out.println(average(8.1, 6.1)); <span class="comment">// invoke version 3</span>
      System.out.println(average(8, 6.1));
           <span class="comment">// int 8 autocast to double 8.0, invoke version 3</span>
      //<span class="error">average(1, 2, 3, 4)</span>  <span class="comment">// Compilation Error - no such method</span>
   }

   <span class="comment">// Version 1 takes 2 int's</span>
   public static int average(int n1, int n2) {
      System.out.println("version 1");
      return (n1 + n2)/2;  <span class="comment">// int</span>
   }

   <span class="comment">// Version 2 takes 3 int's</span>
   public static int average(int n1, int n2, int n3) {
      System.out.println("version 2");
      return (n1 + n2 + n3)/3;   <span class="comment">// int</span>
   }

   <span class="comment">// Version 3 takes 2 doubles</span>
   public static double average(double n1, double n2) {
      System.out.println("version 3");
      return (n1 + n2)/2.0;  <span class="comment">// double</span>
   }
}</pre>

<p>The expected outputs are:</p>
<pre class="output">
version 1
7
version 2
7
version 3
7.1
version 3
7.05</pre>

<h5>Example 2: Arrays</h5>
<p>Suppose you need a method to compute the sum of the elements for <code>int[]</code>, <code>short[]</code>, <code>float[]</code> and <code>double[]</code>, you need to write all overloaded versions - there is no shortcut.</p>

<pre class="example">
<span class="comment">/** Testing Array Method Overloading */</span>
public class <strong>SumArrayMethodOverloading</strong> {
   public static void main(String[] args) {
      int[] a1 = {9, 1, 2, 6, 5};
      System.out.println(sum(a1));     <span class="comment">// invoke version 1</span>
      double[] a2 = {1.1, 2.2, 3.3};
      System.out.println(sum(a2));     <span class="comment">// invoke version 2</span>
      float[] a3 = {1.1f, 2.2f, 3.3f};
      //<span class="error">System.out.println(sum(a3));</span>   <span class="comment">// error - float[] is not casted to double[]</span>
   }

   <span class="comment">// Version 1 takes an int[]</span>
   public static int sum(int[] array) {
      System.out.println(&quot;version 1&quot;);
      int sum = 0;
      for (int item : array) sum += item;
      return sum;  <span class="comment">// int</span>
   }

   <span class="comment">// Version 2 takes a double[]</span>
   public static double sum(double[] array) {
      System.out.println(&quot;version 2&quot;);
      double sum = 0.0;
      for (double item : array) sum += item;
      return sum;  <span class="comment">// double</span>
   }
}</pre>

<p>Notes:</p>
<ol>
<li>Unlike primitives, where <code>int</code> would be autocasted to <code>double</code> during method invocation, <code>int[]</code> is not casted to <code>double[]</code>.</li>
<li>To handle all the 7 primitive number type arrays, you need to write 7 overloaded versions to handle each array types!</li>
</ol>

<h4>&quot;<code>boolean</code>&quot; Methods</h4>

<p>A <code>boolean</code> method returns a <code>boolean</code> value to the caller.</p>

<p>Suppose that we wish to write a method called <code>isOdd()</code> to check if a given number is odd.</p>
	
<pre><code class="language-java line-numbers">/**
 *  Testing boolean method (method that returns a boolean value)
 */
public class BooleanMethodTest {
   // This method returns a boolean value
   public static boolean isOdd(int number) {
      if (number % 2 == 1) {
         return true;
      } else {
         return false;
      }
   }
 
   public static void main(String[] args) {
      System.out.println(isOdd(5));  // true
      System.out.println(isOdd(6));  // false
      System.out.println(isOdd(-5)); // false
   }
}</code></pre>

<p>This seemingly correct code produces <code>false</code> for <code>-5</code>, because <code>-5%2</code> is <code>-1</code> instead of <code>1</code>.  You may rewrite the condition:</p>

<pre class="example">
public static boolean isOdd(int number) {
   if (number % 2 == 0) {
      return false;
   } else {
      return true;
   }
}</pre>

<p>The above produces the correct answer, but is poor.  For boolean method, you can simply return the resultant <code>boolean</code> value of the comparison, instead of using a conditional statement, as follow:</p>

<pre class="example">
public static boolean isEven(int number) {
   return (number % 2 == 0);
}
public static boolean isOdd(int number) {
   return !(number % 2 == 0);
}</pre>

<h4>Mathematical Methods</h4>

<p>JDK provides many common-used Mathematical methods in a class called <code>Math</code>. The signatures of some of these methods are:</p>

<pre class="syntax">
double Math.pow(double x, double y) <span class="comment">// returns x raises to power of y</span>
double Math.sqrt(double x)          <span class="comment">// returns the square root of x</span>
double Math.random()                <span class="comment">// returns a random number in [0.0, 1.0)</span>
double Math.sin()
double Math.cos()</pre>

<p>The <code>Math</code> class also provide two constants:</p>

<pre class="syntax">
Math.PI   <span class="comment">// 3.141592653589793</span>
Math.E    <span class="comment">// 2.718281828459045</span></pre>

<p>To check all the available methods, open JDK API documentation &rArr; select <em>module</em> &quot;<code>java.base</code>&quot; &rArr; select <em>package</em> &quot;<code>java.lang</code>&quot; &rArr; select <em>class</em> &quot;<code>Math</code>&quot; &rArr; choose <em>method</em> (@ <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Math.html">https://docs.oracle.com/javase/10/docs/api/java/lang/Math.html</a> for JDK 10).</p>

<p>For examples,</p>

<pre class="example">
int secretNumber = (int)Math.random()*100;  <span class="comment">// Generate a random int between 0 and 99</span>
&nbsp;
double radius = 5.5;
double area = radius*radius*Math.PI;
area = Math.pow(radius, 2)*Math.PI;         <span class="comment">// Not as efficient as above</span>
&nbsp;
int x1 = 1, y1 = 1, x2 = 2, y2 = 2;
double distance = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
int dx = x2 - x1;
int dy = y2 - y1;
distance = Math.sqrt(dx*dx + dy*dy);        <span class="comment">// Slightly more efficient</span></pre>

<h4>Exercises on Methods</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseMethod">LINK</a></p>


<h3>Command-Line Arguments</h3>

<p>Java's <code>main(String[] args)</code> method takes an argument: <code>String[] args</code>, i.e., a <code>String</code> array named <code>args</code>. This is known as &quot;command-line arguments&quot;, which corresponds to the augments provided by the user when the java program is invoked. For example, a Java program called <code>Arithmetic</code> could be invoked with additional command-line arguments as follows (in a &quot;cmd&quot; shell):</p>

<pre class="command">
java Arithmetic <strong>12 3456 +</strong></pre>

<p>Each argument, i.e., <code>&quot;12&quot;</code>, <code>&quot;3456&quot;</code> and <code>&quot;+&quot;</code>, is a <code>String</code>. Java runtime packs all the arguments into a <code>String</code> array and passes into the <code>main()</code> method as <code>args</code>. For this example, <code>args</code> has the following properties:</p>

<pre class="example">
args = {&quot;12&quot;, &quot;3456&quot;, &quot;+&quot;}   <span class="comment">// &quot;args&quot; is a String array</span>
args.length = 3              <span class="comment">// length of the array args</span>
args[0] = &quot;12&quot;   <span class="comment">            // Each element of the array is a String</span>
args[1] = &quot;3456&quot;
args[2] = &quot;+&quot;
args[0].length() = 2   <span class="comment">      // length of the String</span>
args[1].length() = 4
args[2].length() = 1</pre>

<h4>Code Example: <code>Arithmetic</code></h4>

<p>The program <code>Arithmetic</code> reads three parameters form the command-line, two integers and an arithmetic operator (<code>'+'</code>, <code>'-'</code>, <code>'*'</code>, or <code>'/'</code>), and performs the arithmetic operation accordingly. For example,</p>

<pre class="output">
<strong>java Arithmetic 3 2 +</strong>
3+2=5
<strong>java Arithmetic 3 2 -</strong>
3-2=1
<strong>java Arithmetic 3 2 /</strong>
3/2=1</pre>
	
<pre><code class="language-java line-numbers">public class Arithmetic {
   public static void main (String[] args) {
      int operand1, operand2;
      char theOperator;
      operand1 = Integer.parseInt(args[0]);  // Convert String to int
      operand2 = Integer.parseInt(args[1]);
      theOperator = args[2].charAt(0);       // Consider only 1st character
      System.out.print(args[0] + args[2] + args[1] + "=");
      switch(theOperator) {
         case ('+'):
            System.out.println(operand1 + operand2); break;
         case ('-'):
            System.out.println(operand1 - operand2); break;
         case ('*'):
            System.out.println(operand1 * operand2); break;
         case ('/'):
            System.out.println(operand1 / operand2); break;
         default:
            System.out.printf("%nError: Invalid operator!");
      }
   }
}</code></pre>

<h4>Exercises on Command-Line Arguments</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseCmdArgs">LINK</a></p>

<h3>(Advanced) Bitwise Operations</h3>

<h4>Bitwise Logical Operations</h4>

<p>Bitwise  operators perform operations on one or two operands on a bit-by-bit basis, as follows, in descending order of precedences.</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Mode</th>
  <th>Usage</th>
  <th>Description</th>
  <th>Example</th>
</tr>
<tr>
  <td class="lead-code text-center">~</td>
  <td>Unary</td>
  <td><code>~x</code></td>
  <td>Bitwise NOT (inversion)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="lead-code text-center">&amp;</td>
  <td>Binary</td>
  <td><code>x &amp; y</code></td>
  <td>Bitwise AND</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="lead-code text-center">|</td>
  <td>Binary</td>
  <td><code>x | y</code></td>
  <td>Bitwise OR</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="lead-code text-center">^</td>
  <td>Binary</td>
  <td><code>x ^ y</code></td>
  <td>Bitwise XOR</td>
  <td>&nbsp;</td>
</tr>
</table>

<h5>Example</h5>
	
<pre><code class="language-java line-numbers">public class TestBitwiseOp {
   public static void main(String[] args) {
      int x = 0xAAAA_5555;                // a negative number (sign bit (msb) = 1)
      int y = 0x5555_1111;                // a positive number (sign bit (msb) = 0)
      System.out.printf("%d%n", x);       // -1431677611
      System.out.printf("%d%n", y);       // 1431638289
      System.out.printf("%08X%n", ~x);    // 5555AAAAH
      System.out.printf("%08X%n", x &amp; y); // 00001111H
      System.out.printf("%08X%n", x | y); // FFFF5555H
      System.out.printf("%08X%n", x ^ y); // FFFF4444H
   }
}</code></pre>

<p>Compound operator <code>&amp;=</code>, <code>|=</code> and <code>^=</code> are also available, e.g., <code>x &amp;= y</code> is the same as <code>x = x &amp; y</code>. </p>

<p>Take note that:</p>

<ol>
<li><code>'&amp;'</code>, <code>'|'</code> and <code>'^'</code> are applicable when both operands are integers (<code>int</code>, <code>byte</code>, <code>short</code>, <code>long</code> and <code>char</code>) or <code>boolean</code>s. When both operands are integers, they perform bitwise operations. When both operands are <code>boolean</code>s, they perform logical AND, OR, XOR operations (i.e., same as logical <code>&amp;&amp;</code>, <code>||</code> and <code>^</code>). They are not applicable to <code>float</code> and <code>double</code>. On the other hand, logical AND (<code>&amp;&amp;</code>) and OR (<code>||</code>) are applicable to <code>boolean</code>s only.

<pre class="example">
System.out.println(true &amp; true);   <span class="comment">// logical -&gt; true</span>
System.out.println(0x1 &amp; 0xffff);  <span class="comment">// bitwise -&gt; 1</span>
System.out.println(true &amp;&amp; true);  <span class="comment">// logical -&gt; true</span></pre>
</li>

<li>The bitwise NOT (or bit inversion) operator is represented as '~', which is different from logical NOT (<code>!</code>).</li>

<li>The bitwise XOR is represented as <code>'^'</code>, which is the same as logical XOR (<code>^</code>).</li>

<li>The operators' precedence is in this order: <code>'~'</code>, <code>'&amp;'</code>, <code>'^'</code>, <code>'|'</code>, <code>'&amp;&amp;'</code>, <code>'||'</code>. For example,
<pre class="example">
System.out.println(true | true &amp; false);  <span class="comment">// true | (true &amp; false) -&gt; true</span>
System.out.println(true ^ true &amp; false);  <span class="comment">// true ^ (true &amp; false) -&gt; true</span></pre>
</li>
</ol>

<p>Bitwise operations are powerful and yet extremely efficient. [Example on advanced usage.]</p>

<h4>Bit-Shift Operations</h4>

<p>Bit-shift operators perform left or right shift on an operand by a specified number of bits.  Right-shift can be either signed-extended (<code>&gt;&gt;</code>) (padded with signed bit) or unsigned-extended (<code>&gt;&gt;&gt;</code>) (padded with zeros). Left-shift is always padded with zeros (for both signed and unsigned).</p>

<table class="table-zebra">
<tr>
  <th> Operator</th>
  <th>Mode</th>
  <th>Usage</th>
  <th>Description</th>
  <th>Example</th>
</tr>
<tr>
  <td class="lead-code text-center">&lt;&lt;</td>
  <td>Binary</td>
  <td><code>x &lt;&lt; count</code></td>
  <td>Left-shift and padded with zeros</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="lead-code text-center">&gt;&gt;</td>
  <td>Binary</td>
  <td><code>x &gt;&gt; count</code></td>
  <td>Right-shift and padded with sign bit (signed-extended right-shift)</td>
  <td>&nbsp;</td>
</tr>
<tr>
  <td class="lead-code text-center">&gt;&gt;&gt;</td>
  <td>Binary</td>
  <td><code>x &gt;&gt;&gt; count</code></td>
  <td>Right-shift and padded with zeros (unsigned-extended right-shift)</td>
  <td>&nbsp;</td>
</tr>
</table>

<p>Since all the Java's integers (byte, short, int and long) are signed integers, left-shift &lt;&lt; and right-shift &gt;&gt; operators perform signed-extended bit shift.  Signed-extended right shift &gt;&gt; pads the most significant bits with the sign bit to maintain its sign (i.e., padded with zeros for positive numbers and ones for negative numbers).  Operator &gt;&gt;&gt; (introduced in Java, not in C/C++) is needed to perform unsigned-extended right shift, which always pads the most significant bits with zeros.  There is no difference between the signed-extended and unsigned-extended left shift, as both operations pad the least significant bits with zeros.</p>

<h5>Example</h5>
	
<pre><code class="language-java line-numbers">public class BitShiftTest {
   public static void main(String[] args) {
      int x = 0xAAAA5555;               // a negative number (sign bit (msb) = 1)
      int y = 0x55551111;               // a positive number (sign bit (msb) = 0)
      System.out.printf("%d%n", x);     // -1431677611
      System.out.printf("%d%n", y);     // 1431638289
      System.out.printf("%08X%n", x&lt;&lt;1);  // 5554AAAAH
      System.out.printf("%08X%n", x&gt;&gt;1);  // D5552AAAH
      System.out.printf("%d%n", x&gt;&gt;1);    // negative
      System.out.printf("%08X%n", y&gt;&gt;1);  // 2AAA8888H
      System.out.printf("%08d%n", y&gt;&gt;1);  // positive
      System.out.printf("%08X%n", x&gt;&gt;&gt;1); // 55552AAAH
      System.out.printf("%d%n", x&gt;&gt;&gt;1);   // positive
      System.out.printf("%08X%n", y&gt;&gt;&gt;1); // 2AAA8888
      System.out.printf("%d%n", y&gt;&gt;&gt;1);   // positive
 
      // More efficient to use signed-right-right to perform division by 2, 4, 8,...
      int i1 = 12345;
      System.out.println("i1 divides by 2 is " + (i1 &gt;&gt; 1));
      System.out.println("i1 divides by 4 is " + (i1 &gt;&gt; 2));
      System.out.println("i1 divides by 8 is " + (i1 &gt;&gt; 3));
      int i2 = -12345;
      System.out.println("i2 divides by 2 is " + (i2 &gt;&gt; 1));
      System.out.println("i2 divides by 4 is " + (i2 &gt;&gt; 2));
      System.out.println("i2 divides by 8 is " + (i2 &gt;&gt; 3));
   }
}</code></pre>

<p>As seen from the example, it is more efficient to use sign-right-shift to perform division by 2, 4, 8... (power of 2), as integers are stored in binary.</p>

<p>[More example on advanced usage.]</p>

<h4>Types and Bitwise Operations</h4>

<p>The bitwise operators are applicable to integral primitive types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> and <code>char</code>.  <code>char</code> is treated as unsigned 16-bit integer. There are not applicable to <code>float</code> and  <code>double</code>. The <code>'&amp;'</code>, <code>'|'</code>, <code>'^'</code>, when apply to two <code>boolean</code>s, perform logical operations. Bit-shift operators are not applicable to <code>boolean</code>s.</p>

<p>Like binary arithmetic operations:</p>

<ul>
<li><code>byte</code>, <code>short</code> and <code>char</code> operands are first promoted to <code>int</code>.</li>

<li>If both the operands are of the same type (<code>int</code> or <code>long</code>), they are evaluated in that type and returns a result of that type.</li>

<li>If the operands are of different types, the smaller operand (<code>int</code>) is promoted to the larger one (<code>long</code>). It then operates on the larger type (<code>long</code>) and returns a result in the larger type (<code>long</code>).</li>
</ul>

<h3>Algorithms</h3>

<p>Before writing a program to solve a problem, you have to first develop the steps involved, called <em>algorithm</em>, and then translate the <em>algorithm</em> into programming statements. This is the hardest part in programming, which is also hard to teach because the it involves intuition, knowledge and experience. </p>

<p>An <em>algorithm</em> is a step-by-step instruction to accomplice a  task, which may involve decision and iteration. It is often expressed in English-like <em>pseudocode</em>, before translating into programming statement of a particular programming language. There is no standard on how to write pseudocode - simply write something that you, as well as other people, can understand the steps involved, and able to translate into a working program.</p>

<h4>Algorithm for Prime Testing</h4>

<p>Ancient Greek mathematicians like Euclid and Eratosthenes (around 300-200 BC) had developed many <em>algorithms</em> (or step-by-step instructions) to work on prime numbers. By definition, a <em>prime  </em>is a positive integer that is divisible by one and itself only.</p>

<p>To test whether a number <em><code>x</code></em> is a prime number, we could apply the definition by dividing <em><code>x</code></em> by 2, 3, 4, ..., up to <code><em>x</em>-1</code>.  If no divisor is found, then <em><code>x</code></em> is a prime number. Since divisors come in pair, there is no need to try all the factors until <em>x</em>-1, but up to <code>&radic;<em>x</em></code>.</p>

<pre class="syntax">
<span class="comment">// To test whether an int x is a prime</span>
int maxFactor = (int)Math.sqrt(x);   <span class="comment">// find the nearest integral square root of x</span>
assume x is a prime;
for (int factor = 2; factor &lt;= maxFactor; ++factor) {
   if (x is divisible by factor) {
      x is not a prime;
      break;  <span class="comment">  // a factor found, no need to find more factors</span>
   }
}</pre>

<p><span class="lead">TRY</span>: translate the above pseudocode into a Java program called <code>PrimeTest</code>.</p>

<h4>Algorithm for Perfect Numbers</h4>

<p>A positive integer is called a <em>perfect number</em> if the sum of all its proper divisor is equal to its value.  For example, the number <code>6</code> is perfect because its proper divisors are <code>1</code>, <code>2</code>, and <code>3</code>, and <code>6=1+2+3</code>; but the number <code>10</code> is not perfect because its proper divisors are <code>1</code>, <code>2</code>, and <code>5</code>, and <code>10&ne;1+2+5</code>. Other perfect numbers are <code>28</code>, <code>496</code>, ...</p>

<p>The following algorithm can be used to test for perfect number:</p>

<pre class="syntax">
<span class="comment">// To test whether int x is a perfect number</span>
int sum = 0;
for (int i = 1; i &lt; x; ++i) {
   if (x is divisible by i) {
      i is a proper divisor;
      add i into the sum;
   }
}
if (sum == x)
   x is a perfect number
else
   x is not a perfect number</pre>

<p><span class="lead">TRY</span>: translate the above pseudocode into a Java program called <code>PerfectNumberTest</code>.</p>

<h4>Algorithm on Computing Greatest Common Divisor (GCD)</h4>

<p>Another early algorithm developed by ancient Greek mathematician Euclid (300 BC) is to find the Greatest Common Divisor (GCD) (or Highest Common Factor (HCF)) of two integers. By definition, <code>GCD(a,b)</code> is the largest factor that divides both <code>a</code> and <code>b</code>.</p>

<p>Assume that <code>a</code> and <code>b</code> are positive integers and <code>a &gt;= b</code>, the Euclidean algorithm is based on these two properties:</p>

<pre class="syntax">
1.  GCD(a, 0) = a
2.  GCD(a, b) = GCD(b, a mod b), where &quot;a mod b&quot; denotes the remainder of a divides by b.
</pre>

<p>For example,</p>

<pre class="example">
GCD(15, 5) = GCD(5, 0) = 5
GCD(99,88) = GCD(88,11) = GCD(11,0) = 11
GCD(3456,1233) = GCD(1233,990) = GCD(990,243) = GCD(243,18) = GCD(18,9) = GCD(9,0) = 9</pre>

<p>The Euclidean algorithm is as follows:</p> 

<pre class="syntax">
GCD(a, b)  <span class="comment">// assume that a &gt;= b</span>
while (b != 0) {
<span class="comment">   // Change the value of a and b: a &larr; b, b &larr; a mod b, and repeat until b is 0</span>
   temp &larr; b
   b &larr; a mod b
   a &larr; temp
}
<span class="comment">// after the loop completes, i.e., b is 0, we have GCD(a, 0)</span>
GCD is a</pre>

<p>Before explaining the algorithm, suppose we want to exchange (or swap) the values of two variables <em><code>x</code></em> and <em><code>y</code></em>.  Explain why the following code does not work.</p>
<pre class="example">
int x = 55, y=66;
<span class="comment">// swap the values of x and y</span>
x = y;
y = x;</pre>

<p>To swap the values of two variables, we need to define a temporary  variable as follows:</p>
<pre class="example">
int x = 55, y=66;
int temp;
<span class="comment">// swap the values of x and y</span>
temp = y;
y = x;
x = temp;</pre>

<p>Let us look into the Euclidean algorithm, <code>GCD(a, b) = a</code>, if <code>b</code> is <code>0</code>. Otherwise, we replace <code>a</code> by <code>b</code>; <code>b</code> by <code>(a mod b)</code>, and compute <code>GCD(b, a mod b)</code>. Repeat the process until the second term is <code>0</code>. Try this out on pencil-and-paper to convince yourself that it works.</p>

<p><span class="lead">TRY</span>: Write a program called <code>GCD</code>, based on the above algorithm.</p>

<h4>Exercises on Algorithm</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseNumberTheory">LINK</a></p>

<h3>Summary</h3>

<p>This chapter covers the Java programming basics:</p>

<ul>
<li>Comments, Statements and Blocks.</li>
<li>Variables, Literals, Expressions.</li>

<li>The concept of type and Java's eight primitive types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, and <code>boolean</code>; and <code>String</code>.</li>

<li>Implicit and explicit type-casting.</li>

<li>Operators: assignment (<code>=</code>), arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>), increment/decrement (<code>++</code>, <code>--</code>) relational operators (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>), logical operators (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>^</code>) and conditional (<code>? :</code>).</li>

<li>Three flow control constructs: sequential, condition (<code>if</code>, <code>if-else</code>, <code>switch-case</code> and nested-if) and loops (<code>while</code>, <code>do-while</code>, <code>for</code> and nested loops).</li>

<li>Input (via <code>Scanner</code>) &amp; Output (<code>print()</code>, <code>println()</code> and <code>printf()</code>) operations.</li>

<li>Arrays and the enhanced for-loop.</li>

<li>Methods and passing parameters into methods.</li>

<li>The advanced bitwise logical operators (<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>^</code>) and bit-shift operators (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>).</li>

<li>Developing algorithm for solving problems.</li>
</ul>

<a class="references" href="../howto/References.html#java">Link to Java References and Resources</a>

<p class="references">More References and Resources</p>

<ol>
<li> (MUST READ) &quot;Code Conventions for the Java Programming Language&quot; @ <a href="https://www.oracle.com/technetwork/java/codeconvtoc-136057.html">https://www.oracle.com/technetwork/java/codeconvtoc-136057.html</a>, or google the title, Sun Microsystems (now Oracle), 1999.</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 15.0.2<br>
Last modified: February, 2021</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- @@ v3 footer changes starts here, before "footer", to end of document -->
<!-- footer filled by JavaScript -->
<div id="footer" class="footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->

<!-- jQuery -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<!-- My custom JavaScript v3 -->
<script src="../scripts/programming_notes_v3.js"></script>
<!-- Prism Syntax Highlighter -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
