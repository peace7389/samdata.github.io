<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Java Programming Tutorial on Generics</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="JavaGeneric.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Generics</h1>
</div>

<div id="content-main">

<h5>References:</h5>
<ol>
<li>&quot;The Java Tutorial - Generics&quot; (JDK 8) @ <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a>.</li>
<li>&quot;The Java Tutorial - Generics&quot; by Gilad Bracha (JDK 8) @ <a href="https://docs.oracle.com/javase/tutorial/extra/generics/index.html">https://docs.oracle.com/javase/tutorial/extra/generics/index.html</a>.</li>
<li>&quot;Java Generics FAQs&quot; by Angelika Langer @ <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html">http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a>.</li>
<li>&quot;The Java Tutorial - Collections&quot; @ <a href="http://docs.oracle.com/javase/tutorial/collections/index.html">http://docs.oracle.com/javase/tutorial/collections/index.html</a>.</li>

</ol>

<h3 id="intro">Introduction</h3>

<p>JDK 5 introduces <em>generics</em>, which supports <em>abstraction over types</em> (or <em>parameterized types</em>) on classes and methods.  The class or method designers can be <em>generic about types in the definition</em>, while the users are to provide the <em>specific types (actual type) during the  object instantiation or method invocation</em>.</p>

<p>You are certainly familiar with passing arguments into methods. You place the arguments inside the round bracket <code>()</code> and pass them into the method. In generics, instead of passing arguments, we pass <em>type information</em> inside the angle brackets <code>&lt;&gt;</code>.</p>

<p> The primary usage of generics is to <em>abstract over types</em> for the Collection Framework.</p>
<p>Before discussing generics, we need to introduce these related new Java language features introduced in JDK 5:</p>
<ol>
<li>Auto-Boxing and Auto-Unboxing between primitives and their wrapper objects.</li>
<li>Enhanced for-each loop.</li>
</ol>


<h4 id="J5Autobox">Auto-Boxing/Unboxing between Primitives and their Wrapper Objects (JDK 5)</h4>

<p>A Java <code>Collection</code> (such as <code>List</code> and <code>Set</code>) contains only objects. It cannot holds primitives (such as <code>int</code> and <code>double</code>).  On the other hand, arrays can hold primitives and objects, but they are not <em>resizable</em>. To put a primitive into a <code>Collection</code> (such as <code>ArrayList</code>), you have to wrap the primitive into an object using the corresponding <em>primitive wrapper class</em> as shown below:</p>

<img class="image-center" src="images/OOP_WrapperClass.png" alt="primitive wrapper classes" />

<p>Prior to JDK 5, you need to <em>explicitly</em> wrap a primitive value into an object and unwrap the primitive value from the wrapper object, for example,</p>
<pre class="color-example">
<span class="color-comment">// Pre-JDK 5</span>
Integer intObj = <span class="color-new">new Integer(5566);</span>    <span class="color-comment">// wrap an int to Integer by constructing an instance of Integer</span>
int i = intObj<span class="color-new">.intValue()</span>;             <span class="color-comment">// unwrap Integer to int</span>
&nbsp;
Double doubleObj = <span class="color-new">new Double(55.66)</span>;  <span class="color-comment">// wrap double to Double</span>
double d = doubleObj<span class="color-new">.doubleValue()</span>;    <span class="color-comment">// unwrap Double to double</span>
</pre>

<p>The pre-JDK 5 approach involves quite a bit of codes to do the wrapping and unwrapping. JDK 5 introduces a new feature called <em>auto-boxing</em> and <em>auto-unboxing</em> to resolve this problem, by delegating the compiler to do the job. For example,</p>
<pre class="color-example">
<span class="color-comment">// JDK 5</span>
Integer intObj = 5566;    <span class="color-comment">// auto-box from int to Integer by the compiler</span>
int i = intObj;           <span class="color-comment">// auto-unbox from Integer to int by the compiler</span>
&nbsp;
Double doubleObj = 55.66; <span class="color-comment">// auto-box from double to Double</span>
double d = doubleObj;     <span class="color-comment">// auto-unbox from Double to double</span>
</pre>

<h5>Primitive Wrapper Objects, Like <span class="font-code">String</span>s, are Immutable!</h5>
<p>For example,</p>

<pre class="color-example">
public class PrimitiveWrapperImmutableTest {
   public static void main(String[] args) {
      Integer iObj = 123;   <span class="color-comment">// auto-box</span>
      System.out.println(Integer.toHexString(System.identityHashCode(iObj)));  <span class="color-comment">// Print reference</span>
      <span class="color-comment">//<span class="color-output">36baf30c</span></span>

      iObj += 1;  <span class="color-comment">// a new Integer object is created and assigned to i</span>
      System.out.println(iObj);  <span class="color-comment">//<span class="color-output">124</span></span>
      System.out.println(Integer.toHexString(System.identityHashCode(iObj)));
      <span class="color-comment">//<span class="color-output">7a81197d</span>  (different reference!)</span>

      <span class="color-comment">// This is similar to the immutable String</span>
      String str = &quot;hello&quot;;
      System.out.println(Integer.toHexString(System.identityHashCode(str)));
      <span class="color-comment">//<span class="color-output">5ca881b5</span></span>
      str += &quot;world&quot;;
      System.out.println(str);  <span class="color-comment">//<span class="color-output">helloworld</span></span>
      System.out.println(Integer.toHexString(System.identityHashCode(str)));
      <span class="color-comment">//<span class="color-output">7adf9f5f</span></span>
   }
}</pre>


<h4 id="J5ForEachLoop">Enhanced for-each Loop (JDK 5)</h4>

<p>JDK 5 also introduces a new  for-each loop, which you can use to traverse through all the elements of an array or a <code>Collection</code>.</p>
<p>The syntax is as follows. You should read as <em>for each</em> element in the collection/array.</p>

<pre class="color-syntax">
for ( <em>type</em> <em>item</em> : <em>array_collection</em> ) {
   <em>body</em> ;
}</pre>

<p>For example,</p>
<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
public class <strong>J5ForEachLoopTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Use for-each loop on Array</span>
      int[] numArray = {11, 22, 33};
      for (int num : numArray) System.out.println(num);
      <span class="color-comment"></span><span class="color-comment">//<span class="color-output">11</span>
      //<span class="color-output">22</span>
      //<span class="color-output">33</span></span>

      <span class="color-comment">// Same as:</span>
      for (int idx = 0; idx &lt; numArray.length; ++idx) System.out.println(numArray[idx]);

      <span class="color-comment">// Use for-each loop on Collection</span>
      List&lt;String&gt; coffeeLst = new ArrayList&lt;&gt;();
      coffeeLst.add(&quot;espresso&quot;);
      coffeeLst.add(&quot;latte&quot;);
      for (String coffee : coffeeLst) System.out.println(coffee.toUpperCase());
      <span class="color-comment"></span><span class="color-comment">//<span class="color-output">ESPRESSO</span></span>
      <span class="color-comment">//<span class="color-output">LATTE</span></span>
   }
}</pre>

<h5>Can you modify the Array/<span class="font-code">Collection</span> via Enhanced for-each Loop?</h5>

<p>For primitive arrays, the for-each loop's local variable clones a value for each item and, hence, you cannot modify the original array. (A <code>Collection</code> cannot hold primitives.) For example,</p>

<pre class="color-example">
import java.util.Arrays;
public class <strong>ForEachLoopPrimitiveTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Using for-each loop on an array of primitive (e.g., int[])</span>
      int[] iArray = {11, 22, 33};
      for (int item : iArray) {
         System.out.print(item + &quot; &quot;);
         item += 99;  <span class="color-comment">// try changing</span>
      }
      <span class="color-comment">//<span class="color-output">11 22 33</span></span>
      System.out.println(Arrays.toString(iArray));
      <span class="color-comment">//<span class="color-output">[11, 22, 33]</span>  (no change)</span>

      <span class="color-comment">// You need to use the traditional for-loop to modify the array</span>
      for (int i = 0; i &lt; iArray.length; ++i) {
         iArray[i] += 99;
      }
      System.out.println(Arrays.toString(iArray));
      <span class="color-comment">//<span class="color-output">[110, 121, 132]</span>  (changed!)</span>
   }
}</pre>

<p>For object arrays or <code>Collection</code>s, an object reference is passed to the loop's local variable, you can modify the object via this reference. For example,</p>

<pre class="color-example">
import java.util.Arrays;
import java.util.Arrays;

class <strong>MyMutableInteger</strong> {
   private int value;  <span class="color-comment">// private variable, mutable via setter</span>
   public MyMutableInteger(int value) { this.value = value; }  <span class="color-comment">// constructor</span>
   public String toString() { return &quot;MyMutableInteger[value=&quot; + value + &quot;]&quot;; }
   public void setValue(int value) { this.value = value; }  <span class="color-comment">// setter</span>
}

public class <strong>ForEachLoopMutableObjectTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Using for-each loop on an array of primitive (e.g., int[])</span>
      MyMutableInteger[] iArray = {new MyMutableInteger(11), new MyMutableInteger(22)};
      for (MyMutableInteger item : iArray) {
         System.out.println(item);
         item.setValue(99);  <span class="color-comment">// try changing via setter</span>
      }
      <span class="color-comment">//<span class="color-output">MyMutableInteger[value=11]</span></span>
      <span class="color-comment">//<span class="color-output">MyMutableInteger[value=22]</span></span>
      System.out.println(Arrays.toString(iArray));
      <span class="color-comment">//<span class="color-output">[MyMutableInteger[value=99], MyMutableInteger[value=99]]</span>  (changed!)</span>
   }
}</pre>

<p>However, for immutable object arrays and <code>Collection</code>s (such as <code>String</code> and <code>Integer</code>), you cannot modify the contents, as new objects were created and assigned to the reference. For example,</p>

<pre class="color-example">
import java.util.Arrays;
public class <strong>ForEachLoopImmutableObjectTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Using for-each loop on an array of immutable objects (such as String[])</span>
      String[] sArray = {&quot;dog&quot;, &quot;cat&quot;, &quot;turtle&quot;};
      for (String item : sArray) {
         System.out.print(item + &quot; &quot;);
         item += &quot;hello&quot;;  <span class="color-comment">// a new String is created as Strings are immutable</span>
      }
      <span class="color-comment">//<span class="color-output">dog cat turtle</span></span>
      System.out.println(Arrays.toString(sArray));
      <span class="color-comment">//<span class="color-output">[dog, cat, turtle]</span>  (no change)</span>
   }
}</pre>




<h4 id="ReviewInheritance">A Brief Summary of Inheritance, Polymorphism and Type Casting</h4>
<p>The following rules applied to inheritance substitution and polymorphism:</p>
<ol>
<li>A reference <code>c</code> of class <code>C</code> accepts instances of <code>C</code>. It also accepts instances of <code>C</code>'s subtypes (says <code>CSub</code>), which is known as <em>substitution</em>. This is because <code>CSub</code> inherits all attributes and behaviors of <code>C</code>, and hence, can act as <code>C</code>.</li>
<li>Once substituted, you can only invoke methods defined in <code>C</code>, not <code>CSub</code>, since <code>c</code> is a reference of <code>C</code>.</li>
<li>If <code></code><code>CSub</code> overrides a method <code>m</code> of the supertype <code>C</code>, then  <code>c.m()</code> runs the overridden version in the subtype <code>CSub</code>, not the <code>C</code>'s version.</li>
</ol>

<p>The following rules applied to type casting:</p>
<ol>
<li>Casting from subtype up to supertype (<em>up casting</em>) is type-safe, and does not require an explicit type casting operator.</li>
<li>Casting from supertype down to subtype (<em>down casting</em>) is NOT type-safe, and requires an explicit type casting operator.</li>
</ol>

<p>For example,</p>

<pre class="color-example">
class <strong>C1</strong> {
   public void sayHello() { System.out.println(&quot;C1 runs sayHello()&quot;); }
   public void methodC1() { System.out.println(&quot;C1 runs methodC1()&quot;); }
}
class <strong>C2 extends C1</strong> {  <span class="color-comment">// C2 is a subclass of C1</span>
   @Override public void sayHello() { System.out.println(&quot;C2 runs overridden sayHello()&quot;); }
   public void methodC2() { System.out.println(&quot;C2 runs methodC2()&quot;); }
}

public class <strong>PolymorphismTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Substitution: Reference to C1 can accept instance of C1 and its subclasses</span>
      C1 c1Ref = new C2();  <span class="color-comment">// substituted with C1 subclass' instance</span>
      c1Ref.methodC1();     <span class="color-comment">//<span class="color-output">C1 runs methodC1()</span></span>
      <span class="color-comment">//<span class="color-error">c1Ref.methodC2()</span>;   // CANNOT reference subclass method</span>
      <span class="color-comment">//<span class="color-error">error: cannot find symbol</span></span>

      <span class="color-comment">// Polymorphism: run the overridden version</span>
      c1Ref.sayHello();    <span class="color-comment">//</span><span class="color-output">C2 runs overridden sayHello()</span>

      <span class="color-comment">// Upcasting is type-safe, does not require explicit type cast operator</span>
      C1 c1Ref2 = new C2();
      <span class="color-comment">// Downcasting is NOT type-safe, require explicit type cast operator</span>
      C2 c2Ref = (C2)c1Ref2;
      <span class="color-comment">//<span class="color-error">C2 c2Ref = c1Ref2</span>;</span>
      <span class="color-comment">//<span class="color-error">error: incompatible types: C1 cannot be converted to C2</span></span>
   }
}</pre>

<h3 id="GenericByExamples">Introduction to Generics by Examples (JDK 5)</h3>

<p>This section gives some examples on working with generics, meant for experienced programmers to get a quick review. For novices, start with the next section.</p>


<h4>Example 1: Using Generic Collection: <span class="font-code">List&lt;E&gt;</span> and <span class="font-code">ArrayList&lt;E&gt;</span></h4>

<p>The class <code>java.util.ArrayList&lt;E&gt;</code> is designed (by the class designer) to take a generics type <code>&lt;E&gt;</code> as follows:</p>

<pre class="color-syntax">
public class <strong>ArrayList<span class="color-new">&lt;E&gt;</span> implements List<span class="color-new">&lt;E&gt;</span></strong> ... {
   public boolean add(<span class="color-new">E</span> e)
   public void add(int index, <span class="color-new">E</span> element)
   public boolean addAll(Collection<span class="color-new">&lt;? extends E&gt;</span> c)
   public boolean addAll(int index, Collection<span class="color-new">&lt;? extends E&gt;</span> c)
   public <span class="color-new">E</span> get(int index)
   public <span class="color-new">E</span> remove(int index)
   .......
}</pre>

<p>To construct an instance of an <code>ArrayList&lt;E&gt;</code>, we need to provide the actual type for <code>E</code>. The actual type provided will then substitute all references to <code>E</code> inside the class. For example,</p>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;

public class <strong>GenericArrayListTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Set &quot;E&quot; to &quot;String&quot;</span>
      <span class="color-new">ArrayList&lt;String&gt;</span> fruitLst = <span class="color-new">new ArrayList&lt;String&gt;</span>();<span class="color-comment"></span>
      fruitLst.add(&quot;apple&quot;);
      fruitLst.add(&quot;orange&quot;);
      System.out.println(fruitLst);  <span class="color-comment">//<span class="color-output">[apple, orange]</span></span>
      <span class="color-comment">// JDK 5 also introduces the for-each loop</span>
      <span class="color-new">for (String str: fruitLst)</span> {   <span class="color-comment">// we need to know type of elements</span>
         System.out.println(str);
      }
      <span class="color-comment">//<span class="color-output">apple</span></span>
      <span class="color-comment">//<span class="color-output">orange</span></span>

      <span class="color-comment">// Adding non-String type triggers compilation error</span>
      <span class="color-comment">//fruitLst<span class="color-error">.add(99)</span>;
      //<span class="color-error">compilation error: incompatible types: int cannot be converted to String</span></span>

      <span class="color-comment">// JDK 7 introduces diamond operator &lt;&gt; for type inference to shorten the code</span>
      <span class="color-new">ArrayList&lt;String&gt;</span> coffeeLst = new <span class="color-new">ArrayList&lt;&gt;</span>();  <span class="color-comment">// can omit type in instantiation</span>
      coffeeLst.add(&quot;espresso&quot;);
      coffeeLst.add(&quot;latte&quot;);
      System.out.println(coffeeLst);  <span class="color-comment">//<span class="color-output">[espresso, latte]</span></span>

      <span class="color-comment">// We commonly program at the specification in List instead of implementation ArrayList</span>
      <span class="color-new">List&lt;String&gt;</span> animalLst = new <span class="color-new">ArrayList&lt;&gt;</span>();  <span class="color-comment">// Upcast ArrayList&lt;String&gt; to List&lt;String&gt;</span>
      animalLst.add(&quot;tiger&quot;);
      System.out.println(animalLst);  <span class="color-comment">//<span class="color-output">[tiger]</span></span>

      <span class="color-comment">// A Collection holds only objects, not primitives
      // Try auto-box/unbox between primitives and wrapper objects
</span>      <span class="color-new">List&lt;Integer&gt;</span> intLst = new <span class="color-new">ArrayList&lt;&gt;</span>();
      intLst<span class="color-new">.add(11)</span>;  <span class="color-comment">// primitive &quot;int&quot; auto-box to &quot;Integer&quot; (JDK 5)</span>
      <span class="color-new">int</span> i1 = intLst<span class="color-new">.get(0)</span>;  <span class="color-comment">// &quot;Integer&quot; auto-unbox to primitive &quot;int&quot;</span>
      System.out.println(intLst);  <span class="color-comment">//<span class="color-output">[11]</span></span>
      <span class="color-comment">//intLst<span class="color-error">.add(2.2)</span>;
      //<span class="color-error">compilation error: incompatible types: double cannot be converted to Integer</span></span>

      <span class="color-comment">// &quot;Number&quot; is a supertype of &quot;Integer&quot; and &quot;Double&quot;</span>
      <span class="color-new">List&lt;Number&gt;</span> numLst = new <span class="color-new">ArrayList&lt;&gt;</span>();
      numLst.add(33);   <span class="color-comment">// primitive &quot;int&quot; auto-box to &quot;Integer&quot;, upcast to Number</span>
      numLst.add(4.4);  <span class="color-comment">// primitive &quot;double&quot; auto- box to &quot;Double&quot;, upcast to Number</span>
      System.out.println(numLst);  <span class="color-comment">//<span class="color-output">[33, 4.4]</span></span>
   }
}</pre>

<p>The above example showed that the class designers could be <em>generic about type</em>; while the users provide the <em>specific actual type</em>  during instantiation. With generics, we can design one common class that is applicable to all types with compile-time type-safe checking. The actual types  are passed inside the angle bracket <code>&lt;&gt;</code>, just like method arguments are passed inside the round bracket <code>()</code>.</p>

<h4>Example 2: Pre-Generic Collections (Pre-JDK 5) are not Compile-Time Type-Safe</h4>
<p>If you are familiar with the pre-JDK 5's collections such as <code>ArrayList</code>, they are designed to hold <code>java.lang.Object</code>.  Since <code>Object</code> is the common root class of all the Java's classes, a collection designed to hold <code>Object</code> can hold any Java objects. There is, however, one big problem. Suppose, for example, you wish to define an <code>ArrayList</code> of <code>String</code>.  In the <code>add(Object)</code> operation, the <code>String</code> will be upcasted implicitly into <code>Object</code> by the compiler.  During retrieval, however, it is the programmer's responsibility to downcast the <code>Object</code> back to a <code>String</code> explicitly. If you inadvertently added in a non-<code>String</code> object, the compiler cannot detect the error, but the downcasting will fail at runtime. Below is an example:</p>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

<span class="color-comment">// Pre-JDK 5 Collection</span>
public class <strong>PreJ5ArrayListTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// We create a List meant for String</span>
      <span class="color-new">List strLst = new ArrayList()</span>;  <span class="color-comment">// Pre-JDK 5 List holds Objects</span>
      strLst.add(&quot;alpha&quot;);            <span class="color-comment">// String upcasts to Object implicitly</span>
      strLst.add(&quot;beta&quot;);
      Iterator iter = strLst.iterator();
      while (iter.hasNext()) {
         String str = <span class="color-new">(String)</span>iter.next(); <span class="color-comment">// need to explicitly downcast Object back to String</span>
         System.out.println(str);
      }

      <span class="color-comment">// We inadvertently add a non-String into the List meant for String</span>
      strLst.add(<span class="color-new">new Integer(1234)</span>);       <span class="color-comment">// Compiler and runtime cannot detect this logical error</span>
      String str = <span class="color-new">(String)</span>strLst.get(2);  <span class="color-comment">// Retrieve and downcast back to String</span>
      <span class="color-comment">// Compile ok, but runtime exception</span>
      <span class="color-comment">//<span class="color-error">java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String</span></span>
   }
}</pre>

<p>We could use an <code>instanceof</code> operator to check for proper type before downcasting. But again, <code>instanceof</code> detects the problem at runtime. How about <em>compile-time type-checking</em>? JDK 5 introduces generics to resolve this problem to provide compile-time type-safe checking, as shown in the above example.</p>

<h4>Generic Wildcard (<span class="font-code">?</span>) and Bounded Type Parameters</h4>

<p>Wildcard (?) can be used to represent an unknown type in Generics:</p>
<ul>
<li><code><span class="color-new">&lt;? extends T&gt;</span></code>: called <em>upper bounded wildcard</em> which accepts type <code>T</code> or <code>T</code>'s subtypes. The upper bound type is <code>T</code>.</li>
<li><code><span class="color-new">&lt;? super T&gt;</span></code>: called <em>lower bounded wildcard</em> which accepts type <code>T</code> or <code>T</code>'s supertypes. The lower bound type is <code>T</code>.</li>
<li><code><span class="color-new">&lt;?&gt;</span></code>: called <em>unbounded wildcard</em> which accepts all types.</li>
</ul>

<p>Bounded Type Parameters have the forms:</p>
<ul>
<li><code><span class="color-new">&lt;T extends ClassName&gt;</span></code>: called <em>upper bounded type parameter</em> which accepts the specified <code>ClassName</code> and its subtypes. The upper bound type is <code>ClassName</code>.</li>
</ul>

<h4>Example 3: Upper-Bounded Wildcard <span class="font-code">&lt;? extends T&gt;</span> for Accepting Collections of <span class="font-code">T</span> and <span class="font-code">T</span>'s Subtypes</h4>

<p>As an example, the <code>ArrayList&lt;E&gt;</code> has a method <code>addAll()</code> with the following signature:</p>

<pre class="color-syntax">
public class ArrayList<span class="color-new">&lt;E&gt;</span> implements List<span class="color-new">&lt;E&gt;</span> .... {
   public boolean addAll(Collection<span class="color-new">&lt;? extends E&gt;</span> c)
   .......
}</pre>

<p>The <code>addAll()</code> accepts a <code>Collection</code> of <code>E</code> and <code>E</code>'s subtypes. Via substitution, it also accepts subtypes of <code>Collection</code>.</p>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Set;
import java.util.HashSet;

public class <strong>GenericUpperBoundedTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Set E to Number.
      // Number is supertype of Integer, Double and Float</span>
      <span class="color-new">List&lt;Number&gt;</span> numLst = new <span class="color-new">ArrayList&lt;&gt;</span>();<span class="color-comment"></span>
      numLst<span class="color-new">.add(1.1f)</span>;   <span class="color-comment">// primitive float auto-box to Float, upcast to Number</span>
      System.out.println(numLst);  <span class="color-comment">//<span class="color-output">[1.1]</span></span>

      <span class="color-comment">// Integer is a subtype of Number, which satisfies &lt;? extends E=Number&gt;</span>
      <span class="color-new">Collection&lt;Integer&gt;</span> intColl = new <span class="color-new">LinkedList&lt;&gt;</span>();
      intColl.add(2);  <span class="color-comment">// primitive int auto-box to Integer</span>
      intColl.add(3);
      System.out.println(intColl);  <span class="color-comment">//<span class="color-output">[2, 3]</span></span>
      <span class="color-comment">// Try .addAll(Collection&lt;? extends E&gt;)</span>
      <span class="color-new">numLst.addAll(intColl)</span>;
      System.out.println(numLst);   <span class="color-comment">//<span class="color-output">[1.1, 2, 3]</span></span>

      <span class="color-comment">// Double is a subtype of Number, which satisfies &lt;? extends E=Number&gt;</span>
      <span class="color-comment">// Set is a subtype of Collection. Set&lt;Double&gt; is a subtype of Collection&lt;Double&gt;</span>
      <span class="color-new">Set&lt;Double&gt;</span> numSet = new <span class="color-new">HashSet&lt;&gt;</span>();
      numSet.add(4.4);   <span class="color-comment">// primitive double auto-box to Double</span>
      numSet.add(5.5);
      System.out.println(numSet);  <span class="color-comment">//<span class="color-output">[5.5, 4.4]</span></span>
      <span class="color-comment">// Try .addAll(Collection&lt;? extends E&gt;)</span>
      <span class="color-new">numLst.addAll(numSet)</span>;
      System.out.println(numLst);  <span class="color-comment">//<span class="color-output">[1.1, 2, 3, 5.5, 4.4]</span></span>
   }
}</pre>

<h5>Notes:</h5>

<ul>
<li>The <code>addAll()</code> is not merge, but iterating through the <code>Collection</code> and add elements one-by-one.</li>
<li>If <code>addAll()</code> is defined as <code>addAll(Collection&lt;E&gt;)</code> without the upper bound wildcard, and E is <code>Number</code>, then it can accept <code>Collection&lt;Number&gt;</code>, but NOT <code>Collection&lt;Integer&gt;</code>.</li>
<li>In generics, <code>Collection&lt;Integer&gt;</code> is not a subtype of <code>Collection&lt;Number&gt;</code>, although <code>Integer</code> is a subtype of <code>Number</code>. You cannot substitute <code>Collection&lt;Integer&gt;</code> for <code>Collection&lt;Number&gt;</code>. But <code>Collection&lt;Number&gt;</code> can contain <code>Integer</code>s. See next section for the explanation.</li>
<li>In generics, <code>Set&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code>, as <code>Set</code> is a subtype of <code>List</code> and they have the same parametric type.</li>
<li>The upper bounded wildcard <code>&lt;? extends E&gt;</code> is meant to handle &quot;<code>Collection</code> of <code>E</code> and <code>E</code>'s subtypes&quot;, for maximum flexibility.</li>
</ul>

<h4>Example 4: Lower-Bounded Wildcard <span class="font-code">&lt;? super T&gt;</span> for Applying Operations on <span class="font-code">T</span> and <span class="font-code">T</span>'s Supertype</h4>

<p>As an example, the <code>List</code> has a method <code>forEach(Consumer&lt;? super E&gt; action)</code> (introduced in JDK 8 inherited from its supertype <code>Iterable</code>), which accepts a <code>Consumer</code>  capable of operating on type <code>E</code> and <code>E</code>'s super-types, to operate on each of the elements.</p>

<pre class="color-syntax">
public class List<span class="color-new">&lt;E&gt;</span> implements Iterable<span class="color-new">&lt;E&gt;</span> .... {
   public void forEach(Consumer<span class="color-new">&lt;? super E&gt;</span> action)
   .......
}</pre>

<pre class="color-example">
import java.util.List;
import java.util.function.Consumer;  <span class="color-comment">// JDK 8</span>

public class <strong>GenericLowerBoundedTypeTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Set E to Double to create a List&lt;Double&gt;</span>
      <span class="color-new">List&lt;Double&gt;</span> dLst = List.of(1.1, 2.2);  <span class="color-comment">// JDK 9 to generate an unmodifiable List</span>

      <span class="color-comment">// Set up a Consumer&lt;Double&gt; that is capable of operating on Double
      // We can only use methods supported by Double, such as Double.doubleToRawLongBits(d)</span>
      <span class="color-new">Consumer&lt;Double&gt;</span> dConsumer = d -&gt; System.out.printf(&quot;%x%n&quot;, Double.doubleToRawLongBits(d));
      <span class="color-comment">// Run .forEach() with Consumer&lt;Double&gt; operating on each Double element</span>
      dLst.forEach(dConsumer);
      <span class="color-comment">//<span class="color-output">3ff199999999999a</span></span>
      <span class="color-comment">//<span class="color-output">400199999999999a</span></span>

      <span class="color-comment">// Set up a Consumer&lt;Number&gt;</span>
      <span class="color-comment">// Number is a supertype of Double, which satisfies &lt;? super E=Double&gt;.
      // We can only use methods supported by Number, such as .intValue()</span>
      <span class="color-new">Consumer&lt;Number&gt;</span> numConsumer = num -&gt; System.out.println(num.intValue());  <span class="color-comment">// JDK 8</span>
      <span class="color-comment">// Run .forEach() with Consumer&lt;Number&gt; operating on each Double element
      // Since Double is a subtype of Number. It inherits and supports all methods in Number.</span>
      dLst.forEach(numConsumer);
      <span class="color-comment">//<span class="color-output">1</span></span>
      <span class="color-comment">//<span class="color-output">2</span></span>
   }
}</pre>

<h5>Notes:</h5>
<ul>
<li>If <code>forEach()</code> is defined as <code>forEach(Consumer&lt;E&gt;)</code> without the lower bound wildcard, and <code>E</code> is <code>Double</code>, then it can only accepts <code>Consumer&lt;Double&gt;</code>, but NOT <code>Consumer&lt;Number&gt;</code>. Since <code>Number</code> is a supertype of <code>Double</code>, <code>Consumer&lt;Number&gt;</code> can also be used to process <code>Double</code>. Hence, it make sense to use <code>Consumer&lt;? extends Double&gt;</code> to include the supertypes <code>Consumer&lt;Number&gt;</code> and <code>Consumer&lt;Object&gt;</code> for maximum flexibility.</li>
<li>The lower bounded wildcard <code>&lt;? super E&gt;</code> is meant to operate on <code>E</code>, with function objects operating on <code>E</code> and <code>E</code>'s supertype, for maximum flexibility.</li>
</ul>


<h4>Example 5: Generic Method with Upperbound and Lowerbound Wildcards</h4>

<p>As an example, the <code>java.lang.String</code> class (a non-generic class) contains a generic method called <code>transform()</code> (JDK 12) with the following signature:</p>

<pre class="color-syntax">
public class <strong>String</strong> {
   public <span class="color-new">&lt;R&gt;</span> R transform(Function<span class="color-new">&lt;? super String, ? extends R&gt;</span> f) {
      return f.apply(this);
   }
   ......
}</pre>

<p>This method takes a <code>Function</code> object as argument and returns a generic type <code>R</code>. The generic types used in generic methods (which is not declared in the <code>class</code> statement) are to be declared before the return type, in this case, <code><span class="color-new">&lt;R&gt;</span></code>, to prevent compilation error &quot;cannot find symbol&quot;.</p>
<p>The generic <code>Function</code> object takes two type arguments: a <code>String</code> or its supertypes &lt;<code>? super String</code>&gt;, and a return-type <code>R</code> or its subtypes &lt;<code>? extends R</code>&gt;.</p>

<p>For example,</p>

<pre class="color-example">
import java.util.function.Function;
import java.util.List;
import java.util.ArrayList;

public class <strong>StringTransformTest</strong> {
   public static void main(String[] args) {
      String str = &quot;hello&quot;;

      <span class="color-comment">// Set the return-type R to Number
      // Set up Function&lt;String, Number&gt;, which takes a String and returns a Number</span>
      <span class="color-new">Function&lt;String, Number&gt;</span> f1 = String::length;  <span class="color-comment">// int auto-box to Integer, upcast to Number</span>
      <span class="color-comment">// Run the .transform() on Function&lt;String, Number&gt;</span>
      Number n1 = str.transform(f1);
      System.out.println(n1);             <span class="color-comment">//<span class="color-output">5</span></span>
      System.out.println(n1.getClass());  <span class="color-comment">//<span class="color-output">class java.lang.Integer</span></span>
      <span class="color-comment">//Integer i1 = str.transform(f1);</span>
      <span class="color-comment">//</span><span class="color-error">compilation error: incompatible types: inference variable R has incompatible bounds</span>
      Integer i1 = (Integer)str.transform(f1);  <span class="color-comment">// Explicit downcast</span>
      System.out.println(i1);             <span class="color-comment">//<span class="color-output">5</span></span>

      <span class="color-comment">// Double is a subtype of Number, satisfying &lt;? extends R=Number&gt;
      // Set up Function&lt;String, Double&gt;, which takes a String and returns a Double</span>
      <span class="color-new">Function&lt;String, Double&gt;</span> f2 = s -&gt; (double)s.length();  <span class="color-comment">// double -&gt; Double</span>
      Number n2 = str.transform(f2);      <span class="color-comment">// Double upcast to Number</span>
      System.out.println(n2);  <span class="color-comment">//5.0</span>
      System.out.println(n2.getClass());  <span class="color-comment">//</span><span class="color-output">class java.lang.Double</span>
      Double d2 = str.transform(f2);      <span class="color-comment">// Okay</span>

      <span class="color-comment">// CharSequence is a supertype of String, which satisfies &lt;? super String&gt;</span>
      <span class="color-comment">// Integer is a subtype of Number, satisfying &lt;? extends R=Number&gt;
      // Set up Function&lt;CharSequence, Integer&gt;, which takes a CharSequence and returns a Integer</span>
      <span class="color-new">Function&lt;CharSequence, Integer&gt;</span> f3 = CharSequence::length;  <span class="color-comment">// int auto-box to Integer</span>
      Number n3 = str.transform(f3);  <span class="color-comment">// Upcast Integer to Number</span>
      System.out.println(n3);   <span class="color-comment">//<span class="color-output">5</span></span>
   }
}</pre>

<h5>Notes:</h5>
<ul>
<li>Suppose that <code>R</code> is <code>Number</code>, <code>Function&lt;? super String, ? extends R&gt;</code> includes <code>Function&lt;String, Number&gt;</code>, <code>Function&lt;String, Integer&gt;</code>, <code>Function&lt;CharSequence, Number&gt;</code>, <code>Function&lt;CharSequence, Integer&gt;</code>, and etc.</li>
<li>The upper bounded wildcard <code>&lt;? super String&gt;</code> allows function objects operating on <code>String</code> and its supertypes to be used in processing <code>String</code>, for maximum flexibility. See Example 4.</li>
<li>The return type of <code>R</code> and the lower bounded wildcard <code>&lt;? extends R&gt;</code> permits function object producing <code>R</code> and <code>R</code>'s subtype to be used, for maximum flexibility. See Example 3.</li>
</ul>

<h3 id="GenericsDetails">Generics Explained</h3>

<p>We shall illustrate the use of generics by writing our own <em>type-safe</em> resizable array (similar to an <code>ArrayList</code>).</p>
<p>We shall begin with a non-type-safe non-generic version, explain generics, and write the type-safe generic version.</p>

<h4>Example 1: Non-Type-Safe Non-Generic <span class="font-code">MyArrayList</span></h4>

<p>Let us begin with a version without generics called <code>MyArrayList</code>, which is a linear data structure, similar to array, but resizable. For the <code>MyArrayList</code> to hold all types of objects, we use an <code>Object[]</code> to store the elements. Since <code>Object</code> is the single root class in Java, all Java objects can be upcasted to <code>Object</code> and store in the <code>Object[]</code>.</p>

<h5><span class="font-code">MyArrayList.java</span></h5>

<pre class="color-example">
import java.util.Arrays;
<span class="color-comment">// A resizable array without generics, which can hold any Java objects</span>
public class <strong>MyArrayList</strong> {
   private int size;           <span class="color-comment">// number of elements</span>
   private <span class="color-new">Object[]</span> elements;  <span class="color-comment">// can store all Java objects</span>

   public MyArrayList() {         <span class="color-comment">// constructor</span>
      elements = new Object[10];  <span class="color-comment">// allocate initial capacity of 10</span>
      size = 0;
   }

   <span class="color-comment">// Add an element, any Java objects can be upcasted to Object implicitly</span>
   public void add(<span class="color-new">Object o</span>) {
      if (size &gt;= elements.length) {
         <span class="color-comment">// allocate a larger array and copy over</span>
         Object[] newElements = new Object[size + 10];
         for (int i = 0; i &lt; size; ++i) newElements[i] = elements[i];
         elements = newElements;
      }
      elements[size] = o;
      ++size;
   }

   <span class="color-comment">// Retrieves the element at Index. Returns an Object to be downcasted back to its original type</span>
   public <span class="color-new">Object</span> get(int index) {
      if (index &gt;= size)
         throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
      return elements[index];
   }

   <span class="color-comment">// Returns the current size (length)</span>
   public int size() { return size; }

   <span class="color-comment">// toString() to describe itself</span>
   @Override
   public String toString() {
      return Arrays.toString(Arrays.copyOfRange(elements, 0, size));
   }
}</pre>

<h5><span class="font-code">MyArrayListTest.java</span></h5>

<pre class="color-example">
public class <strong>MyArrayListTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Create a MyArrayList to hold a list of Strings</span>
      MyArrayList strLst = new MyArrayList();
      <span class="color-comment">// Adding elements of type String</span>
      strLst.add(&quot;alpha&quot;);   <span class="color-comment">// String upcasts to Object implicitly</span>
      strLst.add(&quot;beta&quot;);
      System.out.println(strLst);  <span class="color-comment">// toString()</span>
      <span class="color-comment">//<span class="color-output">[alpha, beta]</span></span>

      <span class="color-comment">// Retrieving elements: need to explicitly downcast back to String</span>
      for (int i = 0; i &lt; strLst.size(); ++i) {
         String str = <span class="color-new">(String)</span>strLst.get(i);
         System.out.println(str);
      }
      <span class="color-comment">//<span class="color-output">alpha</span></span><span class="color-output"></span><br />      <span class="color-comment">//<span class="color-output">beta</span></span>

      <span class="color-comment">// Inadvertently added a non-String object. Compiler cannot detect this logical error.
      // But trigger a runtime</span> <span class="color-comment">ClassCastException during downcast.</span>
      strLst.add(<span class="color-new">1234</span>);   <span class="color-comment">// int auto-box to Integer, upcast to Object. Compiler/runtime cannot detect this logical error</span>
      String str = <span class="color-new">(String)</span>strLst.get(2);
         <span class="color-comment">// compile ok
         // </span><span class="color-error">runtime ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String</span>
   }
}</pre>


<p>This <code>MyArrayList</code> is not <em>type-safe</em>. It suffers from the following drawbacks:</p>
<ol>
  <li>The upcasting to <code>java.lang.Object</code> is done implicitly by the compiler.  But, the programmer has to explicitly downcast the <code>Object</code> retrieved back to their original class (e.g., <code>String</code>).</li>
<li>The compiler is not able to check whether the downcasting is valid at <em>compile-time</em>.  Incorrect downcasting will show up only at <em>runtime</em>, as a <code>ClassCastException</code>.  This is known as <em>dynamic binding</em> or <em>late binding</em>.  For example, if you accidentally added an <code>Integer</code> object into the above list which is intended to hold <code>String</code>, the error will show up only when you try to downcast the <code>Integer</code> back to <code>String</code> - at runtime.</li>
</ol>

<p>Why not let the compiler does the upcasting/downcasting and check for casting error, instead of leaving it to the runtime, which could be too late? Can we make the compiler to catch this error to ensure <em>type safety</em> at runtime?</p>

<h4>Generics Classes with Parameterized Types</h4>

<p>JDK 5 introduces the so-called <em>generics</em> to resolve this problem.   <em>Generics</em> allow us to <em>abstract over types</em>.  The class designer can design a class with  a <em>generic type</em>. The users can create specialized instance of the class by providing the <em>specific type</em> during instantiation. Generics allow us to <em>pass type information</em>, in the form of &lt;type&gt;,   to the compiler,  so that the compiler can perform all the necessary   type-check during compilation to ensure type-safety at runtime.</p>
<p>Let's take a look at the declaration of interface <code>java.util.List&lt;E&gt;</code>:</p>
<pre class="color-syntax">
public interface <strong>List<span class="color-new">&lt;E&gt;</span> extends Collection<span class="color-new">&lt;E&gt;</span></strong> {
   abstract boolean add(<span class="color-new">E</span> element)
   abstract void add(int index, <span class="color-new">E</span> element)
   abstract E get(int index)
   abstract E set(int index, E element)
   abstract E remove(int index)
   boolean addAll(Collection<span class="color-new">&lt;? extends E&gt;</span> c)
   boolean containsAll(Collection<span class="color-new">&lt;?&gt;</span> c)
   ......
}</pre>

<p>The <code>&lt;E&gt;</code> is called the <em>formal &quot;type&quot; parameter</em> for passing type information into the generic class. During instantiation, the <em>formal type parameters</em> are replaced by the <em>actual type parameters</em>.</p>
<p>The mechanism is similar to method invocation. Recall that in a method's definition, we declare the <em>formal parameters</em> for passing data into the method. During the method invocation, the <em>formal parameters</em> are substituted by the <em>actual arguments</em>.  For example,</p>

<pre class="color-example">
<span class="color-comment">// Defining a method</span>
public static int max(int a, int b) {  <span class="color-comment">// int a, int b are <em>formal parameters</em></span>
   return (a &gt; b) ? a : b;
}

<span class="color-comment">// Invoke the method: formal parameters substituted by actual parameters</span>
int max1 = max(55, 66);  <span class="color-comment">// 55 and 66 are actual parameters</span>
int x = 77, y = 88;
int max2 = max(x, y);    <span class="color-comment">// x and y are actual parameters</span></pre>

<p><em>Formal type parameters</em> used in the class declaration have the same purpose as the formal parameters used in the method declaration.  A class can use <em>formal type parameters</em> to receive type information when an instance is created for that class.  The actual types used during instantiation are called <em>actual type parameters</em>. Compare with method which passes parameters through round bracket <code>( )</code>, type parameters are passed through angle bracket <code>&lt; &gt;</code>.</p>

<p>Let's return to the <code>List&lt;E&gt;</code>. In an actual instantiation, such as a <code>List&lt;String&gt;</code>, all occurrences of the formal type parameter <code>E</code> are replaced by the actual type parameter <code>String</code>.  With this additional type information, compiler is able to perform type check during compile-time and ensure that there won't have type-casting error at runtime. For example,</p>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;

public class <strong>J5GenericListTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Set E to String</span>
      <span class="color-new">List&lt;String&gt;</span> fruitLst = new <span class="color-new">ArrayList&lt;&gt;</span>();  <span class="color-comment">// JDK 7 supports type inference</span>
      //<span class="color-new">List&lt;String&gt;</span> fruitLst = new <span class="color-new">ArrayList&lt;String&gt;</span>();  <span class="color-comment">// Pre-JDK 7</span>
      fruitLst.add(&quot;apple&quot;);
      fruitLst.add(&quot;orange&quot;);
      for (<span class="color-new">String</span> fruit : fruitLst) System.out.println(fruit);
      <span class="color-comment">//<span class="color-output">apple</span></span>
      <span class="color-comment">//<span class="color-output">orange</span></span>

      <span class="color-comment">//fruitLst.add(<span class="color-error">123</span>);</span>  <span class="color-comment">// This generic list accepts String only</span>
      <span class="color-comment">//<span class="color-error">compilation error: incompatible types: int cannot be converted to String</span></span>
      <span class="color-comment">//fruitLst.add(<span class="color-error">new StringBuffer(&quot;Hello&quot;)</span>);
      //<span class="color-error">compilation error: incompatible types: StringBuffer cannot be converted to String</span></span>
   }
}</pre>

<h5>Generic Type vs. Parameterized Type</h5>
<p>A <em>generic type</em> is a type with <em>formal type parameter</em>s (e.g. <code>List&lt;E&gt;</code>); whereas a <em>parameterized type</em> is an instantiation of a generic type with <em>actual type arguments</em> (e.g., <code>List&lt;String&gt;</code>).</p>

<h5>Formal Type Parameter Naming Convention</h5>
<p>Use an uppercase single-character for formal type parameter.  For example,</p>
<ul>
<li><code>&lt;E&gt;</code> for an element of a collection;</li>
<li><code>&lt;T&gt;</code> for type;</li>
<li><code>&lt;K, V&gt;</code> for key and value.</li>
<li><code>&lt;N&gt;</code> for number</li>
<li><code>S</code>,<code>U</code>,<code>V</code>, etc. for 2nd, 3rd, 4th type parameters</li>
</ul>

<h4>Example 2: A Generic Class <span class="font-code">GenericBox</span></h4>

<p>In this example, a class called <code>GenericBox</code>, which takes a generic type parameter <code>E</code>, holds a <code>content</code> of type <code>E</code>. The constructor, getter and setter work on the parameterized type <code>E</code>. The <code>toString()</code> reveals the actual type of the <code>content</code>.</p>

<pre class="color-example">
<span class="color-comment">// A Generic Box with a content</span>
public class <strong>GenericBox<span class="color-new">&lt;E&gt;</span></strong> {
   private <span class="color-new">E</span> content;  <span class="color-comment">// private variable of generic type E</span>
   public GenericBox(<span class="color-new">E</span> content) {  <span class="color-comment">// constructor</span>
      this.content = content;
   }
   public <span class="color-new">E</span> getContent() {  <span class="color-comment">// getter</span>
      return content;
   }
   public void setContent(<span class="color-new">E</span> content) {  <span class="color-comment">// setter</span>
      this.content = content;
   }
   public String toString() {  <span class="color-comment">// describe itself</span>
      return &quot;GenericBox[content=&quot; + content + &quot;(&quot; + content.getClass() + &quot;)]&quot;;
   }
}</pre>


<p>The following test program creates <code>GenericBox</code>es with various types (<code>String</code>, <code>Integer</code> and <code>Double</code>). Take note that JDK 5 also introduces auto-boxing and unboxing to convert between primitives and wrapper objects.</p>

<pre class="color-example">
public class <strong>GenericBoxTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">GenericBox&lt;String&gt;</span> box1 = new <span class="color-new">GenericBox&lt;&gt;</span>(&quot;hello&quot;);  <span class="color-comment">// JDK 7 supports type inference</span>
      String str = box1.getContent();  <span class="color-comment">// no explicit downcasting needed</span>
      System.out.println(box1);
      <span class="color-comment">//</span><span class="color-output">GenericBox[content=hello(class java.lang.String)]</span>

      <span class="color-new">GenericBox&lt;Integer&gt;</span> box2 = new <span class="color-new">GenericBox&lt;&gt;</span>(123);    <span class="color-comment">// int auto-box to Integer</span>
      int i = box2.getContent();       <span class="color-comment">// Integer auto-unbox to int</span>
      System.out.println(box2);
      <span class="color-comment">//<span class="color-output">GenericBox[content=123(class java.lang.Integer)]</span></span>

      <span class="color-new">GenericBox&lt;Double&gt;</span> box3 = new <span class="color-new">GenericBox&lt;&gt;</span>(55.66);  <span class="color-comment">// double auto-box to Double</span>
      double d = box3.getContent();    <span class="color-comment">// Double auto-unbox to double</span>
      System.out.println(box3);
      <span class="color-comment">//<span class="color-output">GenericBox[content=55.66(class java.lang.Double)]</span></span>
   }
}</pre>

<h4>(JDK 7) Improved Type Inference for Generic Instance Creation with the Diamond Operator <span class="font-code">&lt;&gt;</span></h4>

<p>Before JDK 7, to create an instance of the above <code>GenericBox</code>, you need to specify to type in the constructor:</p>

<pre class="color-example">
GenericBox&lt;String&gt; box1 = new GenericBox<span class="color-new">&lt;String&gt;</span>(&quot;hello&quot;);
</pre>

<p>JDK 7 introduces the <em>type inference</em> to shorten the code, as follows:</p>
<pre class="color-example">
GenericBox&lt;String&gt; box1 = new GenericBox<span class="color-new">&lt;&gt;</span>(&quot;hello&quot;);  <span class="color-comment">// type inferred from the variable</span>
</pre>

<h4>Type Erasure</h4>

<p>From the previous example, it seems that compiler substituted the parameterized type <code>E</code> with the actual type (such as <code>String</code>, <code>Integer</code>) during instantiation. If this is the case, the compiler would need to create a new class for each actual type (similar to C++'s template).</p>

<p>In fact, the compiler replaces all reference to parameterized type <code>E</code> with <code>java.lang.Object</code>. For example, the above <code>GenericBox</code> is compiled as follows, which is compatible with the code without generics:</p>


<pre class="color-example">
public class <strong>GenericBox</strong> {
   private <span class="color-new">Object</span> content;  <span class="color-comment">// private variable</span>
   public GenericBox(<span class="color-new">Object</span> content) {  <span class="color-comment">// Constructor</span>
      this.content = content;
   }
   public <span class="color-new">Object</span> getContent() {  <span class="color-comment">// getter</span>
      return content;
   }
   public void setContent(<span class="color-new">Object</span> content) {  <span class="color-comment">// setter</span>
      this.content = content;
   }
   public String toString() {  <span class="color-comment">// describe itself</span>
      return &quot;GenericBox[content=&quot; + content + &quot;(&quot; + content.getClass() + &quot;)]&quot;;
   }
}</pre>

<p>The compiler  performs the type checking and inserts the required downcast operator when the methods are invoked:</p>
<pre class="color-example">
<span class="color-comment">// Constructor: public GenericBox(<span class="color-new">E</span> content)</span>
<span class="color-new">GenericBox&lt;String&gt;</span> box1 = new <span class="color-new">GenericBox&lt;&gt;</span>(&quot;hello&quot;);  <span class="color-comment">// Knowing E=String, compiler performs the type check</span>

<span class="color-comment">// Getter: public <span class="color-new">E</span> getContent()</span>
String str = <span class="color-new">(String)</span>box1.getContent();  <span class="color-comment">// Compiler inserts the downcast operator to downcast Object to String</span></pre>

<p>In this way, the same class definition is used for all the types. Most importantly, the bytecode are compatible with those without generics. This process is called <em>type erasure</em>.</p>

<p>For example, <code>GenericBox&lt;Integer&gt;</code> and <code>GenericBox&lt;String&gt;</code> are compiled into the same runtime class <code>GenericBox</code>.</p>
<pre class="color-example">
public class <strong>GenericBoxTypeTest</strong> {
   public static void main(String[] args) {
      <span class="color-new">GenericBox&lt;Integer&gt;</span> box1 = new GenericBox&lt;&gt;(123);
      <span class="color-new">GenericBox&lt;String&gt;</span> box2 = new GenericBox&lt;&gt;(&quot;hello&quot;);
      System.out.println(<span class="color-new">box1.getClass() == box2.getClass()</span>);  <span class="color-comment">//<span class="color-output">true</span> (same runtime class)</span>
      System.out.println(box1.getClass());  <span class="color-comment">//<span class="color-output">class GenericBox</span></span>
      System.out.println(box2.getClass());  <span class="color-comment">//<span class="color-output">class GenericBox</span></span>
   }
}</pre>


<h4>Example 3: Type-Safe <span class="font-code">MyGenericArrayList&lt;E&gt;</span></h4>

<p>Let's return to the <code>MyArrayList</code> example.  With the use of generics, we can rewrite our program as follows:</p>

<pre class="color-example">
<span class="color-comment">// A dynamically allocated array with generics</span>
public class <strong>MyGenericArrayList<span class="color-new">&lt;E&gt;</span></strong> {  <span class="color-comment">// E is the generic type of the elements</span>
   private int size;                  <span class="color-comment">// number of elements</span>
   private <span class="color-new">Object[]</span> elements;         <span class="color-comment">// Need to use an Object[], not E[]</span>

   public MyGenericArrayList() {  <span class="color-comment">// constructor</span>
      elements = <span class="color-new">new Object[10]</span>;  <span class="color-comment">// allocate initial capacity of 10</span>
      size = 0;
   }

   public void add(<span class="color-new">E e</span>) {
      if (size &gt;= elements.length) {
         <span class="color-comment">// allocate a larger array and copy over</span>
         Object[] newElements = new Object[size + 10];
         for (int i = 0; i &lt; size; ++i) newElements[i] = elements[i];
         elements = newElements;
      }
      elements[size] = e;
      ++size;
   }

   @SuppressWarnings(&quot;unchecked&quot;)
   public <span class="color-new">E</span> get(int index) {
      if (index &gt;= size)
         throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
      return <span class="color-new">(E)</span>elements[index];   <span class="color-comment">// triggers an &quot;unchecked cast&quot; warning</span>
   }

   public int size() { return size; }
}</pre>

<h5>Dissecting the Program</h5>

<p><code>MyGenericArrayList&lt;E&gt;</code> declare a generics class with a <em>formal type parameter</em>  <code>&lt;E&gt;</code>.  During an actual invocation, e.g., <code>MyGenericArrayList&lt;String&gt;</code>, a specific type <code>&lt;String&gt;</code>, or <em>actual type parameter</em>, replaced the formal type parameter <code>&lt;E&gt;</code>.</p>

<h5>Type Erasure</h5>

<p>Behind the scene, generics are implemented by the Java compiler as a front-end conversion called <em>erasure</em>, which translates or rewrites code that uses generics into non-generic code to ensure backward compatibility. This conversion erases all generic type information. The formal type parameter, such as <code>&lt;E&gt;</code>, are replaced by <code>Object</code> by default (or by the upper bound of the type). When the resulting code is not type correct, the compiler insert a type casting operator.</p>

<p>Hence, the translated code is as follows:</p>
<pre class="color-example">
<span class="color-comment">// The translated code</span>
public class <strong>MyGenericArrayList</strong> {
   private int size;     <span class="color-comment">// number of elements</span>
   private <span class="color-new">Object[] elements</span>;
   
   public MyGenericArrayList() {  <span class="color-comment">// constructor</span>
      elements = <span class="color-new">new Object[10]</span>;  <span class="color-comment">// allocate initial capacity of 10</span>
      size = 0;
   }
   
   <span class="color-comment">// Compiler replaces E with Object, but check e is of type E, when invoked to ensure type-safety</span>
   public void add(<span class="color-new">Object e</span>) {
      if (size &lt; elements.length) {
         elements[size] = e;
      } else {
         <span class="color-comment">// allocate a larger array and copy over</span>
         Object[] newElements = new Object[size + 10];
         for (int i = 0; i &lt; size; ++i) newElements[i] = elements[i];
         elements = newElements;
      }
      ++size;
   }
   
   <span class="color-comment">// Compiler replaces E with Object, and insert downcast operator (E&lt;E&gt;) for the return type when invoked</span>
   public <span class="color-new">Object</span> get(int index) {
      if (index &gt;= size)
         throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
      return <span class="color-new">(Object)</span>elements[index];
   }
   
   public int size() {
      return size; 
   }
}</pre>

<p>When the class is instantiated with an actual type parameter, e.g. <code>MyGenericArrayList&lt;String&gt;</code>, the compiler performs type check to ensures <code>add(E e)</code> operates on only <code>String</code> type. It also inserts the proper downcasting operator to match the return type <code>E</code> of <code>get()</code>. For example,</p>

<pre class="color-example">
public class <strong>MyGenericArrayListTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// type-safe to hold a list of Strings</span>
      <span class="color-new">MyGenericArrayList&lt;String&gt;</span> strLst = new <span class="color-new">MyGenericArrayList&lt;&gt;</span>();  <span class="color-comment">// JDK 7 diamond operator</span>
      strLst.add(&quot;alpha&quot;);   <span class="color-comment">// compiler checks if argument is of type String</span>
      strLst.add(&quot;beta&quot;);

      for (int i = 0; i &lt; strLst.size(); ++i) {
         String str = strLst.get(i);   <span class="color-comment">// compiler inserts the downcasting operator (String)</span>
         System.out.println(str);
      }

      <span class="color-comment">//strLst.add(<span class="color-error">123</span>);  // compiler detected argument is NOT String, issues compilation error</span>
      <span class="color-comment">//<span class="color-error">compilation error: incompatible types: int cannot be converted to String</span></span>
   }
}</pre>


<p>With generics, the compiler is able to perform type checking during compilation to ensure type safety at runtime.</p>

<p>Unlike &quot;template&quot; in C++, which creates a new type for each specific parameterized type, in Java, a generics class is only compiled once, and there is only one single class file which is used to create instances for all the specific types.</p>

<h4>Backward Compatibility</h4>

<p>If you compile a Pre-JDK 5 program using JDK 5 and above compiler, you will receive some warning messages to warn you about the <em>unsafe operations</em>, i.e., the compiler is unable to check for the type (because it was not informed of the type via generics) and ensure type-safety at runtime. You could go ahead and execute the program with warnings. For example,</p>

<pre class="color-example">
<span class="color-comment">// Pre-JDK 5 Collection without generics</span>
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

public class ArrayListPreJ5Test {
   public static void main(String[] args) {
      List lst = new ArrayList();  <span class="color-comment">// A List contains instances of Object</span>
      lst.add(&quot;alpha&quot;);            <span class="color-comment">// add() takes Object. String upcasts to Object implicitly</span>
      lst.add(&quot;beta&quot;);
      System.out.println(lst);     <span class="color-comment">//[alpha, beta]</span>

      Iterator iter = lst.iterator();
      while (iter.hasNext()) {
         String str = (String)iter.next();  <span class="color-comment">// explicitly downcast from Object back to String</span>
         System.out.println(str);
      }
      <span class="color-comment">//alpha</span>
      <span class="color-comment">//beta</span>
   }
}</pre>

<pre class="color-command">
&gt; <strong>javac ArrayListPreJ5Test.java</strong>
Note: ArrayListPreJ5Test.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.

&gt; <strong>javac -Xlint:unchecked ArrayListPreJ5Test.java</strong>
ArrayListPreJ5Test.java:9: warning: [unchecked] <span class="color-error">unchecked call to add(E)</span> as a member of the raw type List
......</pre>

<h4>Generic Methods</h4>
<p>Other than generic class described in the above section, we can also define methods with generic types.</p>

<p>For example, the <code>java.lang.String</code> class, which is non-generic, contain a generic method <code>.transform()</code> defined as follows:</p>

<pre class="color-syntax">
<span class="color-comment">// Class java.lang.<span class="color-new">String</span></span>
public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f)   <span class="color-comment">// JDK 12</span></pre>

<p>A generic method should declare formal type parameters, which did not appear in the <code>class</code> statement, (e.g. <code>&lt;R&gt;</code>) <em>preceding the return type</em>. The formal type parameters can then be used as <em>placeholders</em> for return type, method's parameters and local variables within a generic method, for proper type-checking by compiler.</p>

<h5>Example</h5>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;

public class GenericMethodTest {
   <span class="color-comment">// A static generic method to append an array to a List</span>
   public static <span class="color-new">&lt;E&gt; void Array2List(E[] arr, List&lt;E&gt; lst)</span> {
      for (E e : arr) lst.add(e);
   }

   public static void main(String[] args) {
      <span class="color-comment">// Set E to Integer</span>
      <span class="color-new">Integer[]</span> arr = {55, 66};  <span class="color-comment">// int auto-box to Integer</span>
      <span class="color-new">List&lt;Integer&gt;</span> lst = new ArrayList&lt;&gt;();
      <span class="color-new">Array2List</span>(arr, lst);
      System.out.println(lst);   <span class="color-comment">//[55, 66]</span>

      <span class="color-new">String[]</span> strArr = {&quot;alpha&quot;, &quot;beta&quot;, &quot;charlie&quot;};
      <span class="color-comment">//<span class="color-error">Array2List</span>(strArr, lst);</span>
      <span class="color-comment">//<span class="color-error">compilation error: method Array2List in class GenericMethodTest</span></span>
      <span class="color-comment">//  <span class="color-error">cannot be applied to given types</span></span>
   }
}</pre>

<p>In this example, we define a <code>static</code> generic method <code>Array2List()</code> to append an array of generic type <code>E</code> to a <code>List&lt;E&gt;</code>. In the method definition, we need to declare the generic type <code>&lt;E&gt;</code> before the return-type <code>void</code>.</p>

<p>Similar to generic class, when the compiler translates a generic method, it replaces the formal type parameters using <em>erasure</em>.  All the generic types are replaced with type <code>Object</code> by default (or the upper bound of type).  The translated version is as follows:</p>

<pre class="color-example">public static void Array2List(<span class="color-new">Object[]</span> arr, List lst) {
   for (Object e : arr) lst.add(e);
}</pre>
<p>When the method is invoked, the compiler performs type check and inserts downcasting operator during retrieval.</p>

<p>Generics have an optional syntax for specifying the type for a generic method. You can place the actual type in angle brackets <code>&lt;&gt;</code>, between the dot operator and method name. For example,</p>
<pre class="color-example">
GenericMethodTest.&lt;Integer&gt;Array2List(arr, lst);</pre>

<p>The syntax makes the code more readable and also gives you control over the generic type in situations where the type might not be obvious.</p>

<h4>Generic Subtypes</h4>

<p>Knowing that <code>String</code> is a subtype of <code>Object</code>. Consider the following lines of codes:</p>
<pre class="color-example">
<span class="color-comment">// String is a subtype of Object</span>
Object obj = &quot;hello&quot;;     <span class="color-comment">// A supertype reference holding a subtype instance</span>
System.out.println(obj);  <span class="color-comment">//<span class="color-output">hello</span></span>

<span class="color-comment">// But ArrayList&lt;String&gt; is not a subtype of ArrayList&lt;Object&gt;</span>
ArrayList&lt;Object&gt; lst = new ArrayList&lt;String&gt;();
<span class="color-comment">//</span><span class="color-error">compilation error: incompatible types: ArrayList&lt;String&gt; cannot be converted to ArrayList&lt;Object&gt;</span></pre>

<p>When we try to upcast <code>ArrayList&lt;String&gt;</code> to <code>ArrayList&lt;Object&gt;</code>, it trigger a compilation error &quot;incompatible types&quot;. This is because  <code>ArrayList&lt;String&gt;</code> is NOT a subtype of <code>ArrayList&lt;Object&gt;</code>, even through <code>String</code> is a subtype of <code>Object</code>.</p>
<p>This error is against our intuition on inheritance. Why? Consider these two statements:</p>
<pre class="color-example">
<span class="color-new">List&lt;String&gt; strLst</span> = new ArrayList&lt;&gt;();  <span class="color-comment">// 1</span>
<span class="color-new">List&lt;Object&gt; objLst = strLst</span>;             <span class="color-comment">// 2</span>
<span class="color-comment">//<span class="color-error">compilation error: incompatible types: List&lt;String&gt; cannot be converted to List&lt;Object&gt;</span></span></pre>

<p>Line 2 generates a compilation error. But if line 2 succeeds and some arbitrary objects are added into <code>objLst</code>, <code>strLst</code> will get &quot;corrupted&quot; and no longer contains only <code>String</code>s, as references <code>objLst</code> and <code>strLst</code> share the same value.</p>
<p>Hence, <code>List&lt;String&gt;</code> is NOT a subtype of <code>List&lt;Object&gt;</code>, although <code>String</code> is a subtype of <code>Object</code>.</p>

<p>On the other hands, the following is valid:</p>
<pre class="color-example">
<span class="color-comment">// ArrayList is a subtype of List</span>
List&lt;String&gt; lst = new ArrayList&lt;&gt;();  <span class="color-comment">// valid</span></pre>

<p>That is, <code>ArrayList&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code>, since <code>ArrayList</code> is a subtype of <code>List</code> and both have the same parametric type <code>String</code>.</p>

<p>In summary:</p>
<ol>
<li>Different instantiation of the same generic type for different concrete type arguments (such as <code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>, <code>List&lt;Object&gt;</code>) have NO type relationship.</li>
<li>Instantiations of super-sub generic types for the same actual type argument exhibit the same super-sub type relationship, e.g., <code>ArrayList&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code>.</li>
</ol>

<h5>Array Subtype?</h5>
<p><code>String[]</code> is a subtype of <code>Object[]</code>. But if you upcast a <code>String[]</code> to <code>Object[]</code>, you cannot re-assign value of non-<code>String</code> type. For example,</p>

<pre class="color-example">
import java.util.Arrays;
public class <strong>ArraySubtypeTest</strong> {
   public static void main(String[] args) {
      String[] strArr = {&quot;apple&quot;, &quot;orange&quot;};
      <span class="color-new">Object[] objArr = strArr</span>;  <span class="color-comment">// upcast String[] to Object[]</span>
      System.out.println(Arrays.toString(objArr));
      objArr[0] = 123;  <span class="color-comment">// compile ok, runtime error</span>
      <span class="color-comment">//Exception in thread &quot;main&quot; java.lang.ArrayStoreException: java.lang.Integer</span>
   }
}</pre>

<p>Arrays carry runtime type information about their component type. Hence, you CANNOT use <code>E[]</code> in your generic class, but need to use <code>Object[]</code>, as in the <code>MyGenericArrayList&lt;E&gt;</code>.</p>

<h4>Wildcards <span class="font-code">&lt;? extends T&gt;</span>, <span class="font-code">&lt;? super T&gt;</span> and <span class="font-code">&lt;?&gt;</span></h4>

<p>Suppose that we want to write a  <em>generic method</em> called <code>printList(List&lt;.&gt;)</code> to print the elements of a List. If we define the method as <code>printList(List&lt;Object&gt; lst)</code>, then it can only accept an argument of <code>List&lt;object&gt;</code>, but not <code>List&lt;String&gt;</code> or <code>List&lt;Integer&gt;</code>.  For example,</p>

<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
public class <strong>GenericWildcardTest</strong> {
   <span class="color-comment">// Accepts List&lt;Object&gt;, NOT list&lt;String&gt;, List&lt;Integer&gt;, etc.</span>
   public static void <span class="color-new">printList(List&lt;Object&gt; lst)</span> {
      for (Object o : lst) System.out.println(o);
   }

   public static void main(String[] args) {
      List&lt;Object&gt; objLst = new ArrayList&lt;&gt;();  <span class="color-comment">// ArrayList&lt;Object&gt; inferred</span>
      objLst.add(11);  <span class="color-comment">// int auto-box to Integer, upcast to Object</span>
      objLst.add(22);
      <span class="color-new">printList</span>(objLst);
      <span class="color-comment">// <span class="color-output">11</span></span>
      <span class="color-comment">// <span class="color-output">22</span></span>

      List&lt;String&gt; strLst = new ArrayList&lt;&gt;();  <span class="color-comment">// ArrayList&lt;String&gt; inferred</span>
      strLst.add(&quot;one&quot;);
      <span class="color-comment">//<span class="color-error">printList</span>(strLst);  // only accept List&lt;Object&gt;</span>
      <span class="color-comment">//<span class="color-error">error: incompatible types: List&lt;String&gt; cannot be converted to List&lt;Object&gt;</span></span>
   }
}</pre>

<h5>Unbounded Wildcard <span class="font-code">&lt;?&gt;</span></h5>
<p>To resolve this problem, a wildcard (<code>?</code>) is provided in generics, which stands for <em>any unknown type</em>. For example, we can rewrite our <code>printList()</code> as follows to accept a <code>List</code> of any unknown type.</p>

<pre class="color-example">
public static void printList(<span class="color-new">List&lt;?&gt;</span> lst) {
  for (Object o : lst) System.out.println(o);
}</pre>

<p>The unbounded wildcard <code>&lt;?&gt;</code> is, at times, too relax in type.</p>

<h5>Upper Bounded Wildcard <span class="font-code">&lt;? extends T&gt;</span></h5>

<p>To write a generic method that works on <code>List&lt;Number&gt;</code> and the subtypes of <code>Number</code>, such as <code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code>, we could use an upper bounded wildcard <code>&lt;? extends Number&gt;</code>.</p>
<p>In general, the wildcard <code>&lt;? extends T&gt;</code> stands for type <code>T</code> and <code>T</code>'s subtypes.</p>
<p>For example,</p>

<pre class="color-example">
import java.util.List;
public class <strong>GenericUpperBoundedWildcardTest</strong> {
   <span class="color-comment">// Generic method which accepts List&lt;Number&gt;</span>
   <span class="color-comment">//   and Number's subtypes such as Integer, Double</span>
   public static double sumList(<span class="color-new">List&lt;? extends Number&gt;</span> lst) {
      double sum = 0.0;
      for (Number num : lst) {
         sum += num.doubleValue();
      }
      return sum;
   }

   public static void main(String[] args) {
      <span class="color-new">List&lt;Integer&gt;</span> intLst = List.of(1, 2, 3); <span class="color-comment">// JDK 9 unmodifiable List</span>
      System.out.println(<span class="color-new">sumList</span>(intLst));  <span class="color-comment">//<span class="color-output">6.0</span></span>

      <span class="color-new">List&lt;Double&gt;</span> doubleLst = List.of(1.1, 2.2, 3.3);
      System.out.println(<span class="color-new">sumList</span>(doubleLst));  <span class="color-comment">//<span class="color-output">6.6</span></span>

      <span class="color-new">List&lt;String&gt;</span> strLst = List.of(&quot;apple&quot;, &quot;orange&quot;);
      <span class="color-comment">//<span class="color-error">sumList(strLst);</span></span>
      <span class="color-comment">//<span class="color-error">error: incompatible types: List&lt;String&gt; cannot be converted to List&lt;? extends Number&gt;</span></span>
   }
}</pre>

<p><code>List&lt;? extends Number&gt;</code> accepts <code>List</code> of <code>Number</code> and any subtypes of <code>Number</code>, e.g., <code>List&lt;Integer&gt; </code>and <code>List&lt;Double&gt;</code>.</p>

<p>Another example,</p>
<pre class="color-example">
<span class="color-comment">//<span class="color-error">List&lt;Number&gt;</span> lst = new <span class="color-error">ArrayList&lt;Integer&gt;</span>();<br />//</span><span class="color-error">compilation error: incompatible types: ArrayList&lt;Integer&gt; cannot be converted to List&lt;Number&gt;</span>

<span class="color-new">List&lt;? extends Number&gt;</span> lst = new <span class="color-new">ArrayList&lt;Integer&gt;</span>();  <span class="color-comment">// valid</span></pre>

<h5>Revisit Unbounded Wildcard <span class="font-code">&lt;?&gt;</span></h5>

<p>Clearly, <code>&lt;?&gt;</code> can be interpreted as <code>&lt;? extends Object&gt;</code>, which accepts ALL Java classes. You should use <code>&lt;?&gt;</code> only if:</p>
<ol>
<li>The implementation depends only on methods that provided in the <code>Object</code> class.</li>
<li>The implementation does not depend on the type parameter.</li>
</ol>

<h5>Lower Bounded Wildcard <span class="font-code">&lt;? super T&gt;</span></h5>
<p>The wildcard <code>&lt;? super T&gt;</code> matches type <code>T</code>, as well as <code>T</code>'s supertypes. In other words, it specifies the lower bound type.</p>
<p>Suppose that we want to write a generic method that puts an <code>Integer</code> into a <code>List</code>. To maximize flexibility, we also like the method to work on <code>List&lt;Integer&gt;</code>, as well as <code>List&lt;Number&gt;</code>, <code>List&lt;Object&gt;</code> that can hold <code>Integer</code>. In this case, we could use the less restrictive lower bounded wildcard <code>&lt;? super Integer&gt;</code>, instead of simply <code>List&lt;Integer&gt;</code>. For example,</p>


<pre class="color-example">
import java.util.List;
import java.util.ArrayList;
public class <strong>GenericLowerBoundedWildcardTest</strong> {
   <span class="color-comment">// Generic method which accepts List&lt;Integer&gt;</span>
   <span class="color-comment">//   and Integer's supertypes such as Number and Object</span>
   public static void addIntToList(<span class="color-new">List&lt;? super Integer&gt;</span> lst, int num) {
      lst.add(num);
   }

   public static void main(String[] args) {
      <span class="color-new">List&lt;Integer&gt;</span> intLst = new ArrayList&lt;&gt;(); <span class="color-comment">// modifiable List</span>
      intLst.add(1);
      intLst.add(2);
      System.out.println(intLst);  <span class="color-comment">//</span><span class="color-output">[1, 2]</span>
      <span class="color-new">addIntToList</span>(intLst, 3);
      System.out.println(intLst);  <span class="color-comment">//<span class="color-output">[1, 2, 3]</span></span>

      <span class="color-new">List&lt;Number&gt;</span> numLst = new ArrayList&lt;&gt;();
      numLst.add(1.1);
      numLst.add(2.2);
      System.out.println(numLst);  <span class="color-comment">//<span class="color-output">[1.1, 2.2]</span></span>
      <span class="color-new">addIntToList</span>(numLst, 3);
      System.out.println(numLst);  <span class="color-comment">//<span class="color-output">[1.1, 2.2, 3]</span></span>

      <span class="color-new">List&lt;String&gt;</span> strLst = new ArrayList&lt;&gt;();
      <span class="color-comment">//<span class="color-error">addIntToList(strLst, &quot;hello&quot;);</span></span>
      <span class="color-comment">//<span class="color-error">error: incompatible types: List&lt;String&gt; cannot be converted to List&lt;? super Integer&gt;</span></span>
   }
}</pre>

<h4>Example: Upper and Lower Bounded Wildcards</h4>

<pre class="color-example">
import java.util.*;

@FunctionalInterface
interface <strong>MyConsumer&lt;T&gt;</strong> {
   void accept(T t);  <span class="color-comment">// public abstract</span>
}

<span class="color-comment">// Need 3 levels of class hierarchy for testing</span>
class <strong>C1</strong> {
   protected String value;
   public C1(String value) { this.value = value; }
   public void methodC1() { System.out.println(this + &quot; runs methodC1()&quot;); }
   @Override public String toString() { return &quot;C1[&quot; + value + &quot;]&quot;; }
}
class <strong>C2 extends C1</strong> {
   public C2(String value) { super(value); }
   public void methodC2() { System.out.println(this + &quot; runs methodC2()&quot;); }
   @Override public String toString() { return &quot;C2[&quot; + value + &quot;]&quot;; }
}
class <strong>C3 extends C2</strong> {
   public C3(String value) { super(value); }
   public void methodC3() { System.out.println(this + &quot; runs methodC3()&quot;); }
   @Override public String toString() { return &quot;C3[&quot; + value + &quot;]&quot;; }
}

public class <strong>GenericUpperLowerWildcardTest</strong> {
   <span class="color-comment">// For a specific T only</span>
   public static &lt;T&gt; T processAll1(<span class="color-new">Collection&lt;T&gt;</span> coll, <span class="color-new">MyConsumer&lt;T&gt;</span> consumer) {
      T last = null;
      for (T t : coll) {
         last = t;
         consumer.accept(t);
      }
      return last;
   }

   <span class="color-comment">// Lower bounded wildcard</span>
   public static &lt;T&gt; T processAll2(<span class="color-new">Collection&lt;T&gt;</span> coll, <span class="color-new">MyConsumer&lt;? super T&gt;</span> consumer) {
      T last = null;
      for (T t : coll) {
         last = t;
         consumer.accept(t); <span class="color-comment">// t supports all its supertype's operations</span>
      }
      return last;
   }

   <span class="color-comment">// Lower bounded and upper bounded wildcards</span>
   public static &lt;T&gt; T processAll3(<span class="color-new">Collection&lt;? extends T&gt;</span> coll, <span class="color-new">MyConsumer&lt;? super T&gt;</span> consumer) {
      T last = null;
      for (T t : coll) {     <span class="color-comment">// T's subtype elements can be upcast to T</span>
         last = t;
         consumer.accept(t); <span class="color-comment">// t supports all its supertype's operations</span>
      }
      return last;
   }

   public static void main(String[] args) {
      <span class="color-comment">// Set T to C2</span>
      <span class="color-comment">// Try processAll1(Collection&lt;C2&gt;, MyConsumer&lt;C2&gt;)</span>
      Collection&lt;C2&gt; fruits = List.of(new C2(&quot;apple&quot;), new C2(&quot;orange&quot;));
      MyConsumer&lt;C2&gt; consumer1 = C2::methodC2;  <span class="color-comment">// Can use C2's methods</span>
      C2 result1 = processAll1(fruits, consumer1);
      <span class="color-comment">//C2[apple] runs methodC2()</span>
      <span class="color-comment">//C2[orange] runs methodC2()</span>
      System.out.println(result1);
      <span class="color-comment">//C2[orange]</span>

      <span class="color-comment">// Try processAll2(Collection&lt;C2&gt;, MyConsumer&lt;C1 super C2&gt;)</span>
      MyConsumer&lt;C1&gt; consumer2 = C1::methodC1;
         <span class="color-comment">// Can use only C1's methods. But subtype C2 supports all C1's methods</span>
      <span class="color-comment">//processAll1(fruits, consumer2);  // wrong type for consumer2 in processAll1()</span>
      <span class="color-comment">//error: method processAll1 in class GenericWildcardTest cannot be applied to given types</span>
      C2 result2 = processAll2(fruits, consumer2);
      <span class="color-comment">//C2[apple] runs methodC1()</span>
      <span class="color-comment">//C2[orange] runs methodC1()</span>
      System.out.println(result2);
      <span class="color-comment">//C2[orange]</span>

      <span class="color-comment">// Try processAll3(Collection&lt;C3 extends C2&gt;, MyConsumer&lt;C1 super C2&gt;)</span>
      Collection&lt;C3&gt; coffees = List.of(new C3(&quot;espresso&quot;), new C3(&quot;latte&quot;));
      C2 result3 = processAll3(coffees, consumer2);
      <span class="color-comment">//C3[espresso] runs methodC1()</span>
      <span class="color-comment">//C3[latte] runs methodC1()</span>
      System.out.println(result3);
      <span class="color-comment">//C3[latte]</span>
      processAll3(coffees, consumer2).methodC3();
      <span class="color-comment">//C3[espresso] runs methodC1()</span>
      <span class="color-comment">//C3[latte] runs methodC1()</span>
      <span class="color-comment">//C3[latte] runs methodC3()</span>

      <span class="color-comment">// Try subclass List of Collection</span>
      List&lt;C3&gt; animals = List.of(new C3(&quot;tiger&quot;), new C3(&quot;lion&quot;));
      C2 result4 = processAll3(animals, consumer2);
      <span class="color-comment">//C3[tiger] runs methodC1()</span>
      <span class="color-comment">//C3[lion] runs methodC1()</span>
      System.out.println(result4);
      <span class="color-comment">//C3[lion]</span>
   }
}</pre>

<p>In summary:</p>
<ol>
<li><code>List&lt;String&gt;</code> is NOT a subtype of <code>List&lt;Object&gt;</code>, but <code>ArrayList&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code> and can be upcasted.</li>
<li>Upper Bounded Wildcard <code>&lt;? extends T&gt;</code> for collection: To be able to process <code>Collection</code> of <code>T</code> and <code>T</code>'s subtypes, use <code>Collection&lt;? extends T&gt;</code>. For example, <code>printList&lt;? extends Number&gt;</code> works on <code>printList&lt;Number&gt;</code>, <code>printList&lt;Integer&gt;</code>, <code>printList&lt;Double&gt;</code>, etc.</li>
<li>Lower Bounded Wildcard <code>&lt;? super T&gt;</code> for operation: The type <code>T</code> inherits and supports all its supertypes' operations. A operation that is operating on <code>T</code>'s supertype also works on <code>T</code>, because <code>T</code> support all its supertype's operation. For maximum flexibility in operation on <code>T</code>, we could use <code>&lt;? super T&gt;</code> to operation on <code>T</code>'s supertypes.</li>
</ol>



<h4>Bounded Type Parameters</h4>
<h5>Upper Bounded Type Parameters <span class="font-code">&lt;T extends TypeName&gt;</span></h5>

<p>A bounded parameter type is a generic type that specifies a bound for the generic, in the form of <code>&lt;T extends TypeName&gt;</code>, e.g., <code>&lt;T extends Number&gt;</code> accepts <code>Number</code> and its subclasses (such as <code>Integer</code> and <code>Double</code>).</p>

<p>For example, the <code>static</code> method <code>add()</code> takes a type parameter <code>&lt;T extends Number&gt;</code>, which accepts <code>Number</code> and its subclasses (such as <code>Integer</code> and <code>Double</code>).</p>

<pre class="color-example">
public class <strong>UpperBoundedTypeParamAddTest</strong> {
   public static <span class="color-new">&lt;T extends Number&gt; double add(T first, T second)</span> {
      <span class="color-comment">// Need to use only methods defined in Number, such as doubleValue
      // Subtypes Integer and Double inherit and support these methods too.</span>
      return first.doubleValue() + second.doubleValue();
   }

   public static void main(String[] args) {
      System.out.println(add(55, 66));     <span class="color-comment">// int -&gt; Integer. T is Integer.</span>
      System.out.println(add(5.5f, 6.6f)); <span class="color-comment">// float -&gt; Float. T is Float.</span>
      System.out.println(add(5.5, 6.6));   <span class="color-comment">// double -&gt; Double. T is Double.</span>
      System.out.println(add(55, 6.6));    <span class="color-comment">// int -&gt; double -&gt; Double. T is Double.</span>

      <span class="color-comment">//System.out.println(<span class="color-error">add(&quot;apple&quot;, &quot;orange&quot;)</span>);</span>
      <span class="color-comment">//</span><span class="color-error">compilation error: method add in class UpperBoundedTypeParameterTest</span>
      <span class="color-comment">//  <span class="color-error">cannot be applied to given types;</span></span>
   }
}</pre>

<h5>How the compiler treats the bounded generics?</h5>

<p>As mentioned, by default, all the generic types are replaced with type <code>Object</code> during the code translation.  However, in the case of <code>&lt;T extends Number&gt;</code>, the generic type is replaced by the type <code>Number</code>, which serves as the <em>upper bound</em> of the generic types.</p>

<p>For example,</p>

<pre class="color-example">
public class <strong>UpperBoundedTypeParamMaximumTest</strong> {
   public static <span class="color-new">&lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y)</span> {
      <span class="color-comment">// Need to restrict T to Comparable and its subtype for .compareTo()</span>
      return (x.compareTo(y) &gt; 0) ? x : y;
   }

   public static void main(String[] args) {
      System.out.println(maximum(55, 66));    <span class="color-comment">// 66</span>
      System.out.println(maximum(6.6, 5.5));  <span class="color-comment">// 6.6</span>
      System.out.println(maximum(&quot;Monday&quot;, &quot;Tuesday&quot;));  <span class="color-comment">// Tuesday</span>
   }
}</pre>

<p>By default, <code>Object</code> is the <em>upper-bound</em> of the parameterized type.  <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> changes the upper bound to the <code>Comparable</code> interface, which declares an <code>abstract</code> method <code>compareTo()</code> for comparing two objects.</p>

<p>The compiler translates the above generic method to the following codes:</p>
<pre class="color-example">
public static<strong> Comparable</strong> maximum(<strong>Comparable</strong> x, <strong>Comparable</strong> y) {   <span class="color-comment">// replace T by upper bound type Comparable</span>
                                                                 <span class="color-comment">// Compiler checks x, y are of the type Comparable</span>
                                                                 <span class="color-comment">// Compiler inserts a type-cast for the return value</span>
   return (x.compareTo(y) &gt; 0) ? x : y;
}</pre>

<p>When this method is invoked, e.g. via <code>maximum(55, 66)</code>,  the primitive <code>int</code>s are auto-boxed to <code>Integer</code> objects, which are then implicitly upcasted to <code>Comparable</code>.  The compiler checks the type to ensure type-safety.  The compiler also inserts an explicit downcast operator for the return type.  That is,</p>
<pre class="color-example">
(Comparable)maximum(55, 66);
(Comparable)maximum(6.6, 5.5);
(Comparable)maximum(&quot;Monday&quot;, &quot;Tuesday&quot;);</pre>

<p>We do not have to pass an actual type argument to a generic method.  The compiler infers the type argument automatically, based of the type of the actual argument passed into the method.</p>

<h5>Bounded Type Parameter for Generic Class</h5>
<p>The bounded type parameter <code>&lt;T extends ClassName&gt;</code> can also be applied to generic class, e.g.,</p>

<pre class="color-example">
public class MagicNumber<span class="color-new">&lt;T extends Number&gt;</span> {
   private <span class="color-new">T value</span>;
   public MagicNumber(<span class="color-new">T value</span>) { this.value = value; }
   public boolean isMagic() { return value.intValue() == 9; }
   public String toString() { return &quot;MagicNumber[value=&quot; + value +&quot;]&quot;; }

   public static void main(String[] args) {
      <span class="color-new">MagicNumber&lt;Double&gt;</span> n1 = new MagicNumber&lt;&gt;(9.9);
      System.out.println(n1);           <span class="color-comment">//<span class="color-output">MagicNumber[value=9.9]</span></span>
      System.out.println(n1.isMagic()); <span class="color-comment">//<span class="color-output">true</span></span>

      <span class="color-new">MagicNumber&lt;Float&gt;</span> n2 = new MagicNumber&lt;&gt;(1.23f);
      System.out.println(n2);           <span class="color-comment">//<span class="color-output">MagicNumber[value=1.23]</span></span>
      System.out.println(n2.isMagic()); <span class="color-comment">//<span class="color-output">false</span></span>

      <span class="color-new">MagicNumber&lt;Number&gt;</span> n3 = new MagicNumber&lt;&gt;(1);
      System.out.println(n3);           <span class="color-comment">//<span class="color-output">MagicNumber[value=1]</span></span>
      System.out.println(n3.isMagic()); <span class="color-comment">//<span class="color-output">false</span></span>

      <span class="color-comment">//<span class="color-new">MagicNumber&lt;String&gt;</span> n4 = new MagicNumber&lt;&gt;(&quot;hello&quot;);</span>
      <span class="color-comment">//</span><span class="color-error">error: type argument String is not within bounds of type-variable T</span>
   }
}</pre>


<h5>Lower Bounded Type Parameters <span class="font-code">&lt;T super Class&gt;</span></h5>
<p>Not useful and hence, not supported.</p>
<p>&nbsp;</p>


<a class="references" href="../howto/References.html#java">LINK TO JAVA REFERENCES &amp; RESOURCES</a>


</div> 
<!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 13.0.1<br />
Last modified: January, 2020</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
</body>
</html>
