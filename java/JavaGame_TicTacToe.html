<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tic-tac-toe - Java Game Programming Case Study</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css" rel="stylesheet" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.css" rel="stylesheet" />

<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="JavaGame_TicTacToe.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Graphics Programming</h1>
<h2>Tic-Tac-Toe</h2>
</div>

<div id="content-main">

<p>A game can be programmed as a finite state machine, with clearly defined states and state transition functions, as follows:</p>
<img class="image-center" src="images/Game_StateDiagramV2.png" alt="State Diagram" />

<p>For this Tic-tac-toe, I shall try to closely follow this state diagram.</p>

<h3>Let's Start with a 2-Player Console Non-OO Tic-Tac-Toe</h3>
<p>Let us start with a 2-player console (non-graphics) version of Tic-Tac-Toe, where player <code>'X'</code> and player <code>'O'</code> enter their moves successively, as shown below:</p>

<pre class="output">
Player 'X', enter your move (row[1-3] column[1-3]): <strong>2 2</strong>
   |   |   
-----------
   | X |   
-----------
   |   |   

Player 'O', enter your move (row[1-3] column[1-3]): <strong>1 1</strong>
 O |   |   
-----------
   | X |   
-----------
   |   |   

Player 'X', enter your move (row[1-3] column[1-3]): <strong>1 3</strong>
 O |   | X 
-----------
   | X |   
-----------
   |   |   

Player 'O', enter your move (row[1-3] column[1-3]): <strong>3 1</strong>
 O |   | X 
-----------
   | X |   
-----------
 O |   |   

Player 'X', enter your move (row[1-3] column[1-3]): <strong>2 2</strong>
<span class="color-new">This move at (2,2) is not valid. Try again...</span>
Player 'X', enter your move (row[1-3] column[1-3]): <strong>2 3</strong>
 O |   | X 
-----------
   | X | X 
-----------
 O |   |   

Player 'O', enter your move (row[1-3] column[1-3]): <strong>2 1</strong>
 O |   | X 
-----------
 O | X | X 
-----------
 O |   |   

<strong>Player 'O' won!</strong>
</pre>

<h5 class="font-code">TTTConsoleNonOO.java</h5>
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * Tic-Tac-Toe: Two-player, console-based, non-graphics, non-OO version.
 * All variables/methods are declared as static (i.e., class)
 *  in this non-OO version.
 */
public class TTTConsoleNonOO {
   // Define named constants for:
   //  1. Player: using CROSS and NOUGHT
   //  2. Cell contents: using CROSS, NOUGHT and NO_SEED
   public static final int CROSS   = 0;
   public static final int NOUGHT  = 1;
   public static final int NO_SEED = 2;

   // The game board
   public static final int ROWS = 3, COLS = 3;  // number of rows/columns
   public static int[][] board = new int[ROWS][COLS]; // EMPTY, CROSS, NOUGHT

   // The current player
   public static int currentPlayer;  // CROSS, NOUGHT

   // Define named constants to represent the various states of the game
   public static final int PLAYING    = 0;
   public static final int DRAW       = 1;
   public static final int CROSS_WON  = 2;
   public static final int NOUGHT_WON = 3;
   // The current state of the game
   public static int currentState;

   public static Scanner in = new Scanner(System.in); // the input Scanner

   /** The entry main method (the program starts here) */
   public static void main(String[] args) {
      // Initialize the board, currentState and currentPlayer
      initGame();

      // Play the game once
      do {
         // currentPlayer makes a move
         // Update board[selectedRow][selectedCol] and currentState
         stepGame();
         // Refresh the display
         paintBoard();
         // Print message if game over
         if (currentState == CROSS_WON) {
            System.out.println("'X' won!\nBye!");
         } else if (currentState == NOUGHT_WON) {
            System.out.println("'O' won!\nBye!");
         } else if (currentState == DRAW) {
            System.out.println("It's a Draw!\nBye!");
         }
         // Switch currentPlayer
         currentPlayer = (currentPlayer == CROSS) ? NOUGHT : CROSS;
      } while (currentState == PLAYING); // repeat if not game over
   }

   /** Initialize the board[][], currentState and currentPlayer for a new game*/
   public static void initGame() {
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            board[row][col] = NO_SEED;  // all cells empty
         }
      }
      currentPlayer = CROSS;   // cross plays first
      currentState  = PLAYING; // ready to play
   }

   /** The currentPlayer makes one move (one step).
       Update board[selectedRow][selectedCol] and currentState. */
   public static void stepGame() {
      boolean validInput = false;  // for input validation
      do {
         if (currentPlayer == CROSS) {
            System.out.print("Player 'X', enter your move (row[1-3] column[1-3]): ");
         } else {
            System.out.print("Player 'O', enter your move (row[1-3] column[1-3]): ");
         }
         int row = in.nextInt() - 1;  // array index starts at 0 instead of 1
         int col = in.nextInt() - 1;
         if (row &gt;= 0 &amp;&amp; row &lt; ROWS &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; COLS
                      &amp;&amp; board[row][col] == NO_SEED) {
            // Update board[][] and return the new game state after the move
            currentState = stepGameUpdate(currentPlayer, row, col);
            validInput = true;  // input okay, exit loop
         } else {
            System.out.println("This move at (" + (row + 1) + "," + (col + 1)
                  + ") is not valid. Try again...");
         }
      } while (!validInput);  // repeat if input is invalid
   }

   /**
    * Helper function of stepGame().
    * The given player makes a move at (selectedRow, selectedCol).
    * Update board[selectedRow][selectedCol]. Compute and return the
    * new game state (PLAYING, DRAW, CROSS_WON, NOUGHT_WON).
    * @return new game state
    */
   public static int stepGameUpdate(int player, int selectedRow, int selectedCol) {
      // Update game board
      board[selectedRow][selectedCol] = player;

      // Compute and return the new game state
      if (board[selectedRow][0] == player       // 3-in-the-row
                &amp;&amp; board[selectedRow][1] == player
                &amp;&amp; board[selectedRow][2] == player
             || board[0][selectedCol] == player // 3-in-the-column
                &amp;&amp; board[1][selectedCol] == player
                &amp;&amp; board[2][selectedCol] == player
             || selectedRow == selectedCol      // 3-in-the-diagonal
                &amp;&amp; board[0][0] == player
                &amp;&amp; board[1][1] == player
                &amp;&amp; board[2][2] == player
             || selectedRow + selectedCol == 2  // 3-in-the-opposite-diagonal
                &amp;&amp; board[0][2] == player
                &amp;&amp; board[1][1] == player
                &amp;&amp; board[2][0] == player) {
         return (player == CROSS) ? CROSS_WON : NOUGHT_WON;
      } else {
         // Nobody win. Check for DRAW (all cells occupied) or PLAYING.
         for (int row = 0; row &lt; ROWS; ++row) {
            for (int col = 0; col &lt; COLS; ++col) {
               if (board[row][col] == NO_SEED) {
                  return PLAYING; // still have empty cells
               }
            }
         }
         return DRAW; // no empty cell, it's a draw
      }
   }

   /** Print the game board */
   public static void paintBoard() {
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            paintCell(board[row][col]); // print each of the cells
            if (col != COLS - 1) {
               System.out.print("|");   // print vertical partition
            }
         }
         System.out.println();
         if (row != ROWS - 1) {
            System.out.println("-----------"); // print horizontal partition
         }
      }
      System.out.println();
   }

   /** Print a cell having the given content */
   public static void paintCell(int content) {
      switch (content) {
         case CROSS:   System.out.print(" X "); break;
         case NOUGHT:  System.out.print(" O "); break;
         case NO_SEED: System.out.print("   "); break;
      }
   }
}</code></pre>
	
<h5>How it works?</h5>

<p>Non-OO programs (like C programs) are organized in methods (or functions), which access common global variables. In non-OO Java, all the variables/methods shall be declared <code>static</code> (i.e., they belong to the class instead of instances). The program starts at the <code>main()</code> method. No instances are created.</p>

<p>A board game (such as Tic-tac-toe) is typically programmed as a <em>state machine</em>. Depending on the current-state and the player's move, the game transits into the next-state. In this example, I use a variable <code>currentState</code> to keep track of the <em>current-state</em> of the game, and define named constants to denote the various  states of the game (<code>PLAYING</code>,  <code>DRAW</code>, <code>CROSS_WON</code>, and <code>NOUGHT_WON</code>).  A method called <code>stepGame()</code> is defined, which will be called to transit into next state.</p>
<p>Two methods are defined for printing the game board, <code>paintBoard()</code> and <code>paintCell()</code>. The <code>paintBoard()</code> shall call <code>paintCell()</code> to  print each of the 9 cells.  This seems  trivial here, but will be useful in the object-oriented design to separate the  board and cells into separate classes.</p>

<p>[TODO] more explanation</p>

<p><span class="line-heading">TRY:</span> Prompt the user whether to play again after gameover.</p>

<pre><code class="language-java">// in main()
do {
   // Play the game once
   initGame();
   ......
   ......
   // Prompt the user whether to play again
   System.out.print("Play again (y/n)? ");
   char ans = in.next().charAt(0);
   if (ans != 'y' &amp;&amp; ans != 'Y') {
      System.out.println("Bye!");
      System.exit(0);  // terminate the program
   }
} while (true);  // repeat until user did not answer yes</code></pre>
	

<h3>A Console OO Tic-Tac-Toe</h3>

<p>Let us convert the earlier non-OO version of Tic-Tac-Toe to object-oriented. The OO version of this simple Tic-Tac-Toe is more complex than the non-OO version, because Tic-Tac-Toe is a rather simple application. But OO design is a necessity to build a complex application.</p>

<h5>Enumeration <span class="font-code">State</span></h5>

<p>In our earlier version, we used <code>int</code> named-constants to represent the various game states, as follows:</p>

<pre><code class="language-java">// Define named constants to represent the various states of the game
public static final int PLAYING    = 0;
public static final int DRAW       = 1;
public static final int CROSS_WON  = 2;
public static final int NOUGHT_WON = 3;
 
// The current state of the game
public static int currentState = PLAYING;  // Assigned to a named constant, which is easier to read
                                           // and understand, instead of an int number 0</code></pre>
	
<p>This approach of using <code>int</code> named-constants is better than hardcoding the numbers in the programming statements, but it is not ideal. This is because you may inadvertently assign an <code>int</code> value <em>outside the valid range</em> to the variable <code>currentState</code>. For example,</p>

<pre><code class="language-java">currentState = 99;   // A logical error but can compile</code></pre>

<p>JDK 5 introduces a new feature called <em>enumeration</em>, which is a <em>special class</em> for storing <em>an enumeration (list) of fixed items</em>. In our case, we can define an enumeration called <code>State</code> as follows:</p>

<pre><code class="language-java line-numbers">/**
 *  The enum State defines the various game states of the TTT game
 */
public enum State {  // to save as "State.java"
   PLAYING, DRAW, CROSS_WON, NOUGHT_WON
}</code></pre>

To reference an <em>item</em> in an <code>enum</code>, use <code><em>enumName</em>.<em>itemName</em></code> (e.g., <code>State.PLAYING</code> and  <code>State.DRAW</code>), just like referencing <code>static</code> variables of a class (e.g., <code>Math.PI</code>).

<p>You can create an instance for an <code>enum</code> (just like creating an instance of a <code>class</code>) and assign a value into it.  We shall now declare the variable <code>currentState</code> as an instance of <code>State</code>, which can take the value of <code>State.PLAYING</code>, <code>State.DRAW</code>, <code>State.CROSS_WON</code>, and <code>State.NOUGHT_WON</code>.</p>
<pre><code class="language-java">State currentState;            // declare variable currentState as an instance of enum Game
currentState = State.PLAYING;  // assign a value (an enum item) to the variable currentState</code></pre>

<p>Take note that you can only assign a value defined in the enumeration (such as <code>State.PLAYING</code>, <code>State.DRAW</code>), and NOT an arbitrary <code>int</code> value in the earlier example. In other words, enum is SAFE!</p>

<h5>Enumerations <span class="font-code">Seed</span></h5>

<p>We shall also create an <code>enum</code> called <code>Seed</code> as follows.</p>

<pre><code class="language-java line-numbers">/**
 * This enum is used by:
 * 1. Player: takes value of CROSS or NOUGHT
 * 2. Cell content: takes value of CROSS, NOUGHT, or NO_SEED.
 *
 * We also attach a display icon (text or image) for each of the item,
 *   and define the related variable/constructor/getter.
 *
 * Ideally, we should define two enums with inheritance, which is,
 *  however, not supported.
 */
public enum Seed {   // to save as "Seed.java"
   CROSS("X"), NOUGHT("O"), NO_SEED(" ");

   // Private variable
   private String icon;
   // Constructor (must be private)
   private Seed(String icon) {
      this.icon = icon;
   }
   // Public Getter
   public String getIcon() {
      return icon;
   }
}</code></pre>

<p>This enum is used in two properties:</p>
	
<ol>
<li>Player: uses values <code>CROSS</code> and <code>NOUGHT</code>.</li>
<li>Cell Content: uses values <code>CROSS</code>, <code>NOUGHT</code>, and <code>NO_SEED</code>.</li>
</ol>
<p>(Ideally, we should create 2 enums with inheritance, but enum inheritance is not supported in Java.)</p>

<p>Again, you need to use <code>Seed.NO_SEED</code>, <code>Seed.CROSS</code>, <code>Seed.NOUGHT</code> to refer to these values, just like any <code>public</code> <code>static</code> <code>final</code> constants.</p>

<p>We also attach an icon to each of the enum items, by defining a private variable, a private constructor and a public getter (as in a regular class). We can get the icon via <code>enumItem.getIcon()</code>.</p>

	
<p>We shall declare the variables <code>currentPlayer</code> and <code>content</code> as instances of enum <code>Player</code> and <code>CellContent</code>.</p>
<pre><code class="language-java">private Seed currentPlayer;  // declare variable currentPlayer as an instance of enum Seed
currentPlayer = Seed.CROSS;  // assign a value (an enum item) to the variable currentPlayer
 
private Seed content;        // cell's content
content = Seed.NO_SEED;</code></pre>

<p>In brief, an <code>enum</code> is just <em>a special class with a list of named-constants</em>. But enum is safe with additional features!</p>

<h5>Classes <span class="font-code">Board</span> and <span class="font-code">Cell</span></h5>

<img class="image-center" src="images/GameTTT_Board_Cell.png" alt="GameTTT_Board_Cell.png" />

<p>Next, let's design the OO classes needed for our Tic-Tac-Toe game.  Each class shall maintain its own attributes and operations (variables and methods), and <em>it can paint itself</em> in a graphics program.</p>
<p>We begin with two classes, a class <code>Cell</code> for each individual cell of the game board, and a class <code>Board</code> for the 3x3 game board.</p>

<p>The <code>Cell</code> class has an instance variable called <code>content</code> (with package access), of the type <code>enum</code> <code>Seed</code>. You can only assign a value from the <code>enum</code>'s constants, such as <code>Seed.NO_SEED</code>, <code>Seed.CROSS</code>, and <code>Seed.NOUGHT</code>, into <code>content</code>. A <code>Cell</code> can <code>paint()</code> itself. You can use <code>newGame()</code> to reset all its properties, ready for a new game.</p>

<p>The <code>Board</code> class composes of nine <code>Cell</code> instances, arranged in an 3&times;3 array called <code>cells</code> (with package access), of the type <code>Cell[][]</code>.  A <code>Board</code> can <code>paint()</code> itself, and supports the state transition functions such as <code>initGame()</code>, <code>newGame()</code> and <code>stepGame()</code> (see game state diagram).</p>

<h5 class="font-code">Cell.java</h5>

<pre><code class="language-java line-numbers">/**
 * The Cell class models each individual cell of the TTT 3x3 grid.
 */
public class Cell {  // save as "Cell.java"
   // Define properties (package-visible)
   /** Content of this cell (CROSS, NOUGHT, NO_SEED) */
   Seed content;
   /** Row and column of this cell, not used in this program */
   int row, col;

   /** Constructor to initialize this cell */
   public Cell(int row, int col) {
      this.row = row;
      this.col = col;
      this.content = Seed.NO_SEED;
   }

   /** Reset the cell content to EMPTY, ready for a new game. */
   public void newGame() {
      this.content = Seed.NO_SEED;
   }

   /** The cell paints itself */
   public void paint() {
      // Retrieve the display icon (text) and print
      String icon = this.content.getIcon();
      System.out.print(icon);
   }
}</code></pre>

<h5 class="font-code">Board.java</h5>

<pre><code class="language-java line-numbers">/**
 * The Board class models the TTT game-board of 3x3 cells.
 */
public class Board {  // save as "Board.java"
   // Define named constants for the grid
   public static final int ROWS = 3;
   public static final int COLS = 3;

   // Define properties (package-visible)
   /** A board composes of [ROWS]x[COLS] Cell instances */
   Cell[][] cells;

   /** Constructor to initialize the game board */
   public Board() {
      initGame();
   }

   /** Initialize the board (run once) */
   public void initGame() {
      cells = new Cell[ROWS][COLS];  // allocate the array
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            // Allocate element of the array
            cells[row][col] = new Cell(row, col);
         }
      }
   }

   /** Reset the contents of the game board, ready for new game. */
   public void newGame() {
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            cells[row][col].newGame();  // The cells init itself
         }
      }
   }

   /**
    *  The given player makes a move on (selectedRow, selectedCol).
    *  Update cells[selectedRow][selectedCol]. Compute and return the
    *  new game state (PLAYING, DRAW, CROSS_WON, NOUGHT_WON).
    */
   public State stepGame(Seed player, int selectedRow, int selectedCol) {
      // Update game board
      cells[selectedRow][selectedCol].content = player;

      // Compute and return the new game state
      if (cells[selectedRow][0].content == player  // 3-in-the-row
                &amp;&amp; cells[selectedRow][1].content == player
                &amp;&amp; cells[selectedRow][2].content == player
             || cells[0][selectedCol].content == player // 3-in-the-column
                &amp;&amp; cells[1][selectedCol].content == player
                &amp;&amp; cells[2][selectedCol].content == player
             || selectedRow == selectedCol         // 3-in-the-diagonal
                &amp;&amp; cells[0][0].content == player
                &amp;&amp; cells[1][1].content == player
                &amp;&amp; cells[2][2].content == player
             || selectedRow + selectedCol == 2     // 3-in-the-opposite-diagonal
                &amp;&amp; cells[0][2].content == player
                &amp;&amp; cells[1][1].content == player
                &amp;&amp; cells[2][0].content == player) {
         return (player == Seed.CROSS) ? State.CROSS_WON : State.NOUGHT_WON;
      } else {
         // Nobody win. Check for DRAW (all cells occupied) or PLAYING.
         for (int row = 0; row &lt; ROWS; ++row) {
            for (int col = 0; col &lt; COLS; ++col) {
               if (cells[row][col].content == Seed.NO_SEED) {
                  return State.PLAYING; // still have empty cells
               }
            }
         }
         return State.DRAW; // no empty cell, it's a draw
      }
   }

   /** The board paints itself */
   public void paint() {
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            System.out.print(" ");
            cells[row][col].paint();   // each cell paints itself
            System.out.print(" ");
            if (col &lt; COLS - 1) System.out.print("|");  // column separator
         }
         System.out.println();
         if (row &lt; ROWS - 1) {
            System.out.println("-----------");  // row separator
         }
      }
      System.out.println();
   }
}</code></pre>

<h5>Class <span class="font-code">GameMain</span><img class="image-center" src="images/GameTTT_GameMain.png" alt="GameTTT_GameMain.png" /></h5>
<p>Finally, let's write a main class called <code>GameMain</code> to pull all the pieces together.  <code>GameMain</code> acts as the overall <em>controller</em> for the game.</p>

<h5 class="font-code">GameMain.java</h5>
<pre><code class="language-java line-numbers">import java.util.Scanner;
/**
 * The main class for the Tic-Tac-Toe (Console-OO, non-graphics version)
 * It acts as the overall controller of the game.
 */
public class GameMain {
   // Define properties
   /** The game board */
   private Board board;
   /** The current state of the game (of enum State) */
   private State currentState;
   /** The current player (of enum Seed) */
   private Seed  currentPlayer;

   private static Scanner in = new Scanner(System.in);

   /** Constructor to setup the game */
   public GameMain() {
      // Perform one-time initialization tasks
      initGame();

      // Reset the board, currentStatus and currentPlayer
      newGame();

      // Play the game once
      do {
         // The currentPlayer makes a move.
         // Update cells[][] and currentState
         stepGame();
         // Refresh the display
         board.paint();
         // Print message if game over
         if (currentState == State.CROSS_WON) {
            System.out.println("'X' won!\nBye!");
         } else if (currentState == State.NOUGHT_WON) {
            System.out.println("'O' won!\nBye!");
         } else if (currentState == State.DRAW) {
            System.out.println("It's Draw!\nBye!");
         }
         // Switch currentPlayer
         currentPlayer = (currentPlayer == Seed.CROSS) ? Seed.NOUGHT : Seed.CROSS;
      } while (currentState == State.PLAYING);  // repeat until game over
   }

   /** Perform one-time initialization tasks */
   public void initGame() {
      board = new Board();  // allocate game-board
   }

   /** Reset the game-board contents and the current states, ready for new game */
   public void newGame() {
      board.newGame();  // clear the board contents
      currentPlayer = Seed.CROSS;   // CROSS plays first
      currentState = State.PLAYING; // ready to play
   }

   /** The currentPlayer makes one move.
       Update cells[][] and currentState. */
   public void stepGame() {
      boolean validInput = false;  // for validating input
      do {
         String icon = currentPlayer.getIcon();
         System.out.print("Player '" + icon + "', enter your move (row[1-3] column[1-3]): ");
         int row = in.nextInt() - 1;   // [0-2]
         int col = in.nextInt() - 1;
         if (row &gt;= 0 &amp;&amp; row &lt; Board.ROWS &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; Board.COLS
               &amp;&amp; board.cells[row][col].content == Seed.NO_SEED) {
            // Update cells[][] and return the new game state after the move
            currentState = board.stepGame(currentPlayer, row, col);
            validInput = true; // input okay, exit loop
         } else {
            System.out.println("This move at (" + (row + 1) + "," + (col + 1)
                  + ") is not valid. Try again...");
         }
      } while (!validInput);   // repeat until input is valid
   }

   /** The entry main() method */
   public static void main(String[] args) {
      new GameMain();  // Let the constructor do the job
   }
}</code></pre>
	
<h5>OO vs non-OO</h5>

<p>The OO-version and the non-OO version have the same codes, but are organized differently. The organization in OO enables you to design and develop complex system.</p>

<h3 id="TTTGraphics">A Graphical Tic-Tac-Toe with Simple-OO</h3>

<img class="image-float-right" src="images/GameTTT_Graphics.png" alt="GameTTT_Graphics.png" />

<p>Let's rewrite the &quot;console&quot; version into a &quot;graphics&quot; version - a Java Swing application, as illustrated. In this initial design, we do not separate the cell and board into dedicated classes, but include them in the main class. We used an inner class <code>GamePanel</code> (that extends <code>JPanel</code>) to do the custom drawing, and an anonymous inner class for <code>MouseListener</code>.</p>
<p>The content-pane (of the top-level container <code>JFrame</code>) is set to <code>BorderLayout</code>. The <code>DrawCanvas</code> (<code>JPanel</code>) is placed at the <code>CENTER</code>; while a status-bar (a <code>JLabel</code>) is placed at the <code>SOUTH</code> (<code>PAGE_END</code>).</p>

<p class="float-clear">The class diagram is as follows:</p>

<img class="image-center" src="images/GameTTT_GraphicsClassDiagram.png" alt="GameTTT_GraphicsClassDiagram.png" />

<h5 class="font-code">TTTGraphics.java</h5>

<pre><code class="language-java line-numbers">import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/**
 * Tic-Tac-Toe: Two-player Graphics version with Simple-OO in one class
 */
public class TTTGraphics extends JFrame {
   private static final long serialVersionUID = 1L; // to prevent serializable warning

   // Define named constants for the game board
   public static final int ROWS = 3;  // ROWS x COLS cells
   public static final int COLS = 3;

   // Define named constants for the drawing graphics
   public static final int CELL_SIZE = 120; // cell width/height (square)
   public static final int BOARD_WIDTH  = CELL_SIZE * COLS; // the drawing canvas
   public static final int BOARD_HEIGHT = CELL_SIZE * ROWS;
   public static final int GRID_WIDTH = 10;                  // Grid-line's width
   public static final int GRID_WIDTH_HALF = GRID_WIDTH / 2;
   // Symbols (cross/nought) are displayed inside a cell, with padding from border
   public static final int CELL_PADDING = CELL_SIZE / 5;
   public static final int SYMBOL_SIZE = CELL_SIZE - CELL_PADDING * 2; // width/height
   public static final int SYMBOL_STROKE_WIDTH = 8; // pen's stroke width
   public static final Color COLOR_BG = Color.WHITE;  // background
   public static final Color COLOR_BG_STATUS = new Color(216, 216, 216);
   public static final Color COLOR_GRID   = Color.LIGHT_GRAY;  // grid lines
   public static final Color COLOR_CROSS  = new Color(211, 45, 65);  // Red #D32D41
   public static final Color COLOR_NOUGHT = new Color(76, 181, 245); // Blue #4CB5F5
   public static final Font FONT_STATUS = new Font("OCR A Extended", Font.PLAIN, 14);

   // This enum (inner class) contains the various states of the game
   public enum State {
      PLAYING, DRAW, CROSS_WON, NOUGHT_WON
   }
   private State currentState;  // the current game state

   // This enum (inner class) is used for:
   // 1. Player: CROSS, NOUGHT
   // 2. Cell's content: CROSS, NOUGHT and NO_SEED
   public enum Seed {
      CROSS, NOUGHT, NO_SEED
   }
   private Seed currentPlayer; // the current player
   private Seed[][] board;     // Game board of ROWS-by-COLS cells

   // UI Components
   private GamePanel gamePanel; // Drawing canvas (JPanel) for the game board
   private JLabel statusBar;  // Status Bar

   /** Constructor to setup the game and the GUI components */
   public TTTGraphics() {
      // Initialize the game objects
      initGame();

      // Set up GUI components
      gamePanel = new GamePanel();  // Construct a drawing canvas (a JPanel)
      gamePanel.setPreferredSize(new Dimension(BOARD_WIDTH, BOARD_HEIGHT));

      // The canvas (JPanel) fires a MouseEvent upon mouse-click
      gamePanel.addMouseListener(new MouseAdapter() {
         @Override
         public void mouseClicked(MouseEvent e) {  // mouse-clicked handler
            int mouseX = e.getX();
            int mouseY = e.getY();
            // Get the row and column clicked
            int row = mouseY / CELL_SIZE;
            int col = mouseX / CELL_SIZE;

            if (currentState == State.PLAYING) {
               if (row &gt;= 0 &amp;&amp; row &lt; ROWS &amp;&amp; col &gt;= 0
                     &amp;&amp; col &lt; COLS &amp;&amp; board[row][col] == Seed.NO_SEED) {
                  // Update board[][] and return the new game state after the move
                  currentState = stepGame(currentPlayer, row, col);
                  // Switch player
                  currentPlayer = (currentPlayer == Seed.CROSS) ? Seed.NOUGHT : Seed.CROSS;
               }
            } else {       // game over
               newGame(); // restart the game
            }
            // Refresh the drawing canvas
            repaint();  // Callback paintComponent().
         }
      });

      // Setup the status bar (JLabel) to display status message
      statusBar = new JLabel("       ");
      statusBar.setFont(FONT_STATUS);
      statusBar.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 12));
      statusBar.setOpaque(true);
      statusBar.setBackground(COLOR_BG_STATUS);

      // Set up content pane
      Container cp = getContentPane();
      cp.setLayout(new BorderLayout());
      cp.add(gamePanel, BorderLayout.CENTER);
      cp.add(statusBar, BorderLayout.PAGE_END); // same as SOUTH

      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      pack();  // pack all the components in this JFrame
      setTitle("Tic Tac Toe");
      setVisible(true);  // show this JFrame

      newGame();
   }

   /** Initialize the Game (run once) */
   public void initGame() {
      board = new Seed[ROWS][COLS]; // allocate array
   }

   /** Reset the game-board contents and the status, ready for new game */
   public void newGame() {
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            board[row][col] = Seed.NO_SEED; // all cells empty
         }
      }
      currentPlayer = Seed.CROSS;    // cross plays first
      currentState  = State.PLAYING; // ready to play
   }

   /**
    *  The given player makes a move on (selectedRow, selectedCol).
    *  Update cells[selectedRow][selectedCol]. Compute and return the
    *  new game state (PLAYING, DRAW, CROSS_WON, NOUGHT_WON).
    */
   public State stepGame(Seed player, int selectedRow, int selectedCol) {
      // Update game board
      board[selectedRow][selectedCol] = player;

      // Compute and return the new game state
      if (board[selectedRow][0] == player  // 3-in-the-row
                &amp;&amp; board[selectedRow][1] == player
                &amp;&amp; board[selectedRow][2] == player
             || board[0][selectedCol] == player // 3-in-the-column
                &amp;&amp; board[1][selectedCol] == player
                &amp;&amp; board[2][selectedCol] == player
             || selectedRow == selectedCol  // 3-in-the-diagonal
                &amp;&amp; board[0][0] == player
                &amp;&amp; board[1][1] == player
                &amp;&amp; board[2][2] == player
             || selectedRow + selectedCol == 2 // 3-in-the-opposite-diagonal
                &amp;&amp; board[0][2] == player
                &amp;&amp; board[1][1] == player
                &amp;&amp; board[2][0] == player) {
         return (player == Seed.CROSS) ? State.CROSS_WON : State.NOUGHT_WON;
      } else {
         // Nobody win. Check for DRAW (all cells occupied) or PLAYING.
         for (int row = 0; row &lt; ROWS; ++row) {
            for (int col = 0; col &lt; COLS; ++col) {
               if (board[row][col] == Seed.NO_SEED) {
                  return State.PLAYING; // still have empty cells
               }
            }
         }
         return State.DRAW; // no empty cell, it's a draw
      }
   }

   /**
    *  Inner class DrawCanvas (extends JPanel) used for custom graphics drawing.
    */
   class GamePanel extends JPanel {
      private static final long serialVersionUID = 1L; // to prevent serializable warning

      @Override
      public void paintComponent(Graphics g) {  // Callback via repaint()
         super.paintComponent(g);
         setBackground(COLOR_BG);  // set its background color

         // Draw the grid lines
         g.setColor(COLOR_GRID);
         for (int row = 1; row &lt; ROWS; ++row) {
            g.fillRoundRect(0, CELL_SIZE * row - GRID_WIDTH_HALF,
                  BOARD_WIDTH-1, GRID_WIDTH, GRID_WIDTH, GRID_WIDTH);
         }
         for (int col = 1; col &lt; COLS; ++col) {
            g.fillRoundRect(CELL_SIZE * col - GRID_WIDTH_HALF, 0,
                  GRID_WIDTH, BOARD_HEIGHT-1, GRID_WIDTH, GRID_WIDTH);
         }

         // Draw the Seeds of all the cells if they are not empty
         // Use Graphics2D which allows us to set the pen's stroke
         Graphics2D g2d = (Graphics2D)g;
         g2d.setStroke(new BasicStroke(SYMBOL_STROKE_WIDTH,
               BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
         for (int row = 0; row &lt; ROWS; ++row) {
            for (int col = 0; col &lt; COLS; ++col) {
               int x1 = col * CELL_SIZE + CELL_PADDING;
               int y1 = row * CELL_SIZE + CELL_PADDING;
               if (board[row][col] == Seed.CROSS) {  // draw a 2-line cross
                  g2d.setColor(COLOR_CROSS);
                  int x2 = (col + 1) * CELL_SIZE - CELL_PADDING;
                  int y2 = (row + 1) * CELL_SIZE - CELL_PADDING;
                  g2d.drawLine(x1, y1, x2, y2);
                  g2d.drawLine(x2, y1, x1, y2);
               } else if (board[row][col] == Seed.NOUGHT) {  // draw a circle
                  g2d.setColor(COLOR_NOUGHT);
                  g2d.drawOval(x1, y1, SYMBOL_SIZE, SYMBOL_SIZE);
               }
            }
         }

         // Print status message
         if (currentState == State.PLAYING) {
            statusBar.setForeground(Color.BLACK);
            statusBar.setText((currentPlayer == Seed.CROSS) ? "X's Turn" : "O's Turn");
         } else if (currentState == State.DRAW) {
            statusBar.setForeground(Color.RED);
            statusBar.setText("It's a Draw! Click to play again");
         } else if (currentState == State.CROSS_WON) {
            statusBar.setForeground(Color.RED);
            statusBar.setText("'X' Won! Click to play again");
         } else if (currentState == State.NOUGHT_WON) {
            statusBar.setForeground(Color.RED);
            statusBar.setText("'O' Won! Click to play again");
         }
      }
   }

   /** The entry main() method */
   public static void main(String[] args) {
      // Run GUI codes in the Event-Dispatching thread for thread safety
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new TTTGraphics(); // Let the constructor do the job
         }
      });
   }
}</code></pre>

<h5>How it Works?</h5>
<p>[TODO]</p>


<h3>A Graphical Tic-Tac-Toe with OO Design</h3>

<p>In a good OO design, each class shall be encapsulated, shall have its own attributes and operations (variables and methods), and responsible for <em>painting itself</em> in a graphics program.</p>



<p>The class diagram is as follows:</p>

<img class="image-center" src="images/GameTTT_GraphicsOOClassDiagram.png" alt="GameTTT_GraphicsOOClassDiagram.png" />

<h5>Enumeration <span class="font-code">Seed.java</span></h5>

<pre><code class="language-java line-numbers">/**
 * This enum is used by:
 * 1. Player: takes value of CROSS or NOUGHT
 * 2. Cell content: takes value of CROSS, NOUGHT, or NO_SEED.
 *
 * Ideally, we should define two enums with inheritance, which is,
 *  however, not supported.
 */
public enum Seed {   // to save as "Seed.java"
   CROSS, NOUGHT, NO_SEED
}</code></pre>

<h5>Enumeration <span class="font-code">State.java</span></h5>
<pre><code class="language-java line-numbers">/**
 *  The enum State contains the various game states of the TTT game
 */
public enum State {  // to save as "State.java"
   PLAYING, DRAW, CROSS_WON, NOUGHT_WON
}</code></pre>

<h5>Class <span class="font-code">Cell.java</span></h5>

<pre><code class="language-java line-numbers">import java.awt.*;
/**
 * The Cell class models each individual cell of the game board.
 */
public class Cell {
   // Define named constants for drawing
   public static final int SIZE = 120; // cell width/height (square)
   // Symbols (cross/nought) are displayed inside a cell, with padding from border
   public static final int PADDING = SIZE / 5;
   public static final int SEED_SIZE = SIZE - PADDING * 2;
   public static final int SEED_STROKE_WIDTH = 8; // pen's stroke width

   // Define properties (package-visible)
   /** Content of this cell (Seed.EMPTY, Seed.CROSS, or Seed.NOUGHT) */
   Seed content;
   /** Row and column of this cell */
   int row, col;

   /** Constructor to initialize this cell with the specified row and col */
   public Cell(int row, int col) {
      this.row = row;
      this.col = col;
      content = Seed.NO_SEED;
   }

   /** Reset this cell's content to EMPTY, ready for new game */
   public void newGame() {
      content = Seed.NO_SEED;
   }

   /** Paint itself on the graphics canvas, given the Graphics context */
   public void paint(Graphics g) {
      // Use Graphics2D which allows us to set the pen's stroke
      Graphics2D g2d = (Graphics2D)g;
      g2d.setStroke(new BasicStroke(SEED_STROKE_WIDTH,
            BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
      // Draw the Seed if it is not empty
      int x1 = col * SIZE + PADDING;
      int y1 = row * SIZE + PADDING;
      if (content == Seed.CROSS) {
         g2d.setColor(GameMain.COLOR_CROSS);  // draw a 2-line cross
         int x2 = (col + 1) * SIZE - PADDING;
         int y2 = (row + 1) * SIZE - PADDING;
         g2d.drawLine(x1, y1, x2, y2);
         g2d.drawLine(x2, y1, x1, y2);
      } else if (content == Seed.NOUGHT) {  // draw a circle
         g2d.setColor(GameMain.COLOR_NOUGHT);
         g2d.drawOval(x1, y1, SEED_SIZE, SEED_SIZE);
      }
   }
}</code></pre>

<h5>Class <span class="font-code">Board.java</span></h5>

<pre><code class="language-java line-numbers">import java.awt.*;
/**
 * The Board class models the ROWS-by-COLS game board.
 */
public class Board {
   // Define named constants
   public static final int ROWS = 3;  // ROWS x COLS cells
   public static final int COLS = 3;
   // Define named constants for drawing
   public static final int CANVAS_WIDTH = Cell.SIZE * COLS;  // the drawing canvas
   public static final int CANVAS_HEIGHT = Cell.SIZE * ROWS;
   public static final int GRID_WIDTH = 8;  // Grid-line's width
   public static final int GRID_WIDTH_HALF = GRID_WIDTH / 2; // Grid-line's half-width
   public static final Color COLOR_GRID = Color.LIGHT_GRAY;  // grid lines
   public static final int Y_OFFSET = 1;  // Fine tune for better display

   // Define properties (package-visible)
   /** Composes of 2D array of ROWS-by-COLS Cell instances */
   Cell[][] cells;

   /** Constructor to initialize the game board */
   public Board() {
      initGame();
   }

   /** Initialize the game objects (run once) */
   public void initGame() {
      cells = new Cell[ROWS][COLS]; // allocate the array
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            // Allocate element of the array
            cells[row][col] = new Cell(row, col);
               // Cells are initialized in the constructor
         }
      }
   }

   /** Reset the game board, ready for new game */
   public void newGame() {
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            cells[row][col].newGame(); // clear the cell content
         }
      }
   }

   /**
    *  The given player makes a move on (selectedRow, selectedCol).
    *  Update cells[selectedRow][selectedCol]. Compute and return the
    *  new game state (PLAYING, DRAW, CROSS_WON, NOUGHT_WON).
    */
   public State stepGame(Seed player, int selectedRow, int selectedCol) {
      // Update game board
      cells[selectedRow][selectedCol].content = player;

      // Compute and return the new game state
      if (cells[selectedRow][0].content == player  // 3-in-the-row
                &amp;&amp; cells[selectedRow][1].content == player
                &amp;&amp; cells[selectedRow][2].content == player
             || cells[0][selectedCol].content == player // 3-in-the-column
                &amp;&amp; cells[1][selectedCol].content == player
                &amp;&amp; cells[2][selectedCol].content == player
             || selectedRow == selectedCol     // 3-in-the-diagonal
                &amp;&amp; cells[0][0].content == player
                &amp;&amp; cells[1][1].content == player
                &amp;&amp; cells[2][2].content == player
             || selectedRow + selectedCol == 2 // 3-in-the-opposite-diagonal
                &amp;&amp; cells[0][2].content == player
                &amp;&amp; cells[1][1].content == player
                &amp;&amp; cells[2][0].content == player) {
         return (player == Seed.CROSS) ? State.CROSS_WON : State.NOUGHT_WON;
      } else {
         // Nobody win. Check for DRAW (all cells occupied) or PLAYING.
         for (int row = 0; row &lt; ROWS; ++row) {
            for (int col = 0; col &lt; COLS; ++col) {
               if (cells[row][col].content == Seed.NO_SEED) {
                  return State.PLAYING; // still have empty cells
               }
            }
         }
         return State.DRAW; // no empty cell, it's a draw
      }
   }

   /** Paint itself on the graphics canvas, given the Graphics context */
   public void paint(Graphics g) {
      // Draw the grid-lines
      g.setColor(COLOR_GRID);
      for (int row = 1; row &lt; ROWS; ++row) {
         g.fillRoundRect(0, Cell.SIZE * row - GRID_WIDTH_HALF,
               CANVAS_WIDTH - 1, GRID_WIDTH,
               GRID_WIDTH, GRID_WIDTH);
      }
      for (int col = 1; col &lt; COLS; ++col) {
         g.fillRoundRect(Cell.SIZE * col - GRID_WIDTH_HALF, 0 + Y_OFFSET,
               GRID_WIDTH, CANVAS_HEIGHT - 1,
               GRID_WIDTH, GRID_WIDTH);
      }

      // Draw all the cells
      for (int row = 0; row &lt; ROWS; ++row) {
         for (int col = 0; col &lt; COLS; ++col) {
            cells[row][col].paint(g);  // ask the cell to paint itself
         }
      }
   }
}</code></pre>

<h5>Classes <span class="font-code">GameMain.java</span></h5>
<p>For better flexibility, we shall extend ths main class from <code>JPanel</code> (instead of <code>JFrame</code>); allocate a <code>JFrame</code> in <code>main()</code>; and set this as the <code>contentPane</code> of the <code>JFrame</code>.</p>

<pre><code class="language-java line-numbers">import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/**
 * Tic-Tac-Toe: Two-player Graphic version with better OO design.
 * The Board and Cell classes are separated in their own classes.
 */
public class GameMain extends JPanel {
   private static final long serialVersionUID = 1L; // to prevent serializable warning

   // Define named constants for the drawing graphics
   public static final String TITLE = "Tic Tac Toe";
   public static final Color COLOR_BG = Color.WHITE;
   public static final Color COLOR_BG_STATUS = new Color(216, 216, 216);
   public static final Color COLOR_CROSS = new Color(239, 105, 80);  // Red #EF6950
   public static final Color COLOR_NOUGHT = new Color(64, 154, 225); // Blue #409AE1
   public static final Font FONT_STATUS = new Font("OCR A Extended", Font.PLAIN, 14);

   // Define game objects
   private Board board;         // the game board
   private State currentState;  // the current state of the game
   private Seed currentPlayer;  // the current player
   private JLabel statusBar;    // for displaying status message

   /** Constructor to setup the UI and game components */
   public GameMain() {

      // This JPanel fires MouseEvent
      super.addMouseListener(new MouseAdapter() {
         @Override
         public void mouseClicked(MouseEvent e) {  // mouse-clicked handler
            int mouseX = e.getX();
            int mouseY = e.getY();
            // Get the row and column clicked
            int row = mouseY / Cell.SIZE;
            int col = mouseX / Cell.SIZE;

            if (currentState == State.PLAYING) {
               if (row &gt;= 0 &amp;&amp; row &lt; Board.ROWS &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; Board.COLS
                     &amp;&amp; board.cells[row][col].content == Seed.NO_SEED) {
                  // Update cells[][] and return the new game state after the move
                  currentState = board.stepGame(currentPlayer, row, col);
                  // Switch player
                  currentPlayer = (currentPlayer == Seed.CROSS) ? Seed.NOUGHT : Seed.CROSS;
               }
            } else {        // game over
               newGame();  // restart the game
            }
            // Refresh the drawing canvas
            repaint();  // Callback paintComponent().
         }
      });

      // Setup the status bar (JLabel) to display status message
      statusBar = new JLabel();
      statusBar.setFont(FONT_STATUS);
      statusBar.setBackground(COLOR_BG_STATUS);
      statusBar.setOpaque(true);
      statusBar.setPreferredSize(new Dimension(300, 30));
      statusBar.setHorizontalAlignment(JLabel.LEFT);
      statusBar.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 12));

      super.setLayout(new BorderLayout());
      super.add(statusBar, BorderLayout.PAGE_END); // same as SOUTH
      super.setPreferredSize(new Dimension(Board.CANVAS_WIDTH, Board.CANVAS_HEIGHT + 30));
            // account for statusBar in height
      super.setBorder(BorderFactory.createLineBorder(COLOR_BG_STATUS, 2, false));

      // Set up Game
      initGame();
      newGame();
   }

   /** Initialize the game (run once) */
   public void initGame() {
      board = new Board();  // allocate the game-board
   }

   /** Reset the game-board contents and the current-state, ready for new game */
   public void newGame() {
      for (int row = 0; row &lt; Board.ROWS; ++row) {
         for (int col = 0; col &lt; Board.COLS; ++col) {
            board.cells[row][col].content = Seed.NO_SEED; // all cells empty
         }
      }
      currentPlayer = Seed.CROSS;    // cross plays first
      currentState = State.PLAYING;  // ready to play
   }

   /** Custom painting codes on this JPanel */
   @Override
   public void paintComponent(Graphics g) {  // Callback via repaint()
      super.paintComponent(g);
      setBackground(COLOR_BG); // set its background color

      board.paint(g);  // ask the game board to paint itself

      // Print status-bar message
      if (currentState == State.PLAYING) {
         statusBar.setForeground(Color.BLACK);
         statusBar.setText((currentPlayer == Seed.CROSS) ? "X's Turn" : "O's Turn");
      } else if (currentState == State.DRAW) {
         statusBar.setForeground(Color.RED);
         statusBar.setText("It's a Draw! Click to play again.");
      } else if (currentState == State.CROSS_WON) {
         statusBar.setForeground(Color.RED);
         statusBar.setText("'X' Won! Click to play again.");
      } else if (currentState == State.NOUGHT_WON) {
         statusBar.setForeground(Color.RED);
         statusBar.setText("'O' Won! Click to play again.");
      }
   }

   /** The entry "main" method */
   public static void main(String[] args) {
      // Run GUI construction codes in Event-Dispatching thread for thread safety
      javax.swing.SwingUtilities.invokeLater(new Runnable() {
         public void run() {
            JFrame frame = new JFrame(TITLE);
            // Set the content-pane of the JFrame to an instance of main JPanel
            frame.setContentPane(new GameMain());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.pack();
            frame.setLocationRelativeTo(null); // center the application window
            frame.setVisible(true);            // show it
         }
      });
   }
}</code></pre>

<h5>How it Works?</h5>
<p>[TODO]</p>
	
<h4>Running as a Standalone Program</h4>
<p>Simply run the class containing the entry <code>main()</code> method.</p>

<h4>Deploying an Application via a JAR file</h4>
<p>To deploy an application containing many classes, you have to pack (i.e., jar) all classes and resources into a single file, with a manifest that specifies the main class (containing the entry <code>main()</code> method).</p>

<p>For example:</p>
<ul>
<li>via the Eclipse's &quot;Export&quot; option: Right-click on the project &rArr; Export &rArr; Java &rArr; JAR file &rArr; Next &rArr; Specify the JAR filename &rArr; Next &rArr; Next &rArr; Select &quot;Generate the manifest file&quot; &rArr; Browse to select the main class &quot;<code>GameMain</code>&quot; &rArr; Finish.</li>
<li>via the &quot;<code>jar</code>&quot; command.<br />
  First, create a manifest file called &quot;<code>tictactoe.mf</code>&quot;, as follow:
<pre><code class="language-java">Manifest-Version: 1.0
Main-Class: GameMain</code></pre>
	
Next, issue a &quot;<code>jar</code>&quot; command (form CMD/Terminal shell) where options <code>'c'</code> for create, <code>'m'</code> for manifest, <code>'f'</code> for output jar filename, and <code>'v'</code> for verbose:
<pre class="color-command">
jar cmfv tictactoe.mf tictactoe.jar *.class</pre>

</li>
</ul>

<p>You can run the program from a JAR file directly (without unpacking the JAR file) by:</p>
<ol>
<li>In Windows' Explorer, right-click on the JAR file &rArr; Open with &rArr; Java Platform SE Binary; or</li>
<li>From the CMD/Terminal shell, run <code>java.exe</code> with <code>-jar</code> option, i.e.,
  <pre class="color-command">
java -jar JarFilename.jar</pre></li>
</ol>

<p>Note: JAR file uses the ZIP algorithm. In other words, you could use WinZIP/7-Zip to open and extract the contents of a JAR file.</p>

<h4>Running as an Applet (Obsolete)</h4>

<p>Note: Applet is no longer supported on browser! I nostalgically keep this section.</p>

<h5><span class="font-code">AppletMain.java</span></h5>

<p>Provide a main class (says <code>AppletMain.java</code>) for the applet that extends <code>javax.swing.JApplet</code>:</p>

<pre><code class="language-java line-numbers">import javax.swing.*;
 
/** Tic-tac-toe Applet */
@SuppressWarnings("serial")
public class AppletMain extends JApplet {
 
   /** init() to setup the GUI components */
   @Override
   public void init() {
      // Run GUI codes in the Event-Dispatching thread for thread safety
      try {
         // Use invokeAndWait() to ensure that init() exits after GUI construction
         SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
               setContentPane(new GameMain());
            }
         });
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
}</code></pre>

<h5><span class="font-code">TicTacToe.html</span></h5>

<p>Provide an HTML file (says &quot;<code>TicTacToe.html</code>&quot;) that embeds the &quot;<code>AppletMain.class</code>&quot;:</p>
<pre><code class="language-html line-numbers">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Tic Tac Toe&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Tic Tac Toe&lt;/h1&gt;
  &lt;applet code="AppletMain.class" width="300" height="330" alt="Error Loading Applet?!"&gt;
  Your browser does not seem to support &amp;lt;APPLET&amp;gt; tag!
  &lt;/applet&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<h5><span class="font-code">tictactoe.jar</span></h5>
<p>To deploy an applet which contains more than one classes, you need to pack all the classes and resources into a JAR file (e.g., via Eclipse's &quot;Export&quot; option or &quot;<code>jar</code>&quot; command described earlier), but you need not use a manifest (for specify a main class as applet does not need a <code>main()</code> method). Then, use the following <code>&lt;applet&gt;</code> tag with an &quot;<code>archive</code>&quot; attribute to specify the JAR filename:</p>

<pre><code class="language-html">&lt;applet code="AppletMain.class"
   archive="JarFileName.jar"
   width="300" height="300"
   alt="Error Loading Applet?!" &gt;
Your browser does not seem to support &lt;APPLET&gt; tag!
&lt;/applet&gt;</code></pre>
	
<h3>A Graphical Tic-Tac-Toe with Sound Effect and Images</h3>

<p>Read &quot;Using Images and Audio&quot;.</p>

<h5>Where to keep the image and audio files?</h5>
<p>For Eclipse, create folders called &quot;images&quot; and &quot;audio&quot; under &quot;src&quot;, and copy/paste the files there. These folders/files will be duplicated under the &quot;bin&quot; for execution.</p>
	
<h5><span class="font-code">SoundEffect.java</span></h5>

<pre><code class="language-java line-numbers">import java.io.IOException;
import java.net.URL;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
/**
 * This enum encapsulates all the sound effects of a game, so as to separate the sound playing
 * codes from the game codes.
 * 1. Define all your sound effect names and the associated wave file.
 * 2. To play a specific sound, simply invoke SoundEffect.SOUND_NAME.play().
 * 3. You might optionally invoke the static method SoundEffect.initGame() to pre-load all the
 *    sound files, so that the play is not paused while loading the file for the first time.
 * 4. You can the static variable SoundEffect.volume to SoundEffect.Volume.MUTE
 *    to mute the sound.
 *
 * For Eclipse, place the audio file under "src", which will be copied into "bin".
 */
public enum SoundEffect {
   EAT_FOOD("audio/eatfood.wav"),
   EXPLODE("audio/explode.wav"),
   DIE("audio/die.wav");

   /** Nested enumeration for specifying volume */
   public static enum Volume {
      MUTE, LOW, MEDIUM, HIGH
   }

   public static Volume volume = Volume.LOW;

   /** Each sound effect has its own clip, loaded with its own sound file. */
   private Clip clip;

   /** Private Constructor to construct each element of the enum with its own sound file. */
   private SoundEffect(String soundFileName) {
      try {
         // Use URL (instead of File) to read from disk and JAR.
         URL url = this.getClass().getClassLoader().getResource(soundFileName);
         // Set up an audio input stream piped from the sound file.
         AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(url);
         // Get a clip resource.
         clip = AudioSystem.getClip();
         // Open audio clip and load samples from the audio input stream.
         clip.open(audioInputStream);
      } catch (UnsupportedAudioFileException e) {
         e.printStackTrace();
      } catch (IOException e) {
         e.printStackTrace();
      } catch (LineUnavailableException e) {
         e.printStackTrace();
      }
   }

   /** Play or Re-play the sound effect from the beginning, by rewinding. */
   public void play() {
      if (volume != Volume.MUTE) {
         if (clip.isRunning())
            clip.stop();   // Stop the player if it is still running
         clip.setFramePosition(0); // rewind to the beginning
         clip.start();     // Start playing
      }
   }

   /** Optional static method to pre-load all the sound files. */
   static void initGame() {
      values(); // calls the constructor for all the elements
   }
}</code></pre>

<h5>Enumeration <span class="font-code">State.java</span></h5>

<p>Save as above</p>

<h5>Enumeration <span class="font-code">Seed.java</span></h5>
<pre><code class="language-java line-numbers">import java.awt.Image;
import java.net.URL;
import javax.swing.ImageIcon;
/**
 * This enum is used by:
 * 1. Player: takes value of CROSS or NOUGHT
 * 2. Cell content: takes value of CROSS, NOUGHT, or NO_SEED.
 *
 * We also attach a display image icon (text or image) for the items.
 *   and define the related variable/constructor/getter.
 * To draw the image:
 *   g.drawImage(content.getImage(), x, y, width, height, null);
 *
 * Ideally, we should define two enums with inheritance, which is,
 *  however, not supported.
 */
public enum Seed {   // to save as "Seed.java"
   CROSS("X", "images/cross.gif"),   // displayName, imageFilename
   NOUGHT("O", "images/not.gif"),
   NO_SEED(" ", null);

   // Private variables
   private String displayName;
   private Image img = null;

   // Constructor (must be private)
   private Seed(String name, String imageFilename) {
      this.displayName = name;

      if (imageFilename != null) {
         URL imgURL = getClass().getClassLoader().getResource(imageFilename);
         ImageIcon icon = null;
         if (imgURL != null) {
            icon = new ImageIcon(imgURL);
            //System.out.println(icon);  // debugging
         } else {
            System.err.println("Couldn't find file " + imageFilename);
         }
         img = icon.getImage();
      }
   }

   // Public getters
   public String getDisplayName() {
      return displayName;
   }
   public Image getImage() {
      return img;
   }
}</code></pre>
	
<h5><span class="font-code">Cell.java</span></h5>
<pre><code class="language-java line-numbers">import java.awt.*;
/**
 * The Cell class models each individual cell of the game board.
 */
public class Cell {
   // Define named constants for drawing
   public static final int SIZE = 120; // cell width/height (square)
   // Symbols (cross/nought) are displayed inside a cell, with padding from border
   public static final int PADDING = SIZE / 5;
   public static final int SEED_SIZE = SIZE - PADDING * 2;

   // Define properties (package-visible)
   /** Content of this cell (Seed.EMPTY, Seed.CROSS, or Seed.NOUGHT) */
   Seed content;
   /** Row and column of this cell */
   int row, col;

   /** Constructor to initialize this cell with the specified row and col */
   public Cell(int row, int col) {
      this.row = row;
      this.col = col;
      content = Seed.NO_SEED;
   }

   /** Reset this cell's content to EMPTY, ready for new game */
   public void newGame() {
      content = Seed.NO_SEED;
   }

   /** Paint itself on the graphics canvas, given the Graphics context */
   public void paint(Graphics g) {
      // Draw the Seed if it is not empty
      int x1 = col * SIZE + PADDING;
      int y1 = row * SIZE + PADDING;
      if (content == Seed.CROSS || content == Seed.NOUGHT) {
         g.drawImage(content.getImage(), x1, y1, SEED_SIZE, SEED_SIZE, null);
      }
   }
}</code></pre>
	
<h5><span class="font-code">Board.java</span></h5>

<p>Same as above</p>
	
<h5><span class="font-code">GameMain.java</span></h5>

<p>Play the sound effect after the <code>stepGame()</code>.</p>
	
<pre><code class="language-java">// Play appropriate sound clip
if (currentState == State.PLAYING) {
   SoundEffect.EAT_FOOD.play();
} else {
   SoundEffect.DIE.play();
}</code></pre>

<h5>How It Works?</h5>
<p>[TODO]</p>

<h3>Game Programming Assignment</h3>

<p>You can use the above Tic-tac-toe as a template to develop board games such as Connect-4 and Othello.</p>

<h4>Sudoku</h4>

<p>See the &quot;Sudoku&quot; article.</p>

<h4>Mine Sweeper</h4>
<p>See the &quot;Mine Sweeper&quot; article.</p>

<h4>Snake</h4>
<p>See the &quot;Snake Game&quot; article.</p>

<h4>Tetris</h4>
<p>See the &quot;Tetris&quot; article.</p>

<h4>Connect-Four</h4>

<img class="image-float-right" src="images/GameConnect4_Applet.png" alt="GameConnect4_Applet.png" />

<p>Wiki &quot;Connect-4&quot; to understand the rules of the game.</p>

<p>To write a Connect-Four game, let's start from Tic-Tac-Toe's &quot;<a href="JavaGame_TicTacToe.html#TTTGraphics">Graphics Version</a>&quot;. Do the following changes on &quot;<code>TTTGraphics.java</code>&quot;:</p>

<ol>
<li>Change constants <code>ROWS</code> to 6 and <code>COLS</code> to 7. Run the program. You shall see a 6&times;7 grid. Try clicking on the cells, &quot;cross&quot; and &quot;nought&quot; shall be displayed alternately.</li>

<li>Modify the <code>mouseClicked()</code> event-handler to position the seed at the &quot;bottom&quot; row of the column clicked, instead of on the the cell clicked. You need to check that there is empty cell on that column.
	
<pre><code class="language-java">if (colSelected &gt;= 0 &amp;&amp; colSelected &lt; COLS) {
   // Look for an empty cell starting from the bottom row
   for (int row = ROWS -1; row &gt;= 0; row--) {
      if (board[row][colSelected] == Seed.EMPTY) {
         board[row][colSelected] = currentPlayer; // Make a move
         updateGame(currentPlayer, row, colSelected); // update state
         // Switch player
         currentPlayer = (currentPlayer == Seed.CROSS) ? Seed.NOUGHT : Seed.CROSS;
         break;
      }
   }
}</code></pre>
</li>

<li>Modify the <code>hasWon()</code> method to check for 4-in-a-line (along row, column, diagonal or opposite-diagonal).
<pre><code class="language-java">// HINTS:
public boolean hasWon(Seed theSeed, int rowSelected, int colSelected) {
   // Check for 4-in-a-line on the rowSelected
   int count = 0;
   for (int col = 0; col &lt; COLS; ++col) {
      if (board[rowSelected][col] == theSeed) {
         ++count;
         if (count == 4) return true;  // found
      } else {
         count = 0; // reset and count again if not consecutive
      }
   }
   // Check column and diagonals
   ......
   return false;  // no 4-in-a-line found
}</code></pre>
</li>
</ol>

<p>That's all!</p>
<p>Next,</p>

<ol>
<li>Tidy up the names (In Eclipse, Refactor &rArr; Rename).</li>
<li>Tidy up the display (using red and yellow discs, instead of cross and nought).</li>
<li>Add more features. For example, sound effect; or buttons to control the game.</li>
<li>Re-design your classes (Read the &quot;<a href="JavaGame_TicTacToe.html#TTTGraphicsAdvanceOO">Graphics Advanced-OO Tic-Tac-Toe</a>&quot;).</li>
<li>Improve your display (e.g., using images, animation etc).</li>
</ol>

<h4>Othello (Reversi)</h4>

<img class="image-float-right" src="images/GameOthello_Applet.png" alt="images/GameOthello_Applet.png" />

<p>Wiki &quot;Othello&quot; or &quot;Reversi&quot; to understand the rules of the game.</p>

<p>Modify the above Tic-Tac-Toe (&quot;<code>TTTGraphics.java</code>&quot;):</p>
<ol>
<li>Change <code>ROWS</code> and <code>COLS</code> to 8. Run the program. You shall see a 8&times;8 grid. Try clicking on the cells, &quot;cross&quot; and &quot;nought&quot; shall be displayed alternately.</li>
<li>Modify the <code>updateGame(Seed theSeed, int rowSelected, int colSelect)</code> to flip the opponent's seeds along the row, column, diagonal and opposite diagonal - centered at <code>(rowSelected, colSelected)</code> - after the player with &quot;<code>theSeed</code>&quot; has placed on <code>(rowSelected, colSelected)</code>. If there is no more empty space, the game is over. Decide the winner by counting the numbers of black and white seeds.<br />
HINTS:
<pre><code class="language-java">public void updateGame(Seed mySeed, int rowSelected, int colSelected) {
   Seed opponentSeed = (mySeed == Seed.BLACK) ? Seed.WHITE : Seed.BLACK; 
   int col, row;

   // Flip opponent's seeds along the row to the right if any
   col = colSelected + 1;
   // Look for adjacent opponent's seeds up to 2nd last column
   while (col &lt; COLS - 1 &amp;&amp; board[rowSelected][col] == opponentSeed) {
      ++col;
   }
   // Look for my seed immediately after opponent's seeds
   if (col &lt;= COLS - 1 &amp;&amp; board[rowSelected][col] == mySeed) {
      // Flip opponent's seeds in between to my seeds
      for (int colFlip = colSelected + 1; colFlip &lt;= col - 1; ++colFlip) {
         board[rowSelected][colFlip] = mySeed;
      }
   }
   ......
   // Check for game over and declare winner
   ......</code></pre>
</li>
<li>Remove <code>isDraw()</code> and <code>hasWon()</code>.</li></ol>

<p>Next,</p>

<ol>
<li>Tidy up the names (Refactor &rArr; Rename).</li>
<li>Tidy up the display (using black and white discs, instead of cross and nought).</li>
<li>Add more features. For example, sound effect; or buttons to control the game.</li>
<li>Re-design your classes (Read the &quot;<a href="JavaGame_TicTacToe.html#TTTGraphicsAdvanceOO">Graphics Advanced-OO Tic-Tac-Toe</a>&quot;).</li>
<li>Improve your display (e.g., using images, animation etc).</li>
</ol>

<h4>MasterMind</h4>
<p>[TODO]</p>

<h4>Checker</h4>
<p>[TODO]</p>

<h3>Animation</h3>

<p>Read &quot;<a href="J4b_CustomGraphics.html#animation">Animation</a>&quot; of &quot;Custom Graphics&quot;.</p>

<h3>Fast Matching of Winning Patterns with Bit-Masks (Advanced)</h3>

<p><span class="line-heading">Reference:</span> Arthur van Hoff's Tic Tac Toe Applet Demo (under the JDK demo &quot;applets&quot; folder).</p>

<p>A much more efficient method for matching with a winning pattern in a Tic-tac-toe is to use <em>a 9-bit binary number</em> (stored as an <code>int</code> or <code>short</code> type) to denote the placement of the seeds, and use bit operations to perform the matching.</p>

<img class="image-center" src="images/GameTTT_BitOp.png" alt="GameTTT_BitOp.png" />

<p>The following table summaries all the bit-wise operations, which are efficient and fast.</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Description</th>
  <th>Usage</th>
  <th>Example</th>
</tr>
<tr>
  <td class="td-center"><code><strong>&amp;</strong></code></td>
  <td>Bit-wise AND</td>
  <td><code><em>expr1</em> &amp; <em>expr2</em></code></td>
  <td><code>0b0110 0001 &amp; Ob1110 0000</code> gives <code>0b0110 0000</code></td>
</tr>
<tr class="table-row-alt">
  <td class="td-center"><code><strong>|</strong></code></td>
  <td>Bit-wise OR</td>
  <td><code><em>expr1</em> | <em>expr2</em></code></td>
  <td><code>0b0110 0001 | Ob0000 1000</code> gives <code>0b0110 1001</code></td>
</tr>
<tr>
  <td class="td-center"><code><strong>!</strong></code></td>
  <td>Bit-wise NOT</td>
  <td><code>!<em>expr</em></code></td>
  <td><code>^0b0110 0001</code> gives <code>0b1001 1110</code></td>
</tr>
<tr class="table-row-alt">
  <td class="td-center"><code><strong>^</strong></code></td>
  <td>Bit-wise XOR</td>
  <td><code><em>expr1</em> ^ <em>expr2</em></code></td>
  <td><code>0b0110 0001 ^ Ob0000 0001</code> gives <code>0b0110 1001</code></td>
</tr>
<tr>
  <td class="td-center"><code><strong>&lt;&lt;</strong></code></td>
  <td>Left-shift and padded with zeros</td>
  <td><code>operand &lt;&lt; number</code></td>
  <td><code>0b0000 0001 &lt;&lt; 4</code> gives <code>0b0001 0000</code></td>
</tr>
<tr class="table-row-alt">
  <td class="td-center"><code><strong>&gt;&gt;</strong></code></td>
  <td>Right-shift and padded with the &quot;sign-bit&quot;<br />
    (Signed-extended right-shift)</td>
  <td><code>operand &gt;&gt; number</code></td>
  <td><code>0b1000 0001 &gt;&gt; 2</code> gives <code>0b1110 0000</code></td>
</tr>
<tr>
  <td class="td-center"><code><strong>&gt;&gt;&gt;</strong></code></td>
  <td>Right-shift and padded with zeros<br />
  (Unsigned-extended right-shift)</td>
  <td><code>operand &gt;&gt;&gt; number</code></td>
  <td><code>0b1000 0001 &gt;&gt;&gt; 2</code> gives <code>0b0010 0000</code></td>
</tr>

</table>

<p>We can keep the 8 winning patterns in an <code>int</code> array as follows:</p>
<pre><code class="language-java">int[] winningPatterns = {
      0x1c0,   // 0b111 000 000 (row 2)
      0x038,   // 0b000 111 000 (row 1)
      0x007,   // 0b000 000 111 (row 0)
      0x124,   // 0b100 100 100 (col 2)
      0x092,   // 0b010 010 010 (col 1)
      0x049,   // 0b001 001 001 (col 0)
      0x111,   // 0b100 010 001 (diagonal)
      0x054};  // 0b001 010 100 (opposite diagonal)
   // msb is (2, 2); lsb is (0, 0)</code></pre>
      
<p>Note: JDK 1.7 supports binary literals beginning with prefix &quot;<code>0b</code>&quot;. Pre-JDK 1.7 does not support binary literals but supports hexadecimal literals beginning with prefix &quot;<code>0x</code>&quot;. Eclipse IDE supports JDK 1.7 only after Eclipse 3.7.2. Hence, try <code>0b...</code> but fall back to <code>0x...</code> if compilation fails.</p>

<p>We define two placement binary patterns for the cross and nought respectively.</p>
<pre><code class="language-java">int crossPattern;
int noughtPattern;
 
// updating the pattern after each move
int bitPosition = rowSelected * ROWS + colSelected;
if (currentPlayer == Seed.CROSS) {
   crossPattern = crossPattern | (0x1 &lt;&lt; bitPosition);
} else {
   noughtPattern = noughtPattern | (0x1 &lt;&lt; bitPosition);
}</code></pre>

<p><code>(0x1 &lt;&lt; bitPosition)</code> shifts a binary <code>0b 000 000 001</code> to the left by the <code>bitPosition</code> number of bits, so as to place a <code>'1'</code> bit at the proper position. It is then bit-OR with the existing pattern to include the new bit, without modifying the existing bits. For example, suppose <code>rowSelect = 2</code> and <code>colSelected = 0</code>, then <code>bitPosition = 6</code>. <code>(0x1 &lt;&lt; bitPosition)</code> gives <code>0b 001 000 000</code>.</p>

<p>To match with the winning patterns:</p>
<pre><code class="language-java">public boolean hasWon(Seed theSeed) {
   int playerPattern = (theSeed == Seed.CROSS) ? crossPattern : noughtPattern; 
   for (int aWinningPattern : winningPatterns) {
      if ((aWinningPattern &amp; playerPattern) == aWinningPattern) {
         return true;
      }
   }
   return false;
}</code></pre>

<p><code>(aWinningPattern &amp; playerPattern)</code> masks out all the bits in the <code>playerPattern</code> except those having 1's in <code>aWinningPattern</code>. For example, suppose that <code>playerPattern = 0b111 000 101</code>, it matches the <code>aWinningPattern = 0b111 000 000</code>. This is because <code>(playerPattern &amp; aWinningPattern)</code> returns <code>0b111 000 000</code>, which is the same the the <code>aWinningPattern</code>.</p>

<p>This code is very much more efficient as it involves only comparison with 8 integers (plus 8 efficient bit-AND operations).</p>

<h3>Other Modes of Operation</h3>

<h4>WebStart Application</h4>
<p>[TODO]</p>
<h4>Playing Over the Net</h4>
<p>[TODO]</p>


<h3>Playing Against Computer with AI (Advanced)</h3>

<p>Read &quot;<a href="JavaGame_TicTacToe_AI.html">Case Study on Tic-Tac-Toe Part 2: With AI</a>&quot;.</p>

<p class="references">REFERENCES &amp; RESOURCES</p>

<ol>
<li>JDK Applets demo &quot;TicTacToe&quot; (under JDK demo applets folder).</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 17.0.1<br />
Last modified: April, 2022</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>
