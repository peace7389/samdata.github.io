<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Data Analysis with Python</title>

<!-- @@ start change in v1 -->
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="Python4_DataAnalysis.html#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Python Data Analytics</h1>
</div>

<div id="content-main">

<!-- @@ end change in v1 -->

<h3>Introduction</h3>

<p>Data Analysis is process of extracting information from raw data. It aims to build a model with predictive power. In parallel, data visualization aims to present the data graphically for you to easily understanding their meaning.  At the end of data analysis, you could have a model and a set of graphical displays that allow you to predict the responses given the inputs.</p>

<p>To undertake data analysis, you need these knowledge:</p>
<ul>
<li>Programming (in Python, R or Matlab), e.g., Web Scraping which allows the collection of data through the recognition of specific occurrence of HTML tags within the web page.</li>
<li>Mathematics and Statistics: in particular, Bayesian, regression and clustering.</li>
<li>Machine Learning and Artificial Intelligence.</li>
<li>Domain knowledge on the field under study.</li>
</ul>

<h3 id="tools">Tools and Packages</h3>

<h4>Jupyter Notebook</h4>
<p>Jupyter Notebook is great tool for data analysis under Python, which bundled with all the Python data analytics packages. Read &quot;<a href="https://www3.ntu.edu.sg/home/ehchua/programming/webprogramming/Python5_IDE_Tools.html#jupyter">Jupyter Notebook</a>&quot; on how to install and get started.</p>

<h4>SciPy</h4>
<p>SciPy (@ <a href="https://www.scipy.org/">https://www.scipy.org</a>) is a set of open-source Python libraries specialized for mathematics, science and engineering. It consists of the many Python packages.</p>
<p>We will use the following packages for data analysis:</p>

<ul>
<li>NumPy (@ <a href="http://www.numpy.org/">http://www.numpy.org/</a>): the fundamental package for numerical computation. It defines the n-dimensional array (<code>ndarray</code>) and its basic operations.</li>
<li>Pandas (@ <a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a>): provides a high-performance, easy-to-use 2D tabular data structures (<code>DataFrame</code>) and its analysis.</li>
<li>Matplotlib (@ <a href="https://matplotlib.org/">https://matplotlib.org/</a>): supports comprehensive 2D Plotting and rudimentary 3D plotting.</li>
<li>scikit-learn (@ <a href="https://scikit-learn.org/stable/">https://scikit-learn.org/stable/</a>) is a collection of algorithms and tools for machine learning.</li>
<li>Jupyter Notebook (@ <a href="http://jupyter.org/">http://jupyter.org/</a>): An webapp allows you to document your computation in an easily reproducible form.</li>
</ul>

<p>In addition, SciPy also includes:</p>
<ul>
<li>SciPy Library (@ <a href="https://www.scipy.org/scipylib/index.html">https://www.scipy.org/scipylib/index.html</a>): a collection of numerical algorithms and domain-specific toolboxes, including signal processing, optimization, statistics and more.</li>

<li>SymPy (@ <a href="https://www.sympy.org/en/index.html">https://www.sympy.org/en/index.html</a>): symbolic mathematics and algebra.</li>
<li>scikit-image (@ <a href="https://scikit-image.org/">https://scikit-image.org/</a>) is a collection of algorithms for image processing.</li>
<li>Nose (@ <a href="https://nose.readthedocs.io/en/latest/">https://nose.readthedocs.io/en/latest/</a>): a framework for testing Python code, being phased out in preference for pytest (@ <a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>).</li>
<li>h5py (@ <a href="http://www.h5py.org/">http://www.h5py.org/</a>) and PyTables (@ <a href="http://www.pytables.org/">http://www.pytables.org/</a>) can both access data stored in the HDF5 format.</li>
</ul>

<h5>Installation</h5>
<p>(For Windows/Mac/Ubuntu) I suggest that you install Jupyter Notebook (via Python 3's Anaconda distribution), which bundles with most of the Python data analysis packages.</p>
<p>(For Ubuntu) To install all the packages:</p>
<pre class="color-command">
$ <strong>sudo apt-get install python-numpy python-scipy python-matplotlib python-pandas python-sympy python-nose</strong>
<span class="color-comment"># or</span>
$ <strong>sudo apt-get install python3-numpy python3-scipy pytho3n-matplotlib python3-pandas python3-sympy python3-nose</strong>
<span class="color-comment"># [Check] How to install under pip</span></pre>

<h3 id="matplotlib">Matplotlib</h3>

<p>References:</p>
<ol>
<li>Matplotlib mother site @ <a href="http://matplotlib.org/index.html">http://matplotlib.org/index.html</a>.</li>
<li>Matplotlib beginner's guide @ <a href="http://matplotlib.org/users/beginner.html">http://matplotlib.org/users/beginner.html</a>.</li>
</ol>
<br />

<p>Matplotlib is a Python 2D plotting library for generating plots, such as histograms, power spectra, bar charts, error charts, scatter plots, and more. It can be used in interactive environments, including Python scripts, the Python command-line shells, the Jupyter Notebook, web application servers, and graphical user interface toolkits, across platforms (Windows, Unix, Mac). It also produces quality figures in various hardcopy formats, such as PDF, PNG, SVG.</p>

<h4>The <span class="font-code">matplotlib.pyplot</span> Module</h4>

<p>The <code>matplotlib.pyplot</code> is a collection of command-style functions that makes Matplotlib work like MATLAB.</p>
<p>Include the following <code>import</code> statement to use the module:</p>
<pre class="color-command">
import matplotlib.pyplot as plt</pre>

<h4>Get Started</h4>

<h5>Simplest Plot</h5>
<p>The simplest example to plot a line is as follows. Try it out on Jupyter Notebook  and Python's command-line shell, and observe the output.</p>

<pre class="color-example">
<span class="color-comment"># In one cell of Jupyter Notebook</span>
&gt;&gt;&gt; <strong>import matplotlib.pyplot as plt</strong>

<span class="color-comment"># In next cell</span>
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5, 6, 7], [7, 8, 6, 5, 2, 2, 4], 'b*-')</strong>
   <span class="color-comment"># Provide the x, y and the format</span>
   <span class="color-comment"># b: blue, *: star marker, -: solid line style</span>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>plt.show()</strong>
   <span class="color-comment"># Use show() to display the figure
   # It also clear the figure and free memory, ready for the next plot()</span></pre>

<h5>Customizing Your Figure: Setting Title, X-Y Axis, Legend</h5>

<p>You can customize the figure, such as adding title, setting the axes and legend, via dedicated functions/commands. For example,</p>

<pre class="color-example">
<span class="color-comment"># In one cell of Jupyter Notebook</span>
&gt;&gt;&gt; <strong>import matplotlib.pyplot as plt</strong>
<span class="color-comment">
# In next cell</span>
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5, 6, 7], [7, 8, 6, 5, 2, 2, 4], 'b*-', label='Major')</strong>   <span class="color-comment"># &quot;label&quot; used for legend</span>
[&lt;matplotlib.lines.Line2D object at ...&gt;]   <span class="color-comment"># Return a list of &quot;Line2D&quot; objects</span>
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5, 6, 7], [3, 1, 1, 3, 4, 3, 5], 'ro-', label='Minor')</strong>   <span class="color-comment"># Another line</span>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
<span class="color-comment"># Set the title for the current axes</span>
&gt;&gt;&gt; <strong>plt.title('My Star Plot')</strong>
Text(0.5,1,'My Star Plot')    <span class="color-comment"># Return a &quot;Text&quot; object</span>
<span class="color-comment"># Set the axes labels and ranges for the current axes</span>
&gt;&gt;&gt; <strong>plt.xlabel('Some X (unit)')</strong>
&lt;matplotlib.text.Text object at ...&gt;   <span class="color-comment"># Return a &quot;Text&quot; object</span>
&gt;&gt;&gt; <strong>plt.ylabel('Some Y (unit)')</strong>
&lt;matplotlib.text.Text object at ...&gt;
&gt;&gt;&gt; <strong>plt.axis([1, 7, 0, 9])</strong>  <span class="color-comment"># [xmin, xmax, ymin, ymax]</span>
[1, 7, 0, 9]
<span class="color-comment"># Setup legend on the current axes</span>
&gt;&gt;&gt; <strong>plt.legend()</strong>
&lt;matplotlib.legend.Legend object at ...&gt;   <span class="color-comment"># Return a &quot;Legend&quot; object</span>
<span class="color-comment"># Save the figure to file</span>
&gt;&gt;&gt; <strong>plt.savefig('PlotStars.png', dpi=600, format='png')</strong>
&gt;&gt;&gt; <strong>plt.show()</strong>  <span class="color-comment"># Show figure, clear figure and free memory</span></pre>

<h5>Components of a Plot (Figure)</h5>

<p>A plot (figure)  contains sub-plots (sub-figures) called <em>axes</em>. By default, figure 1, sub-figure 1 is created and set as the <em>current figure</em> and <em>current axes</em>, as in the above examples. All plotting functions like <code>plt.plot()</code>, <code>plt.title()</code>, <code>plt.legend()</code> are applied on the <em>current figure</em> (figure 1) and <em>current axes</em> (sub-figure 1).</p>

<img class="image-center" src="images/Python_PlotFigure.png" alt="figure" />

<h5>Figures, Sub-Figures, and Axes</h5>

<p>A figure (plot) has its own display window. A figure contains sub-figures (sub-plots) called <em>axes</em>. By default, figure 1, subplot 1 is created as the <em>current figure</em> and <em>current axes</em>. Plots are done on the current axes of the current figure by default.</p>
<p>You can use the following functions to create figure and sub-figures (sub-plots), and set the current figure and current sub-plot axes.</p>

<ul>
<li><code>figure() -&gt; Figure</code>: start a new figure, with the next running figure number starting from 1.</li>

<li><code>figure(fig_num) -&gt; Figure</code>: if <code>fig_num</code> does not exist, start a new figure; else set <code>fig_num</code> as the active figure.</li>

<li><code>subplot(nrows, ncols, index) -&gt; axes</code>: add a sub-plot to the current figure at the <code>index</code> position on a grid with <code>nrows</code> rows and <code>ncols</code> columns. <code>index</code> starts at 1 in the upper left corner and increases to the right.</li>

<li><code>subplots(nrows=1, ncols=1) -&gt; (Figure, axes_array)</code>: Create a figure and a set of subplots with <code>nrows</code> rows and <code>ncols</code> columns. Return the figure and axes handles.</li>
</ul>

<p>The plotting functions (such as <code>plt.plot()</code>, <code>plt.title()</code>) are applied on the <em>current figure</em> and <em>current axes</em>.</p>


<p>For example,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>import matplotlib.pyplot as plt</strong>
<span class="color-comment"># Start Figure 1. Optional as it is the default.</span>
&gt;&gt;&gt; <strong>plt.figure(1)</strong>   <span class="color-comment"># Same as plt.figure()</span>
&lt;Figure size 640x480 with 0 Axes&gt;   <span class="color-comment"># Return a figure object</span>

<span class="color-comment"># Start Sub-plot 1 as the current axes</span>
&gt;&gt;&gt; <strong>plt.subplot(2, 1, 1)</strong>   <span class="color-comment"># 2 rows, 1 column, start subplot 1. Same as plt.subplot(211)</span>
&lt;matplotlib.axes._subplots.AxesSubplot object at ...&gt;   <span class="color-comment"># Return an axes object</span>
<span class="color-comment"># Plot on the current axes</span>
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5, 6, 7], [7, 8, 6, 5, 2, 2, 4], 'b*-', label='Major')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>plt.title('Sub-Plot 1 Title')</strong>
Text(0.5,1,'Sub-Plot 1 Title')
&gt;&gt;&gt; <strong>plt.legend()</strong>
&lt;matplotlib.legend.Legend object at ...&gt;

<span class="color-comment"># Start Sub-plot 2 as the current axes</span>
&gt;&gt;&gt; <strong>plt.subplot(2, 1, 2)</strong>   <span class="color-comment"># 2 rows, 1 column, start subplot 2. Same as plt.subplot(212)</span>
&lt;matplotlib.axes._subplots.AxesSubplot object at ...&gt;   <span class="color-comment"># Return an axes object</span>
<span class="color-comment"># Plot on the current axes</span>
&gt;&gt;&gt;<strong>plt.plot([1, 2, 3, 4, 5, 6, 7], [3, 1, 1, 3, 4, 3, 5], 'ro-', label='Minor')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>plt.title('Sub-Plot 2 Title')</strong>
Text(0.5,1,'Sub-Plot 2 Title')
&gt;&gt;&gt; <strong>plt.legend()</strong>
&lt;matplotlib.legend.Legend object at ...&gt;

&gt;&gt;&gt; <strong>plt.tight_layout()</strong>   <span class="color-comment"># Prevent subplots </span><span class="color-comment">overlap</span>
&gt;&gt;&gt; <strong>plt.savefig('Plot2x1.png', dpi=600, format='png')</strong>  <span class="color-comment"># Save this figure</span>

<span class="color-comment"># Start Figure 2 (on a new window), and set as the current figure</span>
&gt;&gt;&gt; <strong>plt.figure(2)</strong>
&lt;Figure size 640x480 with 0 Axes&gt;
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5], [1, 3, 2, 7, 5], 'ro-')</strong>  <span class="color-comment"># subplot 1 created automatically as the current axes</span>

&gt;&gt;&gt; <strong>plt.show()</strong></pre>

<img class="image-center" src="images/Python_PlotSubFigure.png" alt="subplot" />

<p>You can also retrieve the handles (references) to the figure and sub-plots (axes), and use the axes in plotting. For example,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>import matplotlib.pyplot as plt</strong>
<span class="color-comment"># Create a figure and sub-plots of 2 rows by 2 columns. Retrieve the handles of figure and subplot axes</span>
&gt;&gt;&gt; <strong>fig1, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)</strong>
&gt;&gt;&gt; <strong>fig1</strong>
&lt;Figure size 640x480 with 4 Axes&gt;   <span class="color-comment"># Figure object</span>
&gt;&gt;&gt; <strong>ax1</strong>
&lt;matplotlib.axes._subplots.AxesSubplot object at ...&gt;   <span class="color-comment"># subplots are AxesSubplot objects</span>
<span class="color-comment">
# Choose the axes for plotting</span>
&gt;&gt;&gt; <strong>ax1.plot([1, 2, 3, 4, 5], [1, 3, 2, 7, 5], 'ro-')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>ax1.set_title('AX1 Title')</strong>
Text(0.5,1,'AX1 Title')
&gt;&gt;&gt; <strong>ax2.plot([1, 2, 3, 4, 5], [8, 5, 2, 3, 3], 'gx-')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>ax2.set_title('AX2 Title')</strong>
Text(0.5,1,'AX2 Title')
&gt;&gt;&gt; <strong>ax3.plot([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], 'bo-')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>ax3.set_title('AX3 Title')</strong>
Text(0.5,1,'AX3 Title')
&gt;&gt;&gt; <strong>ax4.plot([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 'rx-')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>ax4.set_title('AX4 Title')</strong>
Text(0.5,1,'AX4 Title')

&gt;&gt;&gt; <strong>plt.tight_layout()</strong>  <span class="color-comment"># Prevent subplots overlap</span>
&gt;&gt;&gt; <strong>plt.show()</strong></pre>

<img class="image-center" src="images/Python_PlotSubFigure2x2.png" alt="subplot 2x2" />

<p>Notes:</p>
<ol>
<li>For figure with only one sub-plot (axes), use the following to retrieve the figure and axes handles:
  <pre class="color-example">
fig1, ax1 = plt.subplots()   <span class="color-comment"># default one row and one column</span>
</pre>
</li>
<li>You can also use the following functions to retrieve the handle of the <em>current axes</em> and the <em>current figure</em>:
  <pre class="color-example">
ax = plt.gca()    <span class="color-comment"># Get the current axes handle</span>
fig = plt.gcf()   <span class="color-comment"># Get the current figure handle</span></pre>
</li>
<li>You can clear the <em>current figure</em> with <code>plt.clf()</code>, and <em>current axes</em> with <code>plt.cla()</code>.</li>
<li>The <code>plt.show()</code> function clears the current figure and free the memory.</li>
</ol>

<h4>The <span class="font-code">plot()</span> Function</h4>

<p>The <code>plot()</code> has these signatures:</p>

<pre class="color-syntax">
&gt;&gt;&gt; <strong>help(plt.plot)</strong>
plot([x], y, [fmt], [**kwargs])   <span class="color-comment"># Single line or point</span>
plot([x1], y1, [fmt1], [x2], y2, [fmt2], ..., [**kwargs])  <span class="color-comment"># Multiple lines or points</span>
   <span class="color-comment"># x's and y's can be an array-like structure such as list (line-plot) or a scaler (point-plot)
   # fmt is a format string</span><span class="color-comment"></span>
</pre>

<p>For examples,</p>
<ul>
<li><code>plot(y)</code>: plot <code>y</code> with <code>x=range(len(y))=[0, 1, 2, ..., len-1]</code>, where  <code>y</code> can be an array (line-plot) or a scalar (point-plot).</li>
<li><code>plot(x, y)</code>: plot <code>y</code> against <code>x</code>, where <code>x</code> and <code>y</code> can be an array (line-plot) or a scalar (point-plot)</li>
<li><code>plot(x, y, fmt)</code>: plot <code>y</code> against <code>x</code> using the format string, e.g., <code>'bo-'</code> for blue circle solid-line, <code>'r+'</code> for red pluses.</li>
<li><code>plot(x1, y1, fmt1, x2, y2, fmt2, ...)</code>: plot <code>yn</code> vs. <code>xn</code> using the respective format strings (multiple lines or multiple points).</li>
</ul>

<h5>Line's Properties: Color, Marker and Line Style</h5>

<p>LInes are represented in <code>Line2D</code> objects. You can use format string to specify the <em>color</em>, <em>marker</em> and <em>line style</em>.</p>

<p>The color abbreviations are:</p>
<ul>
<li><code>'r'</code> (red), <code>'g'</code> (green), <code>'b'</code> (blue)</li>
<li><code>'c'</code> (cyan), <code>'m'</code> (magenta), <code>'y'</code> (yellow)</li>
<li><code>'k'</code> (black) and <code>'w'</code> (white)</li>
</ul>

<p>The markers are:</p>
<ul>
<li><code>'.'</code> (point marker), <code>','</code> (pixel marker), <code>'*'</code> (star marker), <code>'+'</code> (plus marker), <code>'x'</code> (cross marker)</li>
<li><code>'o'</code> (circle marker), <code>'s'</code> (square marker), <code>'h'</code> (hexagon1 marker), <code>'H'</code> (hexagon2 marker), <code>'d'</code> (thin-diamond marker), <code>'D'</code> (diamond marker)</li>
<li><code>'v'</code> (triangle-down marker), <code>'^'</code> (triangle-up marker), <code>'&lt;'</code> (triangle-left marker), <code>'&gt;'</code> (triangle-right marker)</li>
<li><code>'1'</code> (triangle-down marker), <code>'2'</code> (triangle-up marker), <code>'3'</code> (triangle-left marker), <code>'4'</code> (triangle-right marker)</li>
<li><code>'|'</code> (vline marker), <code>'_'</code> (hline marker)</li>
</ul>

<p>The line styles are:</p>
<ul>
<li><code>'-'</code> or 'solid'</li>
<li><code>'--'</code> or 'dashed'</li>
<li><code>'-.'</code> or 'dashdot'</li>
<li><code>':'</code> or 'dotted'</li>
</ul>

<h5>Setting Line's Properties</h5>

<p>The function <code>plot()</code> returns a <code>list</code> of <code>Line2D</code> objects (see above examples), which has these attributes:</p>

<ul>
<li><code>color</code> (or <code>c</code>)</li>

<li><code>marker</code>, <code>markersize</code> (or <code>ms</code>), <code>markerfacecolor</code> (or <code>mfc</code>), <code>markeredgecolor</code> (or <code>mec</code>), <code>markeredgewidth</code> (or <code>mew</code>)</li>

<li><code>linestyle</code> (or <code>ls</code>), <code>linewidth</code> (or <code>lw</code>)</li>

<li>others</li>
</ul>


<p>You can set the line's properties:</p>

<ol>
<li>Using keyword arguments of <code>plot()</code>, e.g.,
  <pre class="color-example">
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5], [5, 1, 2, 4, 3],
        color='green', marker='o', markerfacecolor='blue', markersize=12, linestyle='dashed')</strong>
&gt;&gt;&gt; <strong>plt.show()</strong></pre>
</li>

<li>Using <code>Line2D</code>'s Setters <code>set_xxx()</code> for each property, e.g.,
<pre class="color-example">
&gt;&gt;&gt; <strong>line, = plt.plot([1, 2, 3, 4, 5], [5, 1, 2, 4, 3])</strong>
        <span class="color-comment"># plot() returns a list of Line2D objects - an one-item list in this plot
        # Retrieve a reference to the Line2D by unpack an one-item list</span>
&gt;&gt;&gt; <strong>line.set_color('y')</strong>       <span class="color-comment"># same as line.set_color('yellow')</span>
&gt;&gt;&gt; <strong>line.set_linestyle('-.')</strong>  <span class="color-comment"># same as line.set_linestyle('dashdot')</span>
&gt;&gt;&gt; <strong>line.set_marker('*')</strong>      <span class="color-comment"># star marker</span>
&gt;&gt;&gt; <strong>plt.show()</strong></pre>
</li>

<li>Using <code>setp()</code> (set property) function, e.g.,
  <pre class="color-example">
&gt;&gt;&gt; <strong>lines = plt.plot([1, 2, 3, 4, 5], [5, 1, 2, 4, 3], [1, 2, 3, 4, 5], [2, 4, 6, 3, 4])</strong>  <span class="color-comment">  # 2-item list</span>
&gt;&gt;&gt; <strong>lines</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;, &lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>plt.setp(lines, color='r', marker='+') </strong>  <span class="color-comment"># Applicable to single line or list of lines</span>
[None, None, None, None]
&gt;&gt;&gt; <strong>plt.show()</strong></pre>
</li>
</ol>


<h4>Working with Texts</h4>

<p>The following  functions returns a <code>Text</code> object:</p>
<ul>
<li><code>title(str)</code>: Set title</li>
<li><code>xlabel(str)</code>, <code>ylabel(str)</code>: Set <code>x</code>-axis and <code>y</code>-axis labels</li>
<li><code>text(xPos, yPos, str)</code>: Draws <code>str</code> at <code>(xPos, yPos)</code>.</li>
<li><code>annotate(str, xy=(x, y), xytext=(x, y))</code>: Annotate for the point at <code>xy</code>, with <code>str</code> placed at <code>xytext</code>, with an optional arrow.</li>
</ul>

<p>You can include optional keyword arguments in the above functions, such as <code>fontsize</code>, <code>color</code>, etc.</p>

<h5>Example: <span class="font-code">text()</span> and <span class="font-code">annotate()</span></h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>x = range(1, 6)</strong>   <span class="color-comment"># [1, 2, 3, 4, 5]
</span>&gt;&gt;&gt; <strong>y = [5, 2, 4, 1, 6]</strong>
&gt;&gt;&gt; <strong>ytexts = ['First', 'Second', 'Third', 'Fourth', 'Fifth']</strong>
&gt;&gt;&gt; <strong>plt.plot(x, y, 'ro-')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
<span class="color-comment"># Put up text via text() on top of each of the data point</span>
&gt;&gt;&gt; <strong>for i in range(len(x)):
        plt.text(x[i], y[i]+0.1, ytexts[i], horizontalalignment='center', verticalalignment='bottom')</strong>
Text(1,5,'First')
Text(2,2,'Second')
......
<span class="color-comment"># Annotate third point, draw an arrow from xy to xytext</span>
&gt;&gt;&gt; <strong>plt.annotate('Annotate Third', xy=(x[2], y[2]), xytext=(x[2]+0.5, y[2]+1),
        arrowprops={'facecolor':'black', 'shrink':0.05, 'width':1})</strong>
Text(3.5,5,'Annotate Third')
&gt;&gt;&gt; <strong>plt.show()</strong></pre>

<h4>Logarithmic and Non-Linear Axis</h4>

<ul>
<li><code>xscale(<em>scale</em>)</code>, <code>yscale(<em>scale</em>)</code>: the available <code><em>scale</em></code>s are <code>'linear'</code>, <code>'log'</code>, <code>'symlog'</code> (symmetric log).</li>
</ul>

<p>[TODO] Examples</p>

<h4>Saving the Figures: <span class="font-code">savefig()</span></h4>

<pre class="color-syntax">
&gt;&gt;&gt; <strong>help(plt.savefig)</strong>
savefig(fname, dpi=None, facecolor='w', edgecolor='w', orientation='portrait', 
        papertype=None, format=None, transparent=False, bbox_inches=None, 
        pad_inches=0.1, frameon=None)</pre>

<p>The output file formats including PNG, PDF, SVG, EPS, set via keyword <code>format=xxx</code>.</p>

<p>For example,</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>plt.plot([1, 2, 3, 4, 5], [5, 2, 4, 3, 2], 'ro-')</strong>
[&lt;matplotlib.lines.Line2D object at ...&gt;]
&gt;&gt;&gt; <strong>plt.savefig('test.pdf', dpi=600, format='pdf')</strong>
&gt;&gt;&gt; <strong>plt.savefig('test.png', dpi=600, format='png')</strong>
&gt;&gt;&gt; <strong>plt.show()</strong>  <span class="color-comment"># You cannot issue show() before savefig(),
                # as show() clears the figure and free the memory</span></pre>


<h4>Configuration File &quot;<span class="font-code">matplotlibrc</span>&quot;</h4>

<p>You can configure Matplotlib via configuration file &quot;<code>matplotlibrc</code>&quot;.</p>

<p>You can check the location of  &quot;<code>matplotlibrc</code>&quot; via:</p>
<pre class="color-command">
&gt;&gt;&gt; <strong>import matplotlib</strong>
&gt;&gt;&gt; <strong>matplotlib.matplotlib_fname()</strong>
......</pre>
<p>[TODO]</p>

<h3 id="numpy">NumPy</h3>

<p>References:</p>
<ol>
<li>NumPy mother site @ <a href="http://www.numpy.org/">http://www.numpy.org/</a>.</li>
<li>NumPy User Guide @ <a href="http://docs.scipy.org/doc/numpy-dev/user/">http://docs.scipy.org/doc/numpy-dev/user/</a></li>
</ol>

<br />
<p>NumPy (which stands for Numerical Python @ <a href="http://www.numpy.org/">http://www.numpy.org/</a>) is the foundation library for scientific computing in
Python. It provides data structures and high-performance functions that the standard Python
does not provide. NumPy defines a data structure called <code>ndarray</code> which is an N-dimensional array to support matrix operations, basic linear algebra, basic statistical operations, Fourier transform, random number capabilities and much more. NumPy uses pre-compiled numerical routines (most of them implemented in C code) for high-performance operations. It also supports vector (or parallel) computations.</p> 

<h4>The <span class="font-code">numpy</span> Package</h4>

<p>NumPy is distributed in Python package <code>numpy</code>. You need to import the package:</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>import numpy as np</strong></pre>

<h4>The <span class="font-code">numpy.ndarray</span> Class</h4>

<p>At the core of NumPy is a class called <code>ndarray</code> for modeling homogeneous n-dimensional arrays and matrices.  Unlike Python's normal array <code>list</code>, but like C/C++/Java's array:</p>
<ul>
<li><code>ndarray</code> has a <em>fixed size</em> at creation.</li>
<li><code>ndarray</code> contains elements of the <em>same</em> data type.</li>
</ul>
<p>The <code>ndarray</code> has these attributes:</p>

<ul>
<li><span class="font-code line-heading">ndarray.dtype</span>: data type of  the elements. Recall that <code>ndarray</code> contains elements of the same type (unlike Python's array <code>list</code>). You can use the Python built-in  types such as <code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code> and <code>complex</code>; or the NumPy's types, such as <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>, with the specified bit-size.</li>

<li><span class="font-code line-heading">ndarray.shape</span>: a tuple of n positive integers <code>(d0, d1, ..., dn-1)</code> that specifies the size for each dimension. E.g., for a 2D matrix with <code>n</code> rows and <code>m</code> columns, <code>shape</code> is a tuple <code>(n, m)</code>.<br />
  In Numpy, dimensions are called <em>axes</em>. (NumPy dimension is different from the Mathematical dimension!) The number of axes is <em>rank</em>. The length of <code>axis-0</code> is <code>d0</code>, the length of <code>axis-1</code> is <code>d1</code>, and so on.</li>

<li><span class="font-code line-heading">ndarray.ndim</span>: rank (number of axes, length of <code>shape</code>). NumPy's rank is different from Linear Algebra's rank (number of independent vectors)!</li>
<li><span class="font-code line-heading">ndarray.size</span>: total number of elements, same as the product of <code>shape</code>.</li>
<li><span class="font-code line-heading">ndarray.itemsize</span>: size in bytes of each element (all elements have the same type).</li>
<li><span class="font-code line-heading">ndarray.data</span>: the buffer containing the actual elements.</li>
</ul>

<h4>Creating an <span class="font-code">ndarray</span> and Checking its Attributes</h4>

<p>There are a few ways to create a NumPy's <code>ndarray</code>.</p>

<h5>Creating an Array 1: <span class="font-code">numpy.array(lst, [dtype=None]) -&gt; ndarray</span></h5>

<p>You can use the NumPy's function <code>array()</code> to create and initialize an <code>ndarray</code> object from a Python's <code>list/tuple</code>. You can use the optional keyword argument <code>dtype</code> to specify the data type instead of taking the default data type.</p>
<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>import numpy as np</strong>
&gt;&gt;&gt; <strong>help(np.array)</strong>
......

<span class="color-comment"># Create an 1D int ndarray and check its properties</span>
&gt;&gt;&gt; <strong>m1 = np.array([11, 22, 33])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([11, 22, 33])  <span class="color-comment"># ndarray is printed with prefix array()</span>
&gt;&gt;&gt; <strong>type(m1)</strong>
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; <strong>m1.shape</strong>    <span class="color-comment"># dimension</span>
(3,)            <span class="color-comment"># shape is a tuple of dimensions</span>
&gt;&gt;&gt; <strong>m1.dtype</strong>    <span class="color-comment"># data type</span>
dtype('int32')
&gt;&gt;&gt; <strong>m1.itemsize</strong>
4               <span class="color-comment"># 4 bytes (32 bits) for int32</span>
&gt;&gt;&gt; <strong>m1.ndim</strong>     <span class="color-comment"># rank (number of axes)</span>
1
&gt;&gt;&gt; <strong>m1.size</strong>     <span class="color-comment"># total number of elements</span>
3
&gt;&gt;&gt; <strong>m1.data</strong>
&lt;memory at ...&gt;

<span class="color-comment"># Create an 1D float ndarray</span>
&gt;&gt;&gt; <strong>m2 = np.array([1.1, 2.2, 3])</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([1.1, 2.2, 3. ])
&gt;&gt;&gt; <strong>m2.dtype</strong>
dtype('float64')  <span class="color-comment"># default floats are float64</span>

<span class="color-comment"># Create an 1D complex ndarray with keyword dtype</span>
&gt;&gt;&gt; <strong>m3 = np.array([1, 2.2, 3], dtype=complex)</strong>
&gt;&gt;&gt; <strong>m3</strong>
array([ 1.0+0.j,  2.2+0.j,  3.0+0.j])
&gt;&gt;&gt; <strong>m3.dtype</strong>
dtype('complex128')

<span class="color-comment"># Create an 1D string ndarray</span>
&gt;&gt;&gt; <strong>m4 = np.array(['a', 'bb', 'ccc'])</strong>
&gt;&gt;&gt; <strong>m4</strong>
array(['a', 'bb', 'ccc'], dtype='&lt;U3')   <span class="color-comment"># little-endian Unicode 3-character string</span>
&gt;&gt;&gt; <strong>m4.dtype</strong>
dtype('&lt;U3')

&gt;&gt;&gt; <strong>m5 = np.array((11, 22, 33))</strong>   <span class="color-comment"># Can also use a tuple</span>
&gt;&gt;&gt; <strong>m5</strong>
array([11, 22, 33])

<span class="color-comment"># Create a 2D ndarray with a list of lists</span>
<span class="color-comment"></span>&gt;&gt;&gt; <strong>m6 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m6</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>m6.shape</strong>  <span class="color-comment"># dimensions</span>
(2, 3)        <span class="color-comment"># rows, columns</span>
&gt;&gt;&gt; <strong>m6.ndim</strong>   <span class="color-comment"># number of dimensions, or rank, or number of axes</span>
2

<span class="color-comment"># Can also use a list of mixture of tuples and lists</span>
&gt;&gt;&gt; <strong>m7 = np.array([(1, 2), [3, 4], (5, 6)], dtype=float)</strong>
&gt;&gt;&gt; <strong>m7</strong>
array([[1., 2.],
       [3., 4.],
       [5., 6.]])
&gt;&gt;&gt; <strong>m7.dtype</strong>
dtype('float64')
&gt;&gt;&gt; <strong>m7.shape</strong>
(3, 2)
&gt;&gt;&gt; <strong>m7.ndim</strong>
2     <span class="color-comment"># rank (2 axes)</span></pre>

<h5>NumPy's Data Types</h5>

<p>NumPy supports Python's built-in data types (such as <code>int</code>, <code>float</code>, <code>bool</code>, <code>complex</code>, and <code>str</code>). It also introduces its own scalar data types:</p>

<ul>
<li>Signed Integers: <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>int_</code> (default integer type, same as C's <code>long</code>, normally either <code>int64</code> or <code>int32</code>), <code>intc</code> (same as C's <code>int</code>), intp (integers used for indexing, same as C's <code>ssize_t</code>, normally either <code>int32</code> or <code>int64</code>)</li>
<li>Unsigned Integers: <code>uint8</code>, <code>uint16</code>, <code>unit32</code>, <code>uint64</code></li>
<li>Floating-point numbers: <code>float16</code>, <code>float32</code>, <code>float64</code>, <code>float_</code> (default, same as <code>float64</code>)</li>
<li>Boolean: <code>bool_</code> (<code>True</code> or <code>False</code>)</li>
<li>Complex numbers: <code>complex64</code>, <code>complex128</code>, <code>complex_</code> (default, same as <code>complex128</code>)</li>
<li>Strings: <code>str</code>, <code>unicode</code>, <code>unicode_</code></li>
</ul>

<h5>Creating an Array 2:</h5>
<p><span class="font-code line-heading">numpy.ones(shape) -&gt; ndarray</span>: Return a new array of the given <code>shape</code>, filled with 1.<br />
<span class="font-code line-heading">numpy.zeros(shape) -&gt; ndarray</span>: Return a new array of the given <code>shape</code>, filled with 0.<br />
<span class="font-code line-heading">numpy.empty(shape) -&gt; ndarray</span>: Return a new array of the given <code>shape</code>, uninitialized.<br />
<span class="font-code line-heading">numpy.full(shape, fill_value) -&gt; ndarray</span>: Return a new array of the given <code>shape</code>, filled with <code>fill_value</code>.<br />
<span class="font-code line-heading">numpy.diag(lstDiag) -&gt; ndarray</span>: Return a new array with the given diagonal elements.<br />
<span class="font-code line-heading">numpy.ones_like(a) -&gt; ndarray</span>: Return a new array of the same shape and type as <code>a</code>, filled with 1.<br />
<span class="font-code line-heading">numpy.zeros_like(a) -&gt; ndarray</span>: Return a new array of the same shape and type as <code>a</code>, filled with 0.<br />
<span class="font-code line-heading">numpy.empty_like(a) -&gt; ndarray</span>: Return a new array of the same shape and type as <code>a</code>, uninitialized.<br />
<span class="font-code line-heading">numpy.full_like(a, fill_value) -&gt; ndarray</span>: Return a new array of the same shape and type as <code>a</code>, filled with <code>fill_value</code>.</p>

<p>The function <code>ones()</code> and <code>zeros()</code> create an array full of ones and zeros respectively. The <code>empty()</code> creates a new array of given shape and type, without initializing entries. The default type is <code>float64</code>, unless overridden with keyword <code>dtype</code>. For example,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>import numpy as np</strong>
&gt;&gt;&gt; <strong>help(np.ones)</strong>
&gt;&gt;&gt; <strong>m1 = np.ones((3, 5))</strong>  <span class="color-comment"># takes a shape tuple in row-major order</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.],
       [ 1.,  1.,  1.,  1.,  1.]])
&gt;&gt;&gt; <strong> m1.dtype</strong>
dtype('float64')

&gt;&gt;&gt; <strong>help(np.zeros)</strong>
&gt;&gt;&gt; <strong>m2 = np.zeros((2, 3, 4), dtype=np.int32)</strong>   <span class="color-comment"># 3D array</span>
&gt;&gt;&gt; <strong>m2</strong>
array([[[0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]],

       [[0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]]])
&gt;&gt;&gt; <strong>m2.dtype</strong>
dtype('int32')

&gt;&gt;&gt; <strong>help(np.full)</strong>
&gt;&gt;&gt; <strong>m3 = np.full((2, 5), 99)</strong>
&gt;&gt;&gt; <strong>m3</strong>
array([[99, 99, 99, 99, 99],
       [99, 99, 99, 99, 99]])

&gt;&gt;&gt; <strong>help(np.empty)</strong>
&gt;&gt;&gt; <strong>m4 = np.empty((2, 3, 2, 2))</strong>   <span class="color-comment"># A 4D array</span>
&gt;&gt;&gt; <strong>m4</strong>
array([[[[4.65302447e-312, 0.00000000e+000],   <span class="color-comment"># Contents not initialized</span>
         [0.00000000e+000, 1.53527001e-311]],

        [[0.00000000e+000, 1.00000000e+000],
         [0.00000000e+000, 0.00000000e+000]],

        [[1.00000000e+000, 0.00000000e+000],
         [0.00000000e+000, 0.00000000e+000]]],


       [[[0.00000000e+000, 1.00000000e+000],
         [1.01007000e-311, 0.00000000e+000]],

        [[2.49009086e-321, 4.94065646e-324],
         [0.00000000e+000, 1.53526866e-311]],

        [[1.53526866e-311, 0.00000000e+000],
         [0.00000000e+000, 0.00000000e+000]]]])
&gt;&gt;&gt; <strong>m4.dtype</strong>
dtype('float64')

&gt;&gt;&gt; <strong>help(np.diag)</strong>
&gt;&gt;&gt; <strong>m5 = np.diag([11, 22, 33])</strong>   <span class="color-comment"># Create a diagonal 2D array</span>
&gt;&gt;&gt; <strong>m5</strong>
array([[11,  0,  0],
       [ 0, 22,  0],
       [ 0,  0, 33]])

&gt;&gt;&gt; <strong>help(np.zeros_like)</strong>
&gt;&gt;&gt; <strong>m6 = np.zeros_like(m5)</strong>  <span class="color-comment"># Same shape and type</span>
&gt;&gt;&gt; m6
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
&gt;&gt;&gt; <strong>m6.dtype</strong>
dtype('int32')</pre>

<h5>Creating an Array 3:<br />
<span class="font-code">numpy.arange([start=0], stop, [step=1]) -&gt; ndarray_1D</span><br />
<span class="font-code">numpy.linspace(start, stop, num) -&gt; ndarray_1D</span><br />
<span class="font-code">ndarray.reshape(newShape)</span></h5>

<p>NumPy provides a function <code>numpy.arange(start, stop, step)</code> to create a 1D <code>ndarray</code> in the range of <code>[<em>start</em>, <em>stop</em>)</code>, analogous to Python's <code>range(start, stop, step)</code> built-in function. Unlike <code>range()</code> which accepts only <code>int</code>, you can use <code>float</code> for <code>start</code>, <code>stop</code> and <code>step</code> in <code>arange()</code>. For examples,</p>

<pre class="color-example"><span class="color-comment"># Using arange() to create a 1D ndarray</span>
&gt;&gt;&gt; <strong>help(np.arange)</strong>
&gt;&gt;&gt; <strong>m1 = np.arange(1, 11)</strong>  <span class="color-comment"># start included, stop excluded</span>
&gt;&gt;&gt; <strong>m1</strong>
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
&gt;&gt;&gt; <strong>m1.dtype</strong>
dtype('int32')

&gt;&gt;&gt; <strong>m2 = np.arange(5)</strong>   <span class="color-comment"># default start is 0, step is 1</span>
&gt;&gt;&gt; <strong>m2</strong>
array([0, 1, 2, 3, 4])

<span class="color-comment"># Use float for start, stop, step</span>
&gt;&gt;&gt; <strong>m3 = np.arange(1.5, 8.5)</strong>
&gt;&gt;&gt; <strong>m3</strong>
array([1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5])
&gt;&gt;&gt; <strong>m4 = np.arange(1, 10, 0.8)</strong>
&gt;&gt;&gt; <strong>m4</strong>
array([1. , 1.8, 2.6, 3.4, 4.2, 5. , 5.8, 6.6, 7.4, 8.2, 9. , 9.8])

<span class="color-comment"># But Python's range() only takes int</span>
&gt;&gt;&gt; <strong><span class="color-error">a1 = range(1.5, 8.5)</span></strong>
TypeError: 'float' object cannot be interpreted as an integer</pre>

<p>You can then use <em><code>ndarray</code></em><code>.reshape(<em>newShape</em>)</code> to reshape the 1D to N-D <code>ndarray</code>. For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>help(np.reshape)</strong>
<span class="color-comment"># Reshape the 1D ndarray into 2D</span>
&gt;&gt;&gt; <strong>m5 = np.arange(10).reshape(2, 5)</strong>
&gt;&gt;&gt; <strong>m5</strong>
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

<span class="color-comment"># One newShape dimension can be -1. In this case, the value is
#  inferred from the length of the array and remaining dimensions.</span>
&gt;&gt;&gt; m6 = m5.reshape(1, -1)
&gt;&gt;&gt; m6
array([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])</pre>


<p>NumPy also provides a similar function called <code>numpy.linspace(start, stop, num)</code> to create a evenly-spaced (linearly-spaced) 1D <code>float</code> ndarray in the interval <code>[start, stop]</code>. By default, stop is included. But you can exclude it via keyword <code>endpoint=False</code>. The <code>linspace()</code> takes the number of points, instead of step size for <code>arange()</code>.</p>
<p>For example,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>help(np.linspace)</strong>
&gt;&gt;&gt; <strong>m1 = np.linspace(1, 2, 10)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([ 1.        ,  1.11111111,  1.22222222,  1.33333333,  1.44444444,
        1.55555556,  1.66666667,  1.77777778,  1.88888889,  2.        ])
&gt;&gt;&gt; <strong>m1.dtype</strong>
dtype('float64')
&gt;&gt;&gt; <strong>m2 = np.linspace(1, 2, 10, endpoint=False)</strong>  <span class="color-comment"># Exclude end-point</span>
&gt;&gt;&gt; <strong>m2</strong>
array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9])
&gt;&gt;&gt; <strong>m3 = np.linspace(1, 10, 10, dtype=int)</strong>      <span class="color-comment"># Set data type</span>
&gt;&gt;&gt; <strong>m3</strong>
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
&gt;&gt;&gt; <strong>m4 = np.linspace(1, 10, 10).reshape(2, 5)</strong>
&gt;&gt;&gt; <strong>m4</strong>
array([[ 1.,  2.,  3.,  4.,  5.],
       [ 6.,  7.,  8.,  9., 10.]])
<span class="color-comment"># From -pi to pi (both included) in degree resolution
# linspace() could be more convenience than arange()</span>
&gt;&gt;&gt; <strong>m5 = np.linspace(-np.pi, np.pi, 361)</strong>
&gt;&gt;&gt; m5
array([-3.14159265, .... 3.14159265])</pre>

<h5>Creating an Array 4: Creating Random Array via the <span class="font-code">numpy.random.xxx() -&gt; ndarray</span></h5>

<p>The <code>numpy.random</code> module supports random number generation. You can draw samples from commonly-used distributions like Uniform, Normal (Gaussian), Binomial and Poisson.</p>
<ul>
<li><span class="line-heading">Uniformly Distributed</span>:<br />
<span class="font-code line-heading">numpy.random.rand(d0, d1, ..., dn-1) -&gt; ndarray</span>: Uniformly distributed floats in <code>[0.0, 1.0)</code>, providing the dimensions.<br />
<span class="font-code line-heading">numpy.random.random(size=None) -&gt; ndarray</span>: Uniformly distributed floats in <code>[0.0, 1.0)</code>, providing the <code>size</code> in scalar or <code>shape</code> in tuple.<br />
<span class="font-code line-heading">numpy.random.random_sample(size=None) -&gt; ndarray</span>: same as above.<br />
<span class="font-code line-heading">numpy.random.uniform(low=0.0, high=1.0, size=None) -&gt; ndarray</span>: Uniformly distributed floats in <code>[low, high)</code>.<br />
<span class="font-code line-heading">numpy.random.randint(low, high=None, size=None) -&gt; ndarray</span>: Uniformly distributed integers between <code>[low, high)</code>
<pre class="color-example">
&gt;&gt;&gt; <strong>help(np.random.rand)</strong>
&gt;&gt;&gt; <strong>m1 = np.random.rand(2, 3)</strong>   <span class="color-comment"># Specify the dimensions</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[0.57877041, 0.93898599, 0.15998744],
       [0.5195182 , 0.79441764, 0.47046495]])
&gt;&gt;&gt; <strong>m1.dtype</strong>
dtype('float64')

&gt;&gt;&gt; <strong>help(np.random.random)</strong>
&gt;&gt;&gt; <strong>m2 = np.random.random()</strong>   <span class="color-comment"># One sample (default)</span>
&gt;&gt;&gt; <strong>m2</strong>
0.8530312529958475   <span class="color-comment"># Scalar, NOT array</span>
&gt;&gt;&gt; <strong>m3 = np.random.random(5)</strong>  <span class="color-comment"># 1D ndarray</span>
&gt;&gt;&gt; <strong>m3</strong>
array([ 0.31007576,  0.21615439,  0.26983623,  0.44427757,  0.35548085])
&gt;&gt;&gt; <strong>m4 = np.random.random((2, 4))</strong>  <span class="color-comment"># ndarray of given shape</span>
&gt;&gt;&gt; <strong>m4</strong>
array([[ 0.45519034,  0.97199324,  0.49615973,  0.5377464 ],
       [ 0.1057191 ,  0.900195  ,  0.7685127 ,  0.23238175]])

&gt;&gt;&gt; <strong>help(np.random.uniform)</strong>
&gt;&gt;&gt; <strong>m5 = np.random.uniform(5, 10, (2, 4))</strong>   <span class="color-comment"># low, high, shape</span>
&gt;&gt;&gt; <strong>m5</strong>
array([[8.39092855, 5.95135548, 7.21166273, 6.46086279],
       [9.7510942 , 5.99099363, 9.9313887 , 6.75191231]])

&gt;&gt;&gt; <strong>help(np.random.randint)</strong>
&gt;&gt;&gt; <strong>m6 = np.random.randint(1, 101, (2, 4))</strong>
&gt;&gt;&gt; <strong>m6</strong>
array([[68, 97, 84, 55],
       [49, 57, 28, 87]])
&gt;&gt;&gt; <strong>m7 = np.random.randint(1, 101, 10)</strong>
&gt;&gt;&gt; <strong>m7</strong>
array([37, 34, 57, 60, 26, 34, 46, 73, 59, 96])
&gt;&gt;&gt; <strong>m8 = np.random.randint(50, size=(2, 5))</strong>   <span class="color-comment"># [0, 50)</span>
&gt;&gt;&gt; <strong>m8</strong>
array([[16, 48,  9,  3, 22],
       [19, 20, 16, 17, 11]])</pre></li>

<li><span class="line-heading">Normal (Gaussian) Distributed</span>:<br />
<span class="font-code line-heading">numpy.random.randn(d0, d1, ..., dn-1) -&gt; ndarray</span>: Standard normal distribution (mean=0, standard deviation=1), providing the dimensions.<br />
<span class="font-code line-heading">numpy.random.normal(loc=0.0, scale=1.0, size=None) -&gt; ndarray</span>: Normal (Gaussian) distribution, with mean <code>loc</code> and standard deviation <code>scale</code>.
<pre class="color-example">
&gt;&gt;&gt; <strong>help(np.random.randn)</strong>
&gt;&gt;&gt; <strong>m1 = np.random.randn(2, 5)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[-0.36150823, -2.02660018, -0.38235962,  0.64032599,  0.23108273],
       [-0.31966815,  1.3190811 ,  0.49096282,  0.01427582, -1.35702935]])

&gt;&gt;&gt; <strong>help(np.random.normal())</strong>
&gt;&gt;&gt; <strong>m2 = np.random.normal()</strong>
&gt;&gt;&gt; <strong>m2</strong>
-0.355415080976361   <span class="color-comment"># Scalar, NOT array</span>
&gt;&gt;&gt; <strong>m3 = np.random.normal(size=10)</strong>
&gt;&gt;&gt; <strong>m3</strong>
array([-0.78298485,  0.53316234,  0.07914094,  0.88850953,  1.05475548,
        0.84182328,  0.0081135 , -0.28555631, -0.04288513, -0.36058967])
&gt;&gt;&gt; <strong>m4 = np.random.normal(size=(2, 3))</strong>
&gt;&gt;&gt; <strong>m4</strong>
array([[-1.24201626, -0.66748844,  0.3602864 ],
       [-0.97706347,  1.02509533,  0.08946322]])

&gt;&gt;&gt; <strong>m5 = np.random.normal(50, 15, 10)</strong>
&gt;&gt;&gt; <strong>m5</strong>
array([ 49.57202009,  57.63097904,  51.33961472,  22.0570641 ,
        65.46613523,  35.14129408,  61.97144885,  56.32118504,
        75.82942142,  40.70516785])
&gt;&gt;&gt; <strong>m6 = np.random.normal(5, 2, (2, 4))</strong>
>>> <strong>m6</strong>
array([[5.09802446, 1.74155424, 3.87027413, 3.87650247],
       [5.50037146, 6.61549043, 6.9740259 , 5.04622304]])</pre>
</li>

<li><span class="line-heading">Binomial Distributed</span>:<br />
<span class="font-code line-heading">numpy.random.binomial(n, p, size=None) -&gt; ndarray</span>: Binomial distribution for <code>n</code> trials with <code>p</code> probability of success.
  <pre class="color-example">
&gt;&gt;&gt; <strong>help(np.random.binomial)</strong>
&gt;&gt;&gt; <strong>m1 = np.random.binomial(1, 0.5, 10)</strong>  <span class="color-comment"># 5 trials, probability of success is 0.5</span>
&gt;&gt;&gt; <strong>m1</strong>
array([1, 1, 1, 1, 0, 1, 0, 1, 1, 1])
&gt;&gt;&gt; <strong>m2 = np.random.binomial(5, 0.2, (2, 4))</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[2, 0, 0, 0],
       [1, 1, 1, 2]])</pre></li>

<li><span class="line-heading">Poisson Distributed</span>:<br />
<span class="font-code line-heading">numpy.random.poisson(lam=1.0, size=None) -&gt; ndarray</span>: Poisson distribution with parameter <code>lambda</code>.
  <pre class="color-example">
&gt;&gt;&gt; <strong>help(np.random.poisson)</strong>
&gt;&gt;&gt; <strong>m1 = np.random.poisson(1, 15)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([2, 2, 2, 2, 0, 1, 2, 1, 0, 1, 0, 0, 3, 0, 0])
&gt;&gt;&gt; <strong>m2 = np.random.poisson(5, (2, 5))</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[ 4,  6,  5, 11,  5],
       [ 7,  4,  3,  7,  7]])</pre></li>

<li><span class="line-heading">Permutation:</span> <span class="font-code line-heading">numpy.random.permutation(x) -&gt; ndarray</span>
<pre class="color-example">
<span class="color-comment"># If x is an integer, randomly permutate np.arange(x)</span>
&gt;&gt;&gt; <strong>np.random.permutation(10)</strong>
array([0, 8, 2, 5, 3, 6, 7, 9, 1, 4])

<span class="color-comment"># If x is a 1D array, randomly permutate the array</span>
&gt;&gt;&gt; <strong>np.random.permutation([1, 3, 8, 11, 15])</strong>
array([ 8,  3, 11, 15,  1])

<span class="color-comment"># If x is a multi-dimensional array, randomly permutate along the first axis</span>
&gt;&gt;&gt; <strong>m1 = np.arange(12).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
&gt;&gt;&gt; <strong>np.random.permutation(m1)</strong>  <span class="color-comment"># Return a new array</span>
array([[ 8,  9, 10, 11],
       [ 4,  5,  6,  7],
       [ 0,  1,  2,  3]])</pre>
</li>
</ul>

<h4>Accessing the <span class="font-code">ndarray</span></h4>

<h5>Accessing the <span class="font-code">ndarray</span> 1: Multi-Dimensional Indexing <span class="font-code">[i, j, ...]</span> and Slicing <span class="font-code">[m1:n1:step1, m2:n2:step2, ...]</span></h5>

<p>You can apply indexing and slicing to NumPy's <code>ndarray</code>, similar to Python's array <code>list</code>, but extended to multi-dimensional.</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(1, 13).reshape(3, 4)</strong>   <span class="color-comment"># 2D</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; <strong>m1.shape</strong>
(3, 4)

<span class="color-comment"># 2D Indexing a specific element</span>       
&gt;&gt;&gt; <strong>m1[0, 2]</strong>
3
&gt;&gt;&gt; <strong>m1[0, -1]</strong>   <span class="color-comment"># Can use negative index starting from the end</span>
4

<span class="color-comment"># 2D Slicing</span>
&gt;&gt;&gt; <strong>m1[0]</strong>   <span class="color-comment"># Same as m1[0, :] or m1[0, 0:m1.shape[1]]
            # Missing trailing index same as : (all elements)</span>
array([1, 2, 3, 4])
&gt;&gt;&gt; <strong>m1[0, :]</strong>     <span class="color-comment"># Same as above</span>
array([1, 2, 3, 4])
&gt;&gt;&gt; <strong>m1[:, 0]</strong>     <span class="color-comment"># Same as m1[0:m1.shape[0], 0]</span><br />array([1, 5, 9]) <span class="color-comment"># Column becomes row</span>
&gt;&gt;&gt; <strong>m1[-1]</strong>       <span class="color-comment"># Can use negative index, same as m1[-1, :]</span>
array([ 9, 10, 11, 12])
&gt;&gt;&gt; <strong>m1[:, -1]</strong>
array([ 4,  8, 12])
&gt;&gt;&gt; <strong>m1[0, 1:]</strong>
array([2, 3, 4])
&gt;&gt;&gt; <strong>m1[0:2, 1:3]</strong>
array([[2, 3],
       [6, 7]])
&gt;&gt;&gt; <strong>m1[0:2, 0:3:2]</strong>
array([[1, 3],
       [5, 7]])
&gt;&gt;&gt; <strong>m1[::2, ::2]</strong>   <span class="color-comment"># Alternate rows and columns</span>
array([[ 1,  3],
       [ 9, 11]])

<span class="color-comment"># You can use negative step size to reverse the slice (similar to Python's array list)</span>
&gt;&gt;&gt; <strong>m1[::-1]</strong>
array([[ 9, 10, 11, 12],
       [ 5,  6,  7,  8],
       [ 1,  2,  3,  4]])
&gt;&gt;&gt; <strong>m1[::-1, ::-1]</strong>
array([[12, 11, 10,  9],
       [ 8,  7,  6,  5],
       [ 4,  3,  2,  1]])
&gt;&gt;&gt; <strong>m1[::-2, ::-2]</strong>
array([[12, 10],
       [ 4,  2]])

<span class="color-comment"># Python's multi-dimensional list is a list of lists, not truly multi-dimensional
# whereas NumPy's ndarray is a true multi-dimensional array with multiple axes.</span>
&gt;&gt;&gt; <strong>lst = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</strong>  <span class="color-comment"># A list of lists</span>
&gt;&gt;&gt; <strong>lst[0]</strong>
[1, 2, 3, 4]    <span class="color-comment"># Element is a list</span>
&gt;&gt;&gt; <span class="color-error"><strong>lst[0, 0]</strong></span>   <span class="color-comment"># not truly 2D</span>
TypeError: list indices must be integers or slices, not tuple
&gt;&gt;&gt; <strong>lst[0][0]</strong>
1
&gt;&gt;&gt; <strong>lst[::2]</strong>
[[1, 2, 3, 4], [9, 10, 11, 12]]
&gt;&gt;&gt; <strong>lst[::2][::2]</strong>
[[1, 2, 3, 4]]</pre>

<h5>Accessing the <span class="font-code">ndarray</span> 2: Indexing with <span class="font-code">list</span></h5>

<p>You can provide a <code>list</code> in indexing (this is not supported in Python's array <code>list</code>). For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(12).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
&gt;&gt;&gt; <strong>m1[:, [1, 3]]</strong>   <span class="color-comment"># Select a list of columns</span>
array([[ 1,  3],
       [ 5,  7],
       [ 9, 11]])
&gt;&gt;&gt; <strong>m1[[0, 1], :]</strong>   <span class="color-comment"># Select a list of rows</span>
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
&gt;&gt;&gt; <strong>m1[[2, 0], :]</strong>   <span class="color-comment"># Select a list of rows and re-arrange</span>
array([[ 8,  9, 10, 11],
       [ 0,  1,  2,  3]])

<span class="color-comment"># Select a list of elements</span>
&gt;&gt;&gt; <strong>m1[[0, 1], [1, 3]]</strong>   <span class="color-comment"># Elements [0, 1] and [1, 3]</span>
array([1, 7])
&gt;&gt;&gt; <strong>m1[[0, 1, 2], [1, 3, 1]]</strong>   <span class="color-comment"># Elements [0, 1], [1, 3] and [2, 1]</span>
array([1, 7, 9])
&gt;&gt;&gt; <span class="color-error">m1[[0, 1], [1, 3, 1]]</span>
IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (3,)</pre>

<h5>Accessing the <span class="font-code">ndarray</span> 3: Filtering (Selection) via a boolean <span class="font-code">list/ndarray</span></h5>
<p>You can filter a NumPy's <code>ndarray</code> with a boolean <code>list</code> or <code>ndarray</code>. This is not supported in Python's <code>list</code>.</p>
<pre class="color-example">
<span class="color-comment"></span>&gt;&gt;&gt; <strong>m1 = np.arange(12).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

<span class="color-comment"># Filtering rows</span>
&gt;&gt;&gt; <strong>m1[[True, False, False]]</strong>   <span class="color-comment"># Filtering rows according to bool value (axis-0)</span>
array([[0, 1, 2, 3]])
&gt;&gt;&gt; <strong>m1[[True, False, True]]</strong>
array([[ 0,  1,  2,  3],
       [ 8,  9, 10, 11]])

<span class="color-comment"># Filtering columns</span>
&gt;&gt;&gt; <strong>m1[:, [True, False, True, False]]</strong>   <span class="color-comment"># Filtering columns (axis-1)</span>
array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])

<span class="color-comment"># Filter elements</span>
&gt;&gt;&gt; <strong>filter = np.array([[True, False, True, False], [True, False, True, False], [True, False, True, False]])</strong>
&gt;&gt;&gt; <strong>filter</strong>
array([[ True, False,  True, False],
       [ True, False,  True, False],
       [ True, False,  True, False]])
&gt;&gt;&gt; <strong>m1[<strong>filter</strong>]</strong>
array([ 0,  2,  4,  6,  8, 10])   <span class="color-comment"># 1D result</span>

&gt;&gt;&gt; <strong>m1 &gt; 6</strong>
array([[False, False, False, False],
       [False, False,  True,  True],
       [ True,  True,  True,  True]])  <span class="color-comment"># result is an ndarray</span>
&gt;&gt;&gt; <strong>m1[m1 &gt; 6]</strong>   <span class="color-comment"># filtering with a boolean ndarray</span>
array([ 7,  8,  9, 10, 11])</pre>

<h4>The <span class="font-code">ndarray</span>'s Operators</h4>

<h5>The Overloaded Element-wise Assignment Operator (<span class="font-code">=</span>) for Multi-dimensional Indexing and Slicing</h5>

<p>The <code>ndarray</code>'s  assignment operator (<code>=</code>) is overloaded to support element-wise assignment for indexing and slicing. This is not supported in Python's <code>list</code>.</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(1, 10).reshape((3, 3))</strong>  <span class="color-comment"># 2D</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

<span class="color-comment"># Assignment via 2D indexing a specific element</span>
&gt;&gt;&gt; <strong>m1[0, 0] = 99</strong>
&gt;&gt;&gt; m1
array([[99,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9]])

<span class="color-comment"># Element-wise Assignment via 2D slicing</span>
&gt;&gt;&gt; <strong>m1[::2, ::2] = 0</strong>   <span class="color-comment"># Alternate rows and columns</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[0, 2, 0],
       [4, 5, 6],
       [0, 8, 0]])

&gt;&gt;&gt; <strong>m1[[True, False, False]] = 88</strong>   <span class="color-comment"># Slicing via bool list on axis-0</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[88, 88, 88],
       [ 4,  5,  6],
       [ 0,  8,  0]])

&gt;&gt;&gt; <strong>m1 = 0</strong>   <span class="color-comment"># But this re-assigns the variable to new value</span>
&gt;&gt;&gt; <strong>m1</strong>
0

<span class="color-comment"># Python's built-in list does not support element-wise assignment for slicing</span>
&gt;&gt;&gt; <strong>lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]</strong>
&gt;&gt;&gt; <strong>lst[0] = 99</strong>     <span class="color-comment"># Supports indexing with assignment</span>
&gt;&gt;&gt; <strong>lst</strong>
[99, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; <strong><span class="color-error">lst[0:2] = 0</span></strong>    <span class="color-comment"># No element-wise slicing assignment</span>
TypeError: can only assign an iterable
&gt;&gt;&gt; <strong>lst[0:2] = [0, 0]</strong>  <span class="color-comment"># Support slicing assignment with list</span>
&gt;&gt;&gt; <strong>lst</strong>
[0, 0, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; <strong>lst[0:2] = [0]</strong>
&gt;&gt;&gt; <strong>lst</strong>
[0, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; <strong>lst = 0</strong>
&gt;&gt;&gt; <strong>lst</strong>
0       <span class="color-comment"># But this re-assigns the variable to scalar 0</span></pre>

<h5>The Overloaded Element-wise Arithmetic Operators (<span class="font-code">+</span>, <span class="font-code">-</span>, <span class="font-code">*</span>, <span class="font-code">/</span>, <span class="font-code">//</span>, <span class="font-code">%</span>, <span class="font-code">**</span>) and Compound Arithmetic Assignment Operators (<span class="font-code">+=</span>, <span class="font-code">-=</span>, <span class="font-code">*=</span>, <span class="font-code">/=</span>, <span class="font-code">//=</span>, <span class="font-code">%=</span>, <span class="font-code">**=</span>)</h5>

<p>The arithmetic operators such as <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, <code>'/'</code>, <code>'//'</code>, <code>'%'</code> and <code>'**'</code> are overloaded to apply element-wise. The compound assignment operators, such as <code>'+='</code> and <code>'-='</code>, are also supported. This is not supported in Python's array <code>list</code>.</p>
<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[1, 2, 3], [4, 5, 6]])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; <strong>m2 = np.array([[11, 12, 13], [14, 15, 16]])</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[11, 12, 13],
       [14, 15, 16]])

<span class="color-comment"># ndarray  ndarray (element-wise)</span>
&gt;&gt;&gt; <strong>m1 + m2</strong>
array([[12, 14, 16],
       [18, 20, 22]])
&gt;&gt;&gt; <strong>m1 - m2</strong>
array([[-10, -10, -10],
       [-10, -10, -10]])
&gt;&gt;&gt; <strong>m1 * m2</strong>   <span class="color-comment"># element-wise multiplication (not matrix multiplication)</span>
array([[11, 24, 39],
       [56, 75, 96]])
&gt;&gt;&gt; <strong>m2 / m1</strong>    <span class="color-comment"># float divide</span> 
array([[ 11.        ,   6.        ,   4.33333333],
       [  3.5       ,   3.        ,   2.66666667]])
&gt;&gt;&gt; <strong>m2 // m1</strong>  <span class="color-comment"># floor integer divide</span>
array([[11,  6,  4],
       [ 3,  3,  2]], dtype=int32)
&gt;&gt;&gt; <strong>m2 % m1</strong>   <span class="color-comment"># modulus (remainder)</span>
array([[0, 0, 1],
       [2, 0, 4]], dtype=int32)
&gt;&gt;&gt; <strong>m2 ** m1</strong>  <span class="color-comment"># exponential (power)</span>
array([[      11,      144,     2197],
       [   38416,   759375, 16777216]], dtype=int32)

<span class="color-comment"># You can also use NumPy's module-level functions instead of the operators:</span>
&gt;&gt;&gt; <strong>np.add(m1, m2)</strong>
array([[12, 14, 16],
       [18, 20, 22]])
&gt;&gt;&gt; <strong>np.subtract(m1, m2)</strong>
array([[-10, -10, -10],
       [-10, -10, -10]])
&gt;&gt;&gt; <strong>np.multiply(m1, m2)</strong>
array([[11, 24, 39],
       [56, 75, 96]])
&gt;&gt;&gt; <strong>np.divide(m2, m1)</strong>
array([[11.        ,  6.        ,  4.33333333],
       [ 3.5       ,  3.        ,  2.66666667]])
&gt;&gt;&gt; <strong>np.floor_divide(m2, m1)</strong>
array([[11,  6,  4],
       [ 3,  3,  2]], dtype=int32)
&gt;&gt;&gt; <strong>np.mod(m2, m1)</strong>
array([[0, 0, 1],
       [2, 0, 4]], dtype=int32)
&gt;&gt;&gt; <strong>np.power(m2, m1)</strong>
array([[      11,      144,     2197],
       [   38416,   759375, 16777216]], dtype=int32)

<span class="color-comment"># ndarray &oplus; scalar (element-wise)</span>
&gt;&gt;&gt; <strong>m1 + 80</strong>
array([[81, 82, 83],
       [84, 85, 86]])

<span class="color-comment"># Compound Arithmetic Assignment Operators (element-wise)</span>
&gt;&gt;&gt; <strong>m1 += m2</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[12, 14, 16],
       [18, 20, 22]])

<span class="color-comment"># Increment/Decrement (element-wise)</span>
&gt;&gt;&gt; <strong>m3 = np.array([[1, 2, 3], [4, 5, 6]])</strong>
&gt;&gt;&gt; <strong>m3</strong>
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; <strong>m3 += 1</strong>   <span class="color-comment"># Python does not support ++, use m3 += 1, or m3 = m3 + 1</span>
&gt;&gt;&gt; m3
array([[2, 3, 4],
       [5, 6, 7]])
&gt;&gt;&gt; <strong>m3 -= 1</strong>
&gt;&gt;&gt; m3
array([[1, 2, 3],
       [4, 5, 6]])

<span class="color-comment"># Python's list does not support element-wise arithmetic operations</span>
&gt;&gt;&gt; <strong>lst1 = [1, 2, 3]</strong>
&gt;&gt;&gt; <strong>lst2 = [4, 5, 6]</strong>
&gt;&gt;&gt; <strong>lst1 + lst2</strong>
[1, 2, 3, 4, 5, 6]   <span class="color-comment"># Concatenation, NOT element-wise addition</span>
&gt;&gt;&gt; <strong><span class="color-error">lst1 * lst2</span></strong>
TypeError: can't multiply sequence by non-int of type 'list'</pre>

<h5>The Overloaded Element-wise Comparison Operators (<span class="font-code">==</span>, <span class="font-code">!=</span>, <span class="font-code">&lt;</span>, <span class="font-code">&gt;</span>, <span class="font-code">&lt;=</span>, <span class="font-code">&gt;=</span>)</h5>       

<p>You can also apply comparison operators, such as <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, element-wise. This is not supported in Python's <code>list</code>.</p>
<p>For example,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[1, 222, 13], [44, 5, 66]])</strong>
&gt;&gt;&gt; <strong>m2 = np.array([[11, 12, 13], [14, 15, 16]])</strong>
&gt;&gt;&gt; <strong>m1 &lt; m2</strong>
array([[ True, False,  False],
       [False,  True, False]])
&gt;&gt;&gt; <strong>m1 == m2</strong>
array([[False, False,  True],
       [False, False, False]])
       
<span class="color-comment"># With Scalar</span>
&gt;&gt;&gt; <strong>m1 == 44</strong>
array([[False, False, False],
       [ True, False, False]])

<span class="color-comment"># Select individual elements based on a boolean ndarray</span>
&gt;&gt;&gt; <strong>m1[m1 &lt; m2]</strong>
array([1, 5])</pre>

<p><span class="font-code line-heading">numpy.any(a, axis=None), ndarray.any(axis=None)</span>: Test if ANY element along a given axis evaluates to <code>True</code>.<br />
<span class="font-code line-heading">numpy.all(a, axis=None), ndarray.all(axis=None)</span>: Test if ALL elements along a given axis evaluates to <code>True</code>.<br />
</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(10).reshape(2, 5)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
&gt;&gt;&gt; <strong>m1 &gt; 3</strong>    <span class="color-comment"># element-wise comparison</span>
array([[False, False, False, False,  True],
       [ True,  True,  True,  True,  True]])
&gt;&gt;&gt; <strong>(m1 &gt; 3).any()</strong>   <span class="color-comment"># or</span>
True
&gt;&gt;&gt; <strong>(m1 &gt; 3).all()</strong>   <span class="color-comment"># and</span>
False

&gt;&gt;&gt; <strong>np.any([-1, 0, 5])</strong>   <span class="color-comment"># 0 evaluates to False</span>
True

&gt;&gt;&gt; <strong>np.all([-1, 0, 5])</strong>
False

&gt;&gt;&gt; <strong>np.all([[True, False, True], [True, True, False]], axis=0)</strong>
array([ True, False, False])   <span class="color-comment"># Column-wise</span>
</pre>

<h4>Axes, Dimensions and Rank</h4>

<p>Numpy has its own meaning for axes, dimension and rank, which is different from Mathematics and Linear Algebra.</p>

<p>A 2D array has 2 axes: <code>axis-0</code> pointing horizontally across the columns, and <code>axis-1</code> pointing vertically across the rows. Operation applied on <code>axis-0</code> operates column-wise, while operation applied on <code>axis-1</code> operates rows-wise. Rank (or number of dimension, or <code>ndim</code>) is defined as the number of axes.</p>

<img class="image-center" src="images/Python_NumPy_Axes.png" alt="NumPy Axes" />

<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>import numpy as np</strong>
>>> <strong>m1 = np.arange(1, 16).reshape(3, 5)</strong>
>>> <strong>m1</strong>
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15]])
&gt;&gt;&gt; <strong>m1.shape</strong>
(3, 5)    <span class="color-comment"># 3 rows, 5 columns, 2-D</span>
&gt;&gt;&gt; <strong>m1.ndim</strong>
2         <span class="color-comment"># rank or number of axes</span>
&gt;&gt;&gt; <strong>m1.sum(axis=0)</strong>  <span class="color-comment"># Sum over axis-0 (column-wise operation)</span>
array([18, 21, 24, 27, 30])
&gt;&gt;&gt; <strong>m1.sum(axis=1)</strong>  <span class="color-comment"># Sum over axis-1 (row-wise operation)</span>
array([15, 40, 65])<span class="color-comment"></span></pre>

<h4>The <span class="font-code">ndarray</span>'s Functions</h4>
<h5>Multiplication: <span class="font-code">numpy.dot(<em>a</em>, <em>b</em>)</span></h5>

<p>The <code>numpy.dot()</code> performs different operations depending on the dimension of the array. It is NOT always the dot product or matrix multiplication.</p>
<pre class="color-example">&gt;&gt;&gt; <strong>v1 = np.array([1, 2, 3])</strong>
&gt;&gt;&gt; <strong>v2 = np.array([4, 5, 6])</strong>
&gt;&gt;&gt; <strong>m1 = np.arange(1, 10).reshape(3, 3)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
&gt;&gt;&gt; <strong>m2 = np.arange(9, 0, -1).reshape(3, 3)</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[9, 8, 7],
       [6, 5, 4],
       [3, 2, 1]])

&gt;&gt;&gt; <strong>help(np.dot)</strong>

<span class="color-comment"># If both a and b are 1D array, compute the &quot;inner product&quot;</span>
&gt;&gt;&gt; <strong>np.dot(v1, v2)</strong>
32

<span class="color-comment"># If both a and b are 2D arrays, compute the &quot;matrix multiplication&quot;.
# But numpy.matmul(a, b), or a @ b is preferred.</span>
&gt;&gt;&gt; <strong>np.dot(m1, m2)</strong>
array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
&gt;&gt;&gt; <strong>np.matmul(m1, m2)</strong>   <span class="color-comment"># matrix multiplication</span>
array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])
&gt;&gt;&gt; <strong>m1 @ m2</strong>
array([[ 30,  24,  18],
       [ 84,  69,  54],
       [138, 114,  90]])

<span class="color-comment"># If either a or b is 0-D (scalar), it is equivalent to element-wise multiplication.
# But numpy.multiply(a, b), or a * b is preferred.</span>
&gt;&gt;&gt; <strong>np.dot(2, m1)</strong>
array([[ 2,  4,  6],
       [ 8, 10, 12],
       [14, 16, 18]])
&gt;&gt;&gt; <strong>2 * m1</strong>
array([[ 2,  4,  6],
       [ 8, 10, 12],
       [14, 16, 18]])
&gt;&gt;&gt; <strong>np.multiply(m1, 2)</strong>
array([[ 2,  4,  6],
       [ 8, 10, 12],
       [14, 16, 18]])

<span class="color-comment"># If a is an N-D array and b is a 1-D array, it is a sum product over
# the last axis of a and b</span>
&gt;&gt;&gt; <strong>np.dot(m1, v1)</strong>
array([14, 32, 50])
<span class="color-comment">   # Sum product over each row of m1 and v1
   # m1 has two axes, axis-0 pointing horizontally across the columns
   #   and axis-1 pointing vertically across the rows.
   # Operation on axis-1 is row-wise</span>

<span class="color-comment"># If a is an N-D array and b is an M-D array (where M>=2), it is a
# sum product over the last axis of a and the second-to-last axis of b</span>
&gt;&gt;&gt; <strong>np.dot(v1, m1)</strong>
array([30, 36, 42])
   <span class="color-comment"># Second-to-last axis of b (m1) is axis-0, pointing horizontally across the column
   # Operation over axis-0 is column-wise</span></pre>

<h4>Universal Functions (ufunc) and Aggregate Functions</h4>
<p>A Universal Functions (ufunc) operates on each element of the array and return a new array of the same size. For examples, <code>numpy.sin(ndarray)</code>, <code>numpy.sqrt(ndarray)</code>.</p>
<p>An aggregate function operates on an array and returns a single result. For examples, <code>numpy.sum(ndarray)</code>, <code>numpy.min(ndarray)</code>, <code>numpy.mean(ndarray)</code>. In NumPy, you could choose to operate on the entire array, or a particular axis with the keyword argument <code>axis=<em>n</em></code>.</p>

<h5>NumPy's Aggregate Statistical Functions</h5>

<ul>
<li><code>sum()</code>, <code>mean()</code>, <code>std()</code>, <code>min()</code>, <code>max()</code></li>

<li><code>cumsum()</code> (cumulative sum)<code></code></li>

<li>More</li>
</ul>

<p>You can invoke these functions  via either <code>numpy</code>'s module-level functions or <code>ndarray</code>'s member methods. For example, you can invoke the <code>sum()</code> function via <code>ndarray.sum()</code> or <code>numpy.sum(ndarray)</code>. Furthermore, many of the aggregate functions can be applied to the entire array or a particular axis with the keyword argument <code>axis=<em>n</em></code>.</p>

<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>m1.sum()</strong>
231
&gt;&gt;&gt; <strong>np.sum(m1)</strong>  <span class="color-comment"># Same as above</span>
231
&gt;&gt;&gt; <strong>m1.min()</strong>
11
&gt;&gt;&gt; <strong>np.max(m1)</strong>
66

<span class="color-comment"># You can operate over a specific axis</span>
&gt;&gt;&gt; <strong>m1.sum(axis = 0)</strong>     <span class="color-comment"># sum column-wise</span>
array([55, 77, 99])
&gt;&gt;&gt; <strong>np.sum(m1, axis = 0)</strong> <span class="color-comment"># Same as above</span>
array([55, 77, 99])
&gt;&gt;&gt; <strong>m1.sum(axis = 1)</strong>     <span class="color-comment"># sum row-wise</span>
array([ 66, 165])
&gt;&gt;&gt; <strong>m1.cumsum(axis = 0)</strong>  <span class="color-comment"># cumulative sum column-wise</span>
array([[11, 22, 33],
       [55, 77, 99]])
&gt;&gt;&gt; <strong>m1.cumsum(axis = 1)</strong>  <span class="color-comment"># cumulative row-wise</span>
array([[ 11,  33,  66],
       [ 44,  99, 165]])
&gt;&gt;&gt; <strong>m1.cumsum()</strong>          <span class="color-comment"># default, operate on a flatten array</span>
array([ 11,  33,  66, 110, 165, 231], dtype=int32)
&gt;&gt;&gt; <strong>m1.ravel()</strong>           <span class="color-comment"># flatten the array</span>
array([11, 22, 33, 44, 55, 66])</pre>


<h5>NumPy's Universal Mathematical Functions</h5>

<p>NumPy provides mathematical functions, such as:</p>

<ul>
<li><code>numpy.sin(<em>ndarray</em>)</code>, <code>numpy.cos(<em>ndarray</em>)</code>, <code>numpy.tan(<em>ndarray</em>)</code></li>
<li><code>numpy.exp(<em>ndarray</em>)</code>, <code>numpy.sqrt(<em>ndarray</em>)</code></li>
<li><code>numpy.pi</code>, <code>numpy.e</code></li>
<li>more</li>
</ul>

<p>These functions are NumPy's module-level functions. They operate on each element of the array and return an array of the same size.</p>
<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>np.sqrt(m1)</strong>
array([[ 3.31662479,  4.69041576,  5.74456265],
       [ 6.63324958,  7.41619849,  8.1240384 ]])
&gt;&gt;&gt; <strong>np.exp(m1)</strong>
array([[  5.98741417e+04,   3.58491285e+09,   2.14643580e+14],
       [  1.28516001e+19,   7.69478527e+23,   4.60718663e+28]])
&gt;&gt;&gt; <strong>np.sin(m1)</strong>
array([[-0.99999021, -0.00885131,  0.99991186],
       [ 0.01770193, -0.99975517, -0.02655115]])</pre>

<h5>Iterator</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>

<span class="color-comment"># Iterate through the axis-0</span>
&gt;&gt;&gt; <strong>for row in m1:
        print(row, type(row))</strong>
[11 22 33] &lt;class 'numpy.ndarray'&gt;
[44 55 66] &lt;class 'numpy.ndarray'&gt;

<span class="color-comment"># Iterate through axis-0, then axis-1</span>
&gt;&gt;&gt; <strong>for row in m1:
        for col in row:
            print(col, end=', ')</strong>
11, 22, 33, 44, 55, 66,

<span class="color-comment"># Iterate through each element by flattening the array</span>
&gt;&gt;&gt; <strong>for item in m1.flat:
        print(item, end=' ')</strong>
11 22 33 44 55 66</pre>

<p>In general, you shall avoid iterate over the elements, as iteration (sequential) is very much slower than vector (parallel) operations.</p>

<h4><span class="font-code">numpy.apply_along_axis(func, axis, ndarray)</span></h4>

<p>Apply the given func along the axis for the <code>ndarray</code>. For examples,</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[1 , 2, 3], [4, 5, 6]])</strong>
&gt;&gt;&gt; <strong>np.apply_along_axis(np.sum, 0, m1)</strong>  <span class="color-comment"># axis-0 is column-wise</span>
array([5, 7, 9])    <span class="color-comment"># return an ndarray</span>
&gt;&gt;&gt; <strong>np.apply_along_axis(np.sum, 1, m1)</strong>  <span class="color-comment"># axis-1 is row-wise</span>
array([ 6, 15])

<span class="color-comment"># Check out np.apply_along_axis()</span>
&gt;&gt;&gt; <strong>np.apply_along_axis(lambda x: print(x, type(x)), 0, m1)</strong>
[1 4] &lt;class 'numpy.ndarray'&gt;
[2 5] &lt;class 'numpy.ndarray'&gt;
[3 6] &lt;class 'numpy.ndarray'&gt;
array([None, None, None], dtype=object)

<span class="color-comment"># Universal</span>
&gt;&gt;&gt; <strong>np.apply_along_axis(lambda v: v+1, 0, m1)</strong>   <span class="color-comment"># v and v+1 is ndarray</span>
array([[2, 3, 4],
       [5, 6, 7]])

<span class="color-comment"># Aggregate</span>
&gt;&gt;&gt; <strong>np.apply_along_axis(lambda v: v.max()-v.min(), 0, m1)</strong>  <span class="color-comment"># range</span>
array([3, 3, 3])</pre>

<h4>More NumPy's Functions</h4>
<h5>Shape (Dimension) Manipulation</h5>

<ul>
<li><code>reshape()</code>: return an array with modified shape.</li>
<li><code>resize()</code>: modifies this array.</li>
<li><code>ravel()</code>: flatten the array.</li>
<li><code>transpose()</code></li>
</ul>

<p>You can invoke these functions via NumPy's module-level function or ndarray member functions, e.g., <code>numpy.reshape(<em>ndarray</em>, <em>newShape</em>)</code> or <code><em>ndarray</em>.reshape(<em>newShape</em>)</code>.</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>

&gt;&gt;&gt; <strong>m2 = m1.reshape(3, 2)</strong>  <span class="color-comment"># Return a new array</span>
&gt;&gt;&gt; <strong>m2</strong>
array([[11, 22],
       [33, 44],
       [55, 66]])
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>m3 = np.reshape(m1, (3, 2))</strong>  <span class="color-comment"># using NumPy's module-level function</span>
&gt;&gt;&gt; <strong>m3</strong>
array([[11, 22],
       [33, 44],
       [55, 66]])

&gt;&gt;&gt; <strong>m1.resize(3, 2)</strong>  <span class="color-comment"># Resize this array</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22],
       [33, 44],
       [55, 66]])
&gt;&gt;&gt; <strong>m1.shape = (2, 3)</strong>  <span class="color-comment"># Same as resize()</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])

&gt;&gt;&gt; <strong>m1.ravel()</strong>     <span class="color-comment"># Flatten to 1D</span>
array([11, 22, 33, 44, 55, 66])
&gt;&gt;&gt; <strong>m1.resize(6)</strong>   <span class="color-comment"># Same as ravel()</span>
&gt;&gt;&gt; <strong>m1</strong>
array([11, 22, 33, 44, 55, 66])

&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>m1 = m1.transpose()</strong>   <span class="color-comment"># transpose() returns a new array</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 44],
       [22, 55],
       [33, 66]])</pre>


<h5>Stacking Arrays</h5>

<ul>
<li><code>numpy.vstack(<em>tup</em>)</code>: stack 2 or more array vertically.</li>
<li><code>numpy.hstack(<em>tup</em>)</code>: stack 2 or more array horizontally.</li>
<li><code>numpy.column_stack(<em>tup</em>)</code>: stack columns of 2 or more 1D arrays</li>
<li><code>numpy.row_stack(<em>tup</em>)</code>: stack rows of 2 or more 1D arrays</li>
</ul>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m2 = np.arange(6).reshape(2, 3)</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[0, 1, 2],
       [3, 4, 5]])

&gt;&gt;&gt; <strong>np.vstack((m1, m2))</strong>
array([[11, 22, 33],
       [44, 55, 66],
       [ 0,  1,  2],
       [ 3,  4,  5]])

&gt;&gt;&gt; <strong>np.hstack((m1, m2))</strong>
array([[11, 22, 33,  0,  1,  2],
       [44, 55, 66,  3,  4,  5]])

&gt;&gt;&gt; <strong>v1 = np.array([1, 2, 3, 4])</strong>
&gt;&gt;&gt; <strong>v2 = np.array([11, 12, 13, 14])</strong>
&gt;&gt;&gt; <strong>v3 = np.array([21, 22, 23, 24])</strong>
&gt;&gt;&gt; <strong>np.row_stack((v1, v2, v3))</strong>
array([[ 1,  2,  3,  4],
       [11, 12, 13, 14],
       [21, 22, 23, 24]])
&gt;&gt;&gt; <strong>np.column_stack((v1, v2, v3))</strong>
array([[ 1, 11, 21],
       [ 2, 12, 22],
       [ 3, 13, 23],
       [ 4, 14, 24]])</pre>
       
<h5>Splitting an Array</h5>

<ul>
<li><code>numpy.hsplit(<em>arr</em>, <em>sections</em>)</code>: split horizontally into equal partitions</li>
<li><code>numpy.vsplit(<em>arr</em>, <em>sections</em>)</code>: split vertically into equal partitions.</li>
<li><code>numpy.split(<em>arr</em>, <em>sections</em>, <em>axis</em>=0)</code>: split into equal partitions along the axis.</li>
<li><code>numpy.array_split(<em>arr</em>, <em>sections</em>, <em>axis</em>=0)</code>:</li>
</ul>

<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(1, 13).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])

&gt;&gt;&gt; <strong>np.hsplit(m1, 2)</strong>
[array([[ 1,  2],
       [ 5,  6],
       [ 9, 10]]),
 array([[ 3,  4],
       [ 7,  8],
       [11, 12]])]

&gt;&gt;&gt; <strong>a, b = np.hsplit(m1, 2)</strong>  <span class="color-comment"># with assignment</span>
&gt;&gt;&gt; <strong>a</strong>
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10]])
&gt;&gt;&gt; <strong>b</strong>
array([[ 3,  4],
       [ 7,  8],
       [11, 12]])

&gt;&gt;&gt; <strong>np.vsplit(m1, 3)</strong>   <span class="color-comment"># must be equal partitions</span>
[array([[1, 2, 3, 4]]),
 array([[5, 6, 7, 8]]),
 array([[ 9, 10, 11, 12]])]</pre>

<h5>Filling an Array with a Scalar: <span class="font-code">fill()</span></h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>m1.fill(0)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[0, 0, 0],
       [0, 0, 0]])</pre>


<h5>Copying an array: <span class="font-code">copy()</span></h5>

<p>Assigning one array to another variable via the assignment operator (<code>=</code>) simply assigns the reference, e.g.,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m2 = m1</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[11, 22, 33],
       [44, 55, 66]])
&gt;&gt;&gt; <strong>m2 is m1</strong>  
True    <span class="color-comment"># Same reference (pointing to the same object)</span>
<span class="color-comment"># Modifying m1 affects m2</span>
&gt;&gt;&gt; m1[0, 0] = 99
&gt;&gt;&gt; m2
array([[99, 22, 33],
       [44, 55, 66]])</pre>

<p>To generate a new copy, use <code>copy()</code> function:</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(1, 9).reshape(2, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

&gt;&gt;&gt; <strong>m2 = m1.copy()</strong>
&gt;&gt;&gt; <strong>m1 is m2</strong>
False   <span class="color-comment"># holding different objects</span>
&gt;&gt;&gt; <strong>m1[0, 0] = 99</strong>  <span class="color-comment"># modify m1</span>
&gt;&gt;&gt; <strong>m2</strong>
array([[1, 2, 3, 4],  <span class="color-comment"># m2 not affected</span>
       [5, 6, 7, 8]])

&gt;&gt;&gt; <strong>m3 = np.copy(m1)</strong>  <span class="color-comment"># using NumPy's module-level function</span>
&gt;&gt;&gt; <strong>m3</strong>
array([[99,  2,  3,  4],
       [ 5,  6,  7,  8]])
&gt;&gt;&gt; <strong>m3 is m1</strong>
False</pre>

<ul>
<li><code>view()</code>: creates a new array object that looks at the same data, i.e., shallow copy. A slice of array produces a view.</li>
<li><code>copy()</code>: makes a complete (deep) copy of the array and its data.</li>

</ul>

<h4>Vectorization and Broadcasting</h4>

<p>NumPy makes full use of <em>vectorization</em> in its implementation, where you do not need to use an explicit loop to iterate through the elements of an <code>ndarray</code>. For example, you can simply write <code>m1 + m2</code> to perform element-wise addition, instead of writing an explicit loop.</p>
<p>Broadcasting allows NumPy to carry out some operations between two (or more) array of different shapes, subjected to certain constraints.</p>
<p>In NumPy, two arrays are <em>compatible</em> if the lengths of each dimension (shape) are the same, or one of the lengths is 1. For example, suppose that <code>m1</code>'s <code>shape</code> is <code>(3, 4, 1)</code> and <code>m2</code>'s <code>shape</code> is <code>(3, 1, 4)</code>, <code>m1</code> and <code>m2</code> are compatible because <code>d0</code> has the same length, and one of the lengths on <code>d1</code> and <code>d2</code> is 1.</p>
<p>Broadcasting is carried out on NumPy as illustrated in the following example:</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(1, 13).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; <strong>m2 = np.array([1, 1, 1, 1])</strong>
&gt;&gt;&gt; <strong>m1.shape</strong>
(3, 4)
&gt;&gt;&gt; <strong>m2.shape</strong>
(4,)
&gt;&gt;&gt; <strong>m1 + m2</strong>
array([[ 2,  3,  4,  5],
       [ 6,  7,  8,  9],
       [10, 11, 12, 13]])</pre>

<p>Clearly, <code>m1</code> and <code>m2</code> have different shapes, but NumPy is able to carry out the addition via broadcasting. The steps for broadcasting is as follows:</p>

<ol>
<li>If the arrays have different ranks (dimensions), treat the missing dimensions as 1. In the example, <code>m2</code>'s shape is treated as <code>(1, 4)</code>.
 Now, <code>m1</code> and <code>m2</code> are compatible.</li>
<li>If the arrays are compatible, extend the size of smaller array to match the larger one through repetition. Hence, <code>m2</code> is extended to:
<pre class="color-example">array([[ 1,  1,  1,  1],
       [ 1,  1,  1,  1],
       [ 1,  1,  1,  1]])</pre></li>
<li>NumPy is now able to carry out the addition, element-wise.</li>
</ol>

<p>However, the operation will fail if the arrays are not compatible, for example,</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.arange(1, 13).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; <strong>m3 = np.array([2, 2, 2])</strong>
&gt;&gt;&gt; <strong>m3</strong>
array([2, 2, 2])
&gt;&gt;&gt; <strong>m1 + m3</strong>
ValueError: operands could not be broadcast together with shapes (3,4) (3,)</pre>

<h4>Structured Arrays</h4>
<p>An <code>ndarray</code> can hold records, typically in the form of tuples, instead of plain scalar. It is called structured array. For example,</p>

<pre class="color-example">
<span class="color-comment"># ndarray supports only homogeneous data type.
# Mixed data types are converted to string.</span>
&gt;&gt;&gt; <strong>m1 = np.array([(1, 'a', 1.11), (2, 'b', 2.22)])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([['1', 'a', '1.11'],
       ['2', 'b', '2.22']], dtype='&lt;U11')

<span class="color-comment"># However, you can set the data type to a tuple to create a structured array</span>
&gt;&gt;&gt; <strong>m1 = np.array([(1, 'a', 1.11), (2, 'b', 2.22)], dtype=('i4, U11, f8'))</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([(1, 'a', 1.11), (2, 'b', 2.22)],
      dtype=[('f0', '&lt;i4'), ('f1', '&lt;U11'), ('f2', '&lt;f8')])
&gt;&gt;&gt; <strong>m1.shape</strong>
(2,)          <span class="color-comment"># 1D of tuples</span>
&gt;&gt;&gt; <strong>m1[0]</strong>
(1, 'a', 1.11)
&gt;&gt;&gt; m1[0, 0]  <span class="color-comment"># 1D</span>
IndexError: too many indexes for array

<span class="color-comment"># You can also set a header for each column of the tuples</span>
&gt;&gt;&gt; <strong>m2 = np.array([(1, 'a', 1.11), (2, 'b', 2.22)], dtype=[('idx', 'i4'), ('v1', 'U11'), ('v2', 'f8')])</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([(1, 'a', 1.11), (2, 'b', 2.22)],
      dtype=[('idx', '&lt;i4'), ('v1', '&lt;U11'), ('v2', '&lt;f8')])
&gt;&gt;&gt; <strong>m2.shape</strong>
(2,)
<span class="color-comment"># Use the headers to access the columns</span>
&gt;&gt; <strong>m2['idx']</strong>
array([1, 2])
&gt;&gt;&gt; <strong>m2['v1']</strong>
array(['a', 'b'], dtype='&lt;U11')
&gt;&gt;&gt; <strong>m2['v2']</strong>
array([1.11, 2.22])</pre>

<h4>Saving/Loading from Files</h4>

<h5>Saving/Loading from Files in Binary Format: <span class="font-code">save()</span> and <span class="font-code">load()</span></h5>

<p>NumPy provides a pair of functions called <code>load()</code> and <code>save()</code> for reading and writing an <code>ndarray</code> in binary format. For example,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.random.rand(3, 4)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[0.72197242, 0.90794499, 0.07341204, 0.59910337],
       [0.37028474, 0.82666762, 0.68453112, 0.80082228],
       [0.53934751, 0.89862448, 0.78529266, 0.8680931 ]])

&gt;&gt;&gt; <strong>np.save('data', m1)</strong>
&gt;&gt;&gt; <strong>m2 = np.load('data')</strong>
   <span class="color-comment"># In Windows, the filed is named 'data.npy'
   # Verify that it is in binary format</span>

&gt;&gt;&gt; <strong>m2 = np.load('data.npy')</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[0.72197242, 0.90794499, 0.07341204, 0.59910337],
       [0.37028474, 0.82666762, 0.68453112, 0.80082228],
       [0.53934751, 0.89862448, 0.78529266, 0.8680931 ]])</pre>

<h5>Saving/Loading from Text File: <span class="font-code">savetxt()</span> <span class="font-code">loadtxt()</span>, and <span class="font-code">genfromtxt()</span></h5>

<p>NumPy provides a pair of functions called <code>savetxt()</code> and <code>loadtxt()</code> to save/load an <code>ndarray</code> from a text file, such as CSV (Comma-Separated Values) or TSV (Tab-Separated Values). For example,</p>

<pre class="color-example">&gt;&gt;&gt; <strong>m1 = np.arange(1, 11).reshape(2, 5)</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10]])
&gt;&gt;&gt; <strong>np.savetxt('data.csv', m1, fmt='%d', delimiter=',')</strong>
   <span class="color-comment"># Check the CSV file generated</span>

&gt;&gt;&gt; <strong>m2 = np.loadtxt('data.csv', delimiter=',')</strong>
&gt;&gt;&gt; <strong>m2</strong>
array([[ 1.,  2.,  3.,  4.,  5.],
       [ 6.,  7.,  8.,  9., 10.]])
&gt;&gt;&gt; <strong>m3 = np.loadtxt('data.csv', delimiter=',', dtype='int')</strong>  <span class="color-comment"># Set data type</span>
&gt;&gt;&gt; <strong>m3</strong>
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10]])</pre>

<p>NumPy provides another function called <code>genfromtxt()</code> to handle <em>structured arrays</em>. For example, create the following CSV file called <code>data1.csv</code> with missing data points and header:</p>

<pre class="color-example">
i1,i2,f1,f2,u1,u2
1,,3.33,4.44,'a1','a2'
6,7,,9.99,,'b2'</pre>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.genfromtxt('data1.csv', delimiter=',', names=True, dtype=('i4, i4, f4, f8, U11, U11'))</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([(1, -1, 3.33, 4.44, 'aa1', 'aa2'), (6,  7,  nan, 9.99, '', 'bb2')],
      dtype=[('i1', '&lt;i4'), ('i2', '&lt;i4'), ('f1', '&lt;f4'), ('f2', '&lt;f8'), ('u1', '&lt;U11'), ('u2', '&lt;U11')])
<span class="color-comment">    # Structured array of tuples of records
    # Missing int is replaced by -1, missing float by nan (not a number), missing string by empty string</span>
&gt;&gt;&gt; <strong>m1['i2']</strong>  <span class="color-comment"># index by column name</span>
array([-1,  7])
&gt;&gt;&gt; <strong>m1['f1']</strong>
array([3.33,  nan], dtype=float32)
&gt;&gt;&gt; <strong>m1['u1']</strong>
array(['aa1', ''], dtype='&lt;U11')
&gt;&gt;&gt; <strong>m1[1]</strong>   <span class="color-comment"># usual indexing</span>
(6, 7, nan, 9.99, '', 'bb2')</pre>

<h4>Statistical Operations</h4>
<p>NumPy provides statistical functions such as:</p>

<ul>
<li><code>sum()</code>, <code>min()</code>, <code>max()</code></li>
<li><code>amin()</code>, <code>amax()</code>, <code>ptp()</code> (range of values):</li>
<li><code>nanmin()</code>, <code>nanmax()</code>: ignore <code>nan</code></li>
<li><code>average()</code>: weighted average</li>
<li><code>mean()</code>, <code>median()</code>, <code>std()</code>, <code>var()</code>, <code>percentile()</code>:</li>
<li><code>naamean()</code>, <code>nanmedian()</code>, <code>nanstd()</code>, <code>nanvar()</code>, <code>nanpercentile()</code>: ignore <code>nan</code>.</li>
<li><code>corrcoef()</code> (correlation coefficient); <code>correlate()</code> (cross-correlation between two 1D arrays), <code>cov()</code> (co-variance)</li>
<li><code>histogram()</code>, <code>histogram2d()</code>, <code>histogramdd()</code>, <code>bincount()</code>, <code>digitize()</code></li>
</ul>

<p>You can invoke most of these function via ndarray's member function <code><em>ndarray</em>.<em>func</em>(*args)</code>, or NumPy's module-level function <code>numpy.<em>func</em>(<em>ndarray</em>, *args)</code>.</p>
<p>For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>m1</strong>
array([[11, 22, 33],
       [44, 55, 66]])

&gt;&gt;&gt; <strong>m1.mean()</strong>  <span class="color-comment"># All elements, using ndarray member function</span>
38.5
&gt;&gt;&gt; <strong>np.mean(m1)</strong>   <span class="color-comment"># Using NumPy's module-level function</span>
38.5
&gt;&gt;&gt; <strong>m1.mean(axis = 0)</strong>   <span class="color-comment"># Over the rows</span>
array([ 27.5,  38.5,  49.5])
&gt;&gt;&gt; <strong>np.mean(m1, axis = 0)</strong>
array([27.5, 38.5, 49.5])
&gt;&gt;&gt; <strong>m1.mean(axis = 1)</strong>   <span class="color-comment"># Over the columns</span>
array([ 22.,  55.])</pre>


<h4>Linear Algebra</h4>

<ul>
<li><code>numpy.transpose()</code>: </li>
<li><code>numpy.trace()</code>: </li>
<li><code>numpy.eye(dim)</code>: create an identity matrix</li>
<li><code>numpy.dot(a1, a2)</code>: compute the dot product. For 1D, it is the inner product. For 2D, it is equivalent to matrix multiplication.</li>
<li><code>numpy.linalg.inv(m)</code>: compute the inverse of matrix m</li>
<li><code>numpy.linalg.eig(m)</code>: compute the eigenvalues and right eigenvectors of square matrix m.</li>
<li><code>numpy.linalg.solve(a, b)</code>: Solving system of linear equations <code>ax = b</code>.</li>
</ul>

<pre class="color-example">
<span class="color-comment"># Solving system of linear equations ax = b</span>
&gt;&gt;&gt; <strong>a = np.array([[1, 3, -2], [3, 5, 6], [2, 4, 3]])</strong>
&gt;&gt;&gt; <strong>a</strong>
array([[ 1,  3, -2],
       [ 3,  5,  6],
       [ 2,  4,  3]])
&gt;&gt;&gt; <strong>b = np.array([[5], [7], [8]])</strong>
&gt;&gt;&gt; <strong>b</strong>
array([[5],
       [7],
       [8]])
&gt;&gt;&gt; <strong>x = np.linalg.solve(a, b)</strong>
&gt;&gt;&gt; <strong>x</strong>
array([[-15.],
       [  8.],
       [  2.]])
&gt;&gt;&gt; <strong>np.dot(a, x)</strong>  <span class="color-comment"># matrix multiplication ax (=b)</span>
array([[ 5.],
       [ 7.],
       [ 8.]])

<span class="color-comment"># Compute the inverse of matrix a</span>
&gt;&gt;&gt; <strong>np.linalg.inv(a)</strong>
array([[ 2.25,  4.25, -7.  ],
       [-0.75, -1.75,  3.  ],
       [-0.5 , -0.5 ,  1.  ]])

<span class="color-comment"># Compute the eigenvalues and right eigenvectors of a</span>
&gt;&gt;&gt; <strong>eig = np.linalg.eig(a)</strong>
&gt;&gt;&gt; <strong>eig</strong>
(array([ 0.41742431,  9.58257569, -1.        ]),   <span class="color-comment"># eigenvalues</span>
 array([[-0.92194876,  0.15950867,  0.85435766],   <span class="color-comment"># eigenvectors corresponding to eigenvalues</span>
        [ 0.32226296,  0.82139716, -0.51261459],
        [ 0.21484197,  0.54759811,  0.08543577]]))
<span class="color-comment"># Check answer ax=ex</span>
&gt;&gt;&gt; <strong>np.dot(a, eig[1][:, 0])</strong>   <span class="color-comment"># column 0</span>
array([-0.38484382,  0.13452039,  0.08968026])
&gt;&gt;&gt; <strong>np.dot(eig[0][0], eig[1][:, 0])</strong>   <span class="color-comment"># Scalar multiplication</span>
array([-0.38484382,  0.13452039,  0.08968026])</pre>

<h4>Performance and Vectorization</h4>

<p>NumPy provides pre-compiled numerical routines (most of them implemented in C code) for high-performance operations, and supports vector (or parallel) computations.</p>

<p>For example, we use the following programs to compare the performance of NumPy's <code>ndarray</code> and Python's array (list):</p>

<pre class="color-example">
<span class="color-comment"># numpy_performance.py
# Comparing NumPy's ndarray and Python array (list)</span>
import numpy as np
import time

size  = 10000000
#size = 100000000

def using_python_array():
    startTime = time.time()
    lst1 = range(size)   <span class="color-comment"># Python's list</span>
    lst2 = range(size)
    lst3 = []
    for i in range(len(lst1)):   <span class="color-comment"># Sequential</span>
        lst3.append(lst1[i] + lst2[i])
    return time.time() - startTime

def using_numpy_array():
    startTime = time.time()
    m1 = np.arange(size)     <span class="color-comment"># NumPy's ndarray</span>
    m2 = np.arange(size)
    m3 = m1 + m2     <span class="color-comment"># Overloaded operator for element-wise addition (vectorized)</span>
    return time.time() - startTime

t_python = using_python_array()
t_numpy  = using_numpy_array()
print('Python Array:', t_python)
print('NumPy Array:', t_numpy)
print('Ratio: ', t_python // t_numpy)

<span class="color-comment"># Results
</span>#size  = 10000000
#Python Array: 3.6722664833068848
#NumPy Array: 0.06250667572021484
#Ratio:  58

#size = 100000000
#Python Array: 38.09505248069763
#NumPy Array: 0.6761398315429688
#Ratio:  56</pre>

<h5>Vectorized Scalar Function: <span class="font-code">numpy.vectorize(<em>func</em>) -&gt; <em>func</em></span></h5>

<p>Normal functions that work on scalar cannot be applied to list (array). You can vectorize the function via <code>numpy.vectorize(<em>func</em>)</code>. For example,</p>
<pre class="color-example">
<span class="color-comment"># Define a scalar function</span>
&gt;&gt;&gt; <strong>def myfunc(x):
        return x + 1</strong>
<span class="color-comment"># Run the scalar function</span>
&gt;&gt;&gt; <strong>myfunc(5)</strong>
6

<span class="color-comment"># This scalar function cannot be applied to list</span>
&gt;&gt;&gt; <strong>myfunc([1, 2, 3])</strong>
TypeError: can only concatenate list (not &quot;int&quot;) to list

<span class="color-comment"># Vectorize the function using numpy.vectorize()</span>
&gt;&gt;&gt; <strong>v_myfunc = np.vectorize(myfunc)</strong>
<span class="color-comment"># Apply to Python's list</span>
&gt;&gt;&gt; <strong>v_myfunc([1, 2, 3, 4])</strong>
array([2, 3, 4, 5])  <span class="color-comment"># return a NumPy's array</span>
<span class="color-comment"># Apply to a NumPy's array</span>
&gt;&gt;&gt; <strong>m1 = np.array([[11, 22, 33], [44, 55, 66]])</strong>
&gt;&gt;&gt; <strong>v_myfunc(m1)</strong>
array([[12, 23, 34],
       [45, 56, 67]])
       
<span class="color-comment"># Function with two arguments</span>
&gt;&gt;&gt; <strong>def my_absdiff(a, b):
        return a-b if a &gt; b else b-a</strong>
&gt;&gt;&gt; <strong>my_absdiff(5, 2)</strong>
3
&gt;&gt;&gt; <strong>my_absdiff(2, 5)</strong>
3
&gt;&gt;&gt; <strong>my_absdiff = np.vectorize(my_absdiff)</strong>  <span class="color-comment"># Same function name</span>
&gt;&gt;&gt; <strong>my_absdiff([1, 2, 3, 4, 5], 3)</strong>
array([2, 1, 0, 1, 2])</pre>


<h3 id="matplotlib_numpy">NumPy and Matplotlib</h3>

<p>The <code>plot()</code> function can handle NumPy's <code>ndarray</code>, just like Python's <code>list</code>.</p>
<pre class="color-syntax">
plot([x], y, [fmt], **kwargs)   <span class="color-comment"># Single line or point</span></pre>

<p>These examples are developed and tested in Jupyter Notebook, which is convenience and productive. [TODO] Share the notebook.</p>

<h4>Example 1: Line Chart</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Line Plot: sin(x), cos(x), cos(x**2) for x=[-2*pi, 2*pi]</span>
import matplotlib.pyplot as plt
import numpy as np
<span class="color-comment"># Generate x: linearly spaced in degree interval, both ends included</span>
x = np.linspace(-2*np.pi, 2*np.pi, 721)
<span class="color-comment"># Generate y's</span>
sx, cx, cx2 = np.sin(x), np.cos(x), np.cos(x**2)

<span class="color-comment"># Plot lines - use individual plot() to setup label for legend
# x is scaled to number of pi</span>
plt.plot(x/np.pi, sx, color='#FF6666', label='sin(x)')
plt.plot(x/np.pi, cx, color='#66FF66', label='cos(x)')
plt.plot(x/np.pi, cx2, color='#6666FF', label='cos(x**2)')

<span class="color-comment"># Setup x, y labels, axis, legend and title</span>
plt.xlabel(r'x ($\pi$)')  <span class="color-comment"># Use letex symbol for pi in Python's raw string</span>
plt.ylabel('y')
plt.axis([-2, 2, -1, 1])  <span class="color-comment"># x-min, x-max, y-min, y-max</span>
plt.legend()  <span class="color-comment"># Extracted from plot()'s label</span>
plt.title('Sines and Cosines (NumPy-Matplotlib Line Plot)')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_LineSineCosine.png" alt="Line Plot Sine/Cosine" />

<h4>Example 2: Line Chart with x-y Axis at Zero</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Line Plot: Set x-y axis at zero</span>
import matplotlib.pyplot as plt
import numpy as np
<span class="color-comment"># Generate x: linearly spaced in degree interval, both ends included</span>
x = np.linspace(-2*np.pi, 2*np.pi, 721)
<span class="color-comment"># Generate y's</span>
y = np.sin(3*x)/x

<span class="color-comment"># Get the axes handle for fine control. Axes uses set_xxx() setters for properties</span>
ax = plt.subplot(1, 1, 1)
ax.plot(x, y, 'r-', label='sin(3*x)/x')
<span class="color-comment"># Remove the top and right border</span>
ax.spines['top'].set_color('none')
ax.spines['right'].set_color('none')
<span class="color-comment"># Move the bottom and left border to x and y of 0</span>
ax.spines['bottom'].set_position(('data', 0))
ax.spines['left'].set_position(('data', 0))
<span class="color-comment"># Set the x-tick position, locations and labels</span>
ax.xaxis.set_ticks_position('bottom')
ax.yaxis.set_ticks_position('left')
ax.set_xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi])
ax.set_xticklabels([r'$-2\pi$', r'$-\pi$', r'$0$', r'$+\pi$', r'$+2\pi$']) <span class="color-comment"># Using latex symbol</span>
ax.set_title('Line Plot with Axis at 0 (NumPy-Matplotlib)')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_ZeroAxis.png" alt="Plot with axis at zero" />

<h4>Example 3: Bar Chart</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Bar Chart</span>
import matplotlib.pyplot as plt
import numpy as np
<span class="color-comment"># Setup data</span>
x = np.arange(5)  <span class="color-comment"># [0, 1, ..., 4]</span>
y = np.random.randint(1, 101, len(x))  <span class="color-comment"># 5 values in [1, 100]</span>
xticklabels = ['2020', '2021', '2022', '2023', '2024']

<span class="color-comment"># Plot bar chart</span>
plt.bar(x, y, tick_label=xticklabels)  <span class="color-comment"># Bar chart with labels</span>
   <span class="color-comment"># default bar width is 0.8, from x-0.4 to x+0.4</span>
plt.xlabel('Year')
plt.ylabel('Sales')
plt.title('Coffee &amp; Tea Sales (NumPy-Matplotlib Bar Chart)')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Bar.png" alt="Bar Chart" />

<h4>Example 4: Bar Chart (Grouped and Stacked)</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Grouped and Stacked Bar Charts</span>
import matplotlib.pyplot as plt
import numpy as np

<span class="color-comment"># Setup x and y</span>
x = np.arange(5)  # [0, 1, ..., 4]
y1 = np.array([1, 6, 3, 5, 2])
y2 = np.array([2, 2, 4, 5, 1])
y3 = np.array([3, 3, 2, 3, 1])
x_ticklabels = ['2020', '2021', '2022', '2023', '2024']
y_colors = ['#5B9BD5', '#ED7D31', '#70AD47']
y_labels = ['Espresso', 'Cappuccino', 'Latte']

<span class="color-comment"># Setup 1 figure with 2 subplots</span>
plt.figure(figsize=(6.4, 6.4))  # in inches, default is (6.4, 4.8)

<span class="color-comment"># Stacked Bar Chart</span>
plt.subplot(2, 1, 1)
<span class="color-comment"># Set the bottom as base in y for stacking</span>
plt.bar(x, y1, color=y_colors[0], tick_label=x_ticklabels, label=y_labels[0])
plt.bar(x, y2, bottom=y1, color=y_colors[1], label=y_labels[1])
plt.bar(x, y3, bottom=y1+y2, color=y_colors[2], label=y_labels[2])
plt.xlabel('Year')
plt.ylabel('Sales')
plt.title('Coffee &amp; Tea Sales (NumPy-Matplotlib Stacked Bar Chart)')
plt.legend()  <span class="color-comment"># Extracted from plt.bar()'s label</span>

<span class="color-comment"># Grouped Bar Chart</span>
plt.subplot(2, 1, 2)
bar_width = 0.3  # 3*0.3 = 0.9
<span class="color-comment"># Set the width in x for grouped bars</span>
plt.bar(x, y1, bar_width, color=y_colors[0], label=y_labels[0])
plt.bar(x+bar_width, y2, bar_width, color=y_colors[1], label=y_labels[1], tick_label=x_ticklabels)
plt.bar(x+2*bar_width, y3, bar_width, color=y_colors[2], label=y_labels[2])
plt.xlabel('Year')
plt.ylabel('Sales')
plt.title('Coffee &amp; Tea Sales (NumPy-Matplotlib Grouped Bar Chart)')
plt.legend()

plt.tight_layout()  <span class="color-comment"># To prevent overlapping of subplots</span>
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_BarStacked.png" alt="Bar Stacked and Parallel" />

<h4>Example 5: Histogram (Bar Chart)</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Histogram
# For marks of [0, 100], in 10 bins</span>
import matplotlib.pyplot as plt
import numpy as np
<span class="color-comment"># Setup data</span>
y = np.random.normal(65, 15, 500)  # Normal Distributed at mean and std dev
xtick_locations = np.arange(5, 100, 10)  # x=5, 15, 25, ...
xtick_labels = ['0-9', '10-19', '20-29', '30-39', '40-49', '50-59', '60-69', '70-79', '80-89', '90-100']

<span class="color-comment"># Setup bins and Plot</span>
bins = range(0, 101, 10)  <span class="color-comment"># bins are [0, 10), [10, 19), ... [90, 100]</span>
plt.hist(y, bins=bins, rwidth=0.8)
    <span class="color-comment"># rwidth: ratio of width of bar over bin</span>
plt.xticks(xtick_locations, xtick_labels, rotation=90)
plt.xlim(0, 100)   <span class="color-comment"># range of x-axis</span>
plt.xlabel('Mark')
plt.ylabel('Number of Students')
plt.title('Histogram (NumPy-Matplotlib)')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Histogram.png" alt="Histogram" />

<h4>Example 6: Pie Chart</h4>

<pre class="color-example">
<span class="color-comment"># Matplotlib Pie Chart</span>
import matplotlib.pyplot as plt
x_labels = ['2020', '2021', '2022', '2023', '2024']
y = [5, 3, 6, 2, 3]
explode = (0, 0, 0, 0.2, 0)   <span class="color-comment"># &quot;explode&quot; the forth slice by 0.2</span>
plt.pie(y, labels=x_labels, explode=explode, shadow=True, startangle=90)
plt.axis('equal')   <span class="color-comment"># Draw a circle</span>
plt.title('Pie Chart (Matplotlib)')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pie.png" alt="Pie Chart" />

<h4>Example 7: Scatter Chart</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Scatter Plot</span>
<span class="color-comment"># for 2 categories of 25 points each, randomly generated</span>
import matplotlib.pyplot as plt
import numpy as np
xy1 = np.random.normal(8, 1, 50).reshape(-1, 2)  <span class="color-comment"># cat1: [x1, y1] 25 samples</span>
xy2 = np.random.normal(4, 2, 50).reshape(-1, 2)  <span class="color-comment"># cat2: [x2, y2] 25 samples</span>
plt.scatter(xy1[:,0], xy1[:,1], c='red', label='cat 1')
plt.scatter(xy2[:,0], xy2[:,1], c='green', label='cat 2')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Scatter Plot (NumPy-Matplotlib)')
plt.legend()
xmin = min(xy1[:,0].min(), xy2[:,0].min())
xmax = max(xy1[:,0].max(), xy2[:,0].max())
ymin = min(xy1[:,1].min(), xy2[:,1].min())
ymax = max(xy1[:,1].max(), xy2[:,1].max())
plt.axis((xmin-1, xmax+1, ymin-1, ymax+1))
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Scatter.png" alt="Scatter Plot" />

<h4>Example 8: Pseudo-color Mesh</h4>

<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Pseudo-color Mesh</span>
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import ListedColormap

<span class="color-comment"># Set up a 10x8 grid with random values in [0, 2] for 3 categories</span>
x = np.arange(5, 15)  <span class="color-comment"># [5, 6, ..., 14] with 10 points</span>
y = np.arange(2, 10)  <span class="color-comment"># [2, 3, ... 9] with 8 points</span>
z = np.random.randint(0, 3, (len(y), len(x)))  <span class="color-comment"># Random integers in [0, 2]</span>
cmap = ListedColormap(['#FF6666', '#66FF66', '#6666FF'])  <span class="color-comment"># color map for [0, 2]</span>
plt.pcolormesh(x, y, z, cmap=cmap)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Pseudocolor Mesh (NumPy-Matplotlib)')

<span class="color-comment"># Plot colorbar for color mesh</span>
cbar = plt.colorbar()
cbar.set_ticks([0.33, 1., 1.67])
cbar.set_ticklabels(['Cat 0', 'Cat 1', 'Cat 2'])
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_ColorMesh.png" alt="Color Mesh" />

<h4>Example 8: Pseudo-color Mesh with MeshGrid</h4>
<pre class="color-example">
<span class="color-comment"># NumPy-Matplotlib Pseudo-color Mesh with meshgrid</span>
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import ListedColormap

<span class="color-comment"># Setup a mesh grid and values</span>
step = 0.2   # mesh step size
xx, yy = np.meshgrid(np.arange(5, 14, step), np.arange(2, 9, step))
z = np.random.randint(0, 3, xx.shape)  <span class="color-comment"># random integers in [0, 2]</span>

cmap = ListedColormap(['#FF6666', '#66FF66', '#6666FF'])  <span class="color-comment"># color map for [0, 2]</span>
plt.pcolormesh(xx, yy, z, cmap=cmap)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Pseudocolor Mesh with meshgrid (NumPy-Matplotlib)')

<span class="color-comment"># Plot colorbar for color mesh</span>
cbar = plt.colorbar()
cbar.set_ticks([0.33, 1., 1.67])
cbar.set_ticklabels(['Cat 0', 'Cat 1', 'Cat 2'])
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_ColorMeshGrid.png" alt="Color Mesh" />


<h5>Example: Contour Chart</h5>
<p>[TODO]</p>

<h5>Example: Polar Chart</h5>
<p>[TODO]</p>


<h3 id="pandas">Pandas</h3>

<p>References:</p>
<ol>
<li>Pandas mother site @ <a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a></li>
<li>Pandas API References @ <a href="https://pandas.pydata.org/pandas-docs/stable/api.html">https://pandas.pydata.org/pandas-docs/stable/api.html</a></li>
</ol>

<p>Pandas is an open-source library providing high-performance, easy-to-use 2d tabular data structure and data analysis tools for Python. Pandas is built on top of NumPy, specializing in data analysis.</p>

<p>The two most important classes in Pandas are:</p>
<ol>
<li><code>Series</code>: For 1D labeled sequences.</li>
<li><code>DataFrame</code>: For 2D labeled tabular data.</li>
</ol>

<p>To use Pandas package:</p>
<pre class="color-syntax">
<strong>import pandas as pd</strong></pre>

<h4>The Pandas' <span class="font-code">Series</span> Class</h4>

<p>A Pandas' <code>Series</code> is designed to represent <em>labeled</em> 1D sequences, where each element has an <em>index</em> and a <em>value</em>. The row-index could be a user-defined object, unique or non-unique. An integral index starting from 0 is also provided. All values have the same data type.</p>

<img class="image-center" src="images/Python_Pandas_Series.png" alt="Pandas Series" />

<p>To create a Pandas' <code>Series</code>, use the constructor:</p>
<pre class="color-syntax">
&gt;&gt;&gt; <strong>import numpy as np</strong>
&gt;&gt;&gt; <strong>import pandas as pd</strong>
&gt;&gt;&gt; <strong>help(pd.Series)</strong>
Series(data=None, index=None, dtype=None, name=None)
    <span class="color-comment"># data: array-like, dict, or scaler
    # index: array-like or Pandas' Index object. Same length as data. Can be non-unique.
    #     Default to Pandas' RangeIndex(0, 1, ..., n-1) if not provided</span></pre>

<h5>Constructing a Pandas' <span class="font-code">Series</span> 1: Using a Value-List and an Index-List.</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([5, 7, 2, 5, 3], index=['a', 'b', 'c', 'd', 'a'], name='x')</strong>   <span class="color-comment"># non-unique index</span>
&gt;&gt;&gt; <strong>s1</strong>
a    5
b    7
c    2
d    5
a    3
Name: x, dtype: int64
&gt;&gt;&gt; <strong>s1.index</strong>
Index(['a', 'b', 'c', 'd', 'a'], dtype='object')  <span class="color-comment"># An Index object</span>
&gt;&gt;&gt; <strong>s1.values</strong>
array([5, 7, 2, 5, 3], dtype=int64)  <span class="color-comment"># Data values in ndarray</span>
&gt;&gt;&gt; <strong>s1.dtype</strong>
dtype('int64')
&gt;&gt;&gt; <strong>s1.name</strong>   <span class="color-comment"># column name</span>
'x'</pre>

<h5>Accessing the Series: Indexing <span class="font-code">[idx]</span>, Dot <span class="font-code">.idx</span>, and Slicing <span class="font-code">[start:stop:step]</span></h5>
<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([5, 7, 2, 5, 3], index=['a', 'b', 'c', 'd', 'a'], name='x')</strong>

<span class="color-comment"># Indexing and Dot-Index</span>
&gt;&gt;&gt; <strong>s1['c']</strong>   <span class="color-comment"># Indexing via index</span>
2
&gt;&gt;&gt; <strong>s1.c</strong>      <span class="color-comment"># Same as above</span>
2
&gt;&gt;&gt; <strong>type(s1.c)</strong>
&lt;class 'numpy.int64'&gt;   <span class="color-comment"># Scalar</span>
&gt;&gt;&gt; <strong>s1['a']</strong>   <span class="color-comment"># Non-unique index</span>
a    5
a    3
Name: x, dtype: int64
&gt;&gt;&gt; <strong>s1.a</strong>      <span class="color-comment"># Same as above</span>
a    5
a    3
Name: x, dtype: int64
&gt;&gt;&gt; <strong>type(s1.a)</strong>
&lt;class 'pandas.core.series.Series'&gt;   <span class="color-comment"># A Series</span>

<span class="color-comment"># Slicing</span>
&gt;&gt;&gt; <strong>s1['b':'d']</strong>   <span class="color-comment"># Slicing via index</span>
b    7
c    2
d    5
Name: x, dtype: int64
&gt;&gt;&gt; <strong>s1['b':'d':2]</strong>   <span class="color-comment"># Slicing with step</span>
b    7
d    5
Name: x, dtype: int64
&gt;&gt;&gt; <strong><span class="color-error">s1['a':'b']</span></strong>     <span class="color-comment"># Cannot use non-unique index for slicing</span>
KeyError: &quot;Cannot get left slice bound for non-unique label: 'a'&quot;

<span class="color-comment"># An numeric row-index starting from 0 is also maintained</span>
&gt;&gt;&gt; <strong>s1[2]</strong>     <span class="color-comment"># Indexing via numeric index</span>
2
&gt;&gt;&gt; <strong>s1[-1]</strong>
0
&gt;&gt;&gt; <strong>s1[::2]</strong>   <span class="color-comment"># Slicing via numeric index</span>
a    0
c    2
a    0
Name: x, dtype: int64</pre>

<h5>Selection with a List of Indexes</h5>

<pre class="color-example">
<span class="color-comment"># Selection (filtering) with a list of indexes</span>
&gt;&gt;&gt; <strong>s1[['a', 'c']]</strong>
a    5
a    3
c    2
Name: x, dtype: int64</pre>

<h5>Element-wise Operations</h5>
<pre class="color-example">
<span class="color-comment"># Element-wise Assignment via Indexing</span>
&gt;&gt;&gt; <strong>s1['a'] = 0</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    0
b    7
c    2
d    5
a    0
Name: x, dtype: int64</pre>

<h5>Constructing a Pandas' Series 2: From a Value-List with Default Numeric Index</h5>
<pre class="color-example">
<span class="color-comment"></span>&gt;&gt;&gt; <strong>s1 = pd.Series([5, 7, 2, 7, 3])</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    5
1    7
2    2
3    7
4    3
dtype: int64
&gt;&gt;&gt; <strong>s1.index</strong>
RangeIndex(start=0, stop=5, step=1)  <span class="color-comment"># An iterator</span>
&gt;&gt;&gt; <strong>s1.values</strong>
array([5, 7, 2, 7, 3], dtype=int64)

<span class="color-comment"># Indexing</span>
&gt;&gt;&gt; <strong>s1[1]</strong>
7
&gt;&gt;&gt; <strong><span class="color-error">s1[-1]</span></strong>    <span class="color-comment"># Cannot use negative index in this case!</span>
KeyError: -1

<span class="color-comment"># Slicing</span>
&gt;&gt;&gt; <strong>s1[::2]</strong>
0    5
2    2
4    3
dtype: int64</pre>

<h5>Constructing a Pandas' <span class="font-code">Series</span> 3: From a NumPy's 1D <span class="font-code">ndarray</span></h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>arr1d = np.array([1.1, 2.2, 3.3, 4.4])</strong>
&gt;&gt;&gt; <strong>s1 = pd.Series(arr1d, index=['a', 'b', 'c', 'd'])</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    1.1
b    2.2
c    3.3
d    4.4
dtype: float64

<span class="color-comment"># The NumPy's array is passed by reference.
# Modify NumPy's array affects Pandas' Series</span>
&gt;&gt;&gt; <strong>arr1d[0] = 99</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    99.0
b     2.2
c     3.3
d     4.4
dtype: float64</pre>

<h5>Construct a Pandas' <span class="font-code">Series</span> 4: From another Pandas' <span class="font-code">Series</span></h5>
<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([11, 22, 33, 44], index=['a', 'b', 'c', 'd'])</strong>
&gt;&gt;&gt; <strong>s2 = pd.Series(s1)</strong>
&gt;&gt;&gt; <strong>s2</strong>
a    11
b    22
c    33
d    44
dtype: int64
&gt;&gt;&gt; <strong>s2 is s1</strong>
False   <span class="color-comment"># different objects</span>
<span class="color-comment"># But the Series is passed by reference</span>
&gt;&gt;&gt; <strong>s1['d'] = 88</strong>   <span class="color-comment"># affect s4 too</span>
&gt;&gt;&gt; <strong>s2</strong>
a    11
b    22
c    33
d    88
dtype: int64</pre>

<h5>Constructing a Pandas' <span class="font-code">Series</span> 5: From a Python's Dictionary as Index-Value Pairs</h5>
<pre class="color-example">
<span class="color-comment"></span>&gt;&gt;&gt; <strong>dict = {'a': 11, 'b': 22, 'c': 33, 'd': 44}</strong>  <span class="color-comment"># keys are unique in dictionary</span>
&gt;&gt;&gt; <strong>s1 = pd.Series(dict)</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    11
b    22
c    33
d    44
dtype: int64

<span class="color-comment"># If index is provided, match index with the dict's key</span>
&gt;&gt;&gt; <strong>s2 = pd.Series(dict, index=['b', 'd', 'a', 'c', 'aa'])</strong>
&gt;&gt;&gt; <strong>s2</strong>
b     22.0      <span class="color-comment"># Order according to index</span>
d     44.0
a     11.0
c     33.0
aa     NaN      <span class="color-comment"># Missing value for this index is assigned NaN</span>
dtype: float64  <span class="color-comment"># NaN is float, all elements also converted to float</span></pre>

<h4>Operations on <span class="font-code">Series</span></h4>
<h5>Operations between a <span class="font-code">Series</span> and a Scalar</h5>

<p>The NumPy's element-wise arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>) and comparison operators (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>), as well as NumPy's module-level functions (such as <code>sum()</code>, <code>min()</code>, <code>max()</code>) are extended to support Pandas' <code>Series</code>. For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([5, 4, 3, 2, 1], index=['a', 'b', 'c', 'd', 'e'])</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    5
b    4
c    3
d    2
e    1
dtype: int64

<span class="color-comment"># Series &oplus; scalar</span>
&gt;&gt;&gt; <strong>s1 + 1</strong>
a    6
b    5
c    4
d    3
e    2

&gt;&gt;&gt; <strong>s1 &gt; 3</strong>
a     True
b     True
c    False
d    False
e    False
dtype: bool
&gt;&gt;&gt; <strong>s1[s1 &gt; 3]</strong>   <span class="color-comment"># Filtering with boolean Series</span>
a    5
b    4
dtype: int64</pre>

<h5>Operations between Two <span class="font-code">Series</span> are Index-based</h5>

Operations between Series (<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>**</code>) align values based on their index, which need not be the same length. The result index will be the sorted union of the two indexes.
<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([1, 2, 3, 4, 5], index=['a', 'b', 'c', 'd', 'e'])</strong>
&gt;&gt;&gt; <strong>s2 = pd.Series([4, 3, 2, 1], index=['c', 'a', 'b', 'aa'])</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    1
b    2
c    3
d    4
e    5
dtype: int64
&gt;&gt;&gt; <strong>s2</strong>
c     4
a     3
b     2
aa    1
dtype: int64

<span class="color-comment"># Operation aligns on their index. Resultant index is the sorted union</span>
&gt;&gt;&gt; <strong>s1 + s2</strong>
a     4.0    <span class="color-comment"># this index on both Series</span>
aa    NaN    <span class="color-comment"># this index is not in both, assign NaN</span>
b     4.0
c     7.0
d     NaN
e     NaN
dtype: float64  <span class="color-comment"># All elements converted to float, as NaN is float</span></pre>

<h5>Statistical Methods on <span class="font-code">Series</span></h5>

<p>NumPy's module-level statistical functions are extended to support Pandas' <code>Series</code>. For examples,</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([5, 4, 3, 2, 1], index=['a', 'b', 'c', 'd', 'e'])</strong>
&gt;&gt;&gt; <strong>np.sum(s1)</strong>  <span class="color-comment"># No pd.sum()</span>
15
&gt;&gt;&gt; <strong>s1.sum()</strong>    <span class="color-comment"># Same as above.</span>
15
&gt;&gt;&gt; <strong>np.cumsum(s1)</strong>
a     5
b     9
c    12
d    14
e    15
dtype: int64</pre>

<h5><span class="font-code">NaN</span> (Not A Number), <span class="font-code">Inf</span> (Positive Infinity) and <span class="font-code">-Inf</span> (Negative Infinity)</h5>

<p>The IEEE 754 standard for floating point representation supports 3 special floating point numbers (See &quot;Data Representation&quot; article):</p>
<ol>
<li><code>Inf</code> (Positive Integer): <code>1/0</code>, all positive floats are smaller than <code>Inf</code>.</li>
<li>-<code>Inf</code> (Negative Infinity): <code>-1/0</code>, all negative floats are bigger than <code>-Inf</code>.</li>
<li><code>NaN</code> (Not a Number): <code>0/0</code></li>
</ol>

<p>For examples,</p>
<pre class="color-example"><span class="color-comment"># Creating Inf, -Inf, NaN using float()</span>
&gt;&gt;&gt; <strong>f1, f2, f3 = float('inf'), float('-inf'), float('nan')</strong>
&gt;&gt;&gt; <strong>f1, f2, f3</strong>
(inf, -inf, nan)
&gt;&gt;&gt; <strong>type(f1), type(f2), type(f3)</strong>
(&lt;class 'float'&gt;, &lt;class 'float'&gt;, &lt;class 'float'&gt;)

<span class="color-comment"># Checking for infinity: math.isinf()
</span>&gt;&gt;&gt; <strong>import math</strong>
&gt;&gt;&gt; <strong>isinf(f1), isinf(f2), isinf(f3)</strong>
&gt;&gt;&gt; <strong>math.isinf(f1), math.isinf(f2), math.isinf(f3)</strong>
(True, True, False)

<span class="color-comment"># Using inf to set the initial min and max value</span>
&gt;&gt;&gt; <strong>initial_value = 5</strong>
&gt;&gt;&gt; <strong>min, max = min(5, float('inf')), max(5, float('-inf'))</strong>
&gt;&gt;&gt; <strong>min, max</strong>
(5, 5)

<span class="color-comment"># You can also use the attributes in math module</span>
&gt;&gt;&gt; <strong>f11, f12, f13 = math.inf, -math.inf, math.nan</strong>
&gt;&gt;&gt; <strong>f11, f12, f13</strong>
(inf, -inf, nan)

<span class="color-comment"># Or the attributes in numpy module</span>
&gt;&gt;&gt; <strong>f21, f22, f23 = np.inf, -np.inf, np.nan</strong>
&gt;&gt;&gt; <strong>f21, f22, f23</strong>
(inf, -inf, nan)</pre>

<p>In Data Analysis, <code>NaN</code> is often used to represent missing data, and needs to be excluded from statistical operations. Hence, statistical methods from <code>ndarray</code> have been overridden in Pandas to automatically exclude <code>NaN</code>. For examples,</p>

<pre class="color-example">
<span class="color-comment"># NumPy's ndarray does not excluded nan in statistical methods</span>
&gt;&gt;&gt; <strong>m1 = np.arange(12, dtype=float).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m1[0, 1] = np.nan</strong>   <span class="color-comment"># nan is a float, all elements converted to float</span>
&gt;&gt;&gt; <strong>m1</strong>
array([[ 0., nan,  2.,  3.],
       [ 4.,  5.,  6.,  7.],
       [ 8.,  9., 10., 11.]])
&gt;&gt;&gt; <strong>m1.sum()</strong>
nan
&gt;&gt;&gt; <strong>m1.sum(axis=0)</strong>
array([12., nan, 18., 21.])

<span class="color-comment"># Pandas excludes nan in statistical methods</span>
&gt;&gt;&gt; <strong>s1 = pd.Series([1, 2, np.NaN, 4, 5])</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    1.0
1    2.0
2    NaN
3    4.0
4    5.0
dtype: float64   <span class="color-comment"># nan is float, all elements converted to float</span>
&gt;&gt;&gt; <strong>s1.sum()</strong>
12.0   <span class="color-comment"># nan excluded</span></pre>

<h5>More Statistics Methods</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([3, 2, 2, 1, np.nan, 6, 8, 4], index=['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])</strong>
&gt;&gt;&gt; <strong>s1.describe()</strong>
count    7.000000   <span class="color-comment"># nan excluded</span>
mean     3.714286
std      2.497618
min      1.000000
25%      2.000000
50%      3.000000
75%      5.000000
max      8.000000
dtype: float64

<span class="color-comment"># These methods are extended from NumPy's ndarray, but nan excluded</span>
&gt;&gt;&gt; <strong>s1.mean()</strong>
3.7142857142857144
&gt;&gt;&gt; <strong>np.mean(s1)</strong>    <span class="color-comment"># Same as above</span>
3.7142857142857144
&gt;&gt;&gt; <strong>s1.median()</strong>
3.0
&gt;&gt;&gt; <strong>s1.std()</strong>
2.4976179127511156
&gt;&gt;&gt; <strong>s1.var()</strong><br />6.238095238095238</pre>

<h5>Correlation and Covariance between 2 <span class="font-code">Series</span></h5>
<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([3, 2, 2, 1, 6, 8, 4], index=['a', 'b', 'c', 'd', 'e', 'f', 'g'])</strong>
&gt;&gt;&gt; <strong>s2 = pd.Series([1, 1, 5, 1, 6, 9, 3], index=['a', 'b', 'c', 'd', 'e', 'f', 'g'])</strong>
&gt;&gt;&gt; <strong>s3 = pd.Series([1, 1, 5, 1, 6, 3, 9], index=['a', 'b', 'c', 'd', 'e', 'g', 'f'])</strong>  <span class="color-comment"># for verifying index-align</span>
<span class="color-comment">
# NumPy's correlation coefficients (not extended to Pandas)
# NumPy's ndarray does not support index</span>
&gt;&gt;&gt; <strong>np.corrcoef(s1, s2)</strong><span class="color-comment"></span>
array([[1.        , 0.85044339],
       [0.85044339, 1.        ]])   <span class="color-comment"># 2D array</span>
&gt;&gt;&gt; <strong>np.corrcoef(s1, s3)</strong>
array([[1.       , 0.3327822],
       [0.3327822, 1.       ]])     
    <span class="color-comment"># Different results, non-index-align for NumPy's operations</span>

<span class="color-comment"># Covariance (extended from NumPy to Pandas but index-align)</span>
&gt;&gt;&gt; <strong>s1.cov(s2)</strong>
6.57142857142857
&gt;&gt;&gt; <strong>s1.cov(s3)</strong>
6.57142857142857   <span class="color-comment"># Same result, index-align</span>
<span class="color-comment"></span>
<span class="color-comment"># Pandas' correlation coefficient index aligned</span>
&gt;&gt;&gt; <strong>s1.corr(s2)</strong>      <span class="color-comment"># No np.corr()</span>
0.8504433897747548   <span class="color-comment"># Scalar</span>
&gt;&gt;&gt; <strong>s1.corr(s3)</strong>
0.8504433897747548</pre>


<h5>The Pandas' <span class="font-code">Series</span> Member Functions <span class="font-code">unique()</span>, <span class="font-code">value_counts()</span>, <span class="font-code">isin()</span>, <span class="font-code">isnull()</span>, <span class="font-code">notnull()</span></h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([1, 2, 2, 1, 3, 3, 1], index=['a', 'a', 'b', 'c', 'c', 'b', 'a'])</strong>
   <span class="color-comment"># with duplicate values and indexes</span>
&gt;&gt;&gt; <strong>s1</strong>
a    1
a    2
b    2
c    1
c    3
b    3
a    1
dtype: int64

<span class="color-comment"># Series.unique() -&gt; ndarray</span>
&gt;&gt;&gt; <strong>s1.unique()</strong>   <span class="color-comment"># filter unique values</span>
array([1, 2, 3], dtype=int64)

<span class="color-comment"># s1.duplicated() -&gt; bool_Series</span>
&gt;&gt;&gt; <strong>s1.duplicated()</strong>   <span class="color-comment"># Check duplicated values</span>
a    False
a    False
b     True   <span class="color-comment"># value 2 duplicated</span>
c     True
c    False
b     True
a     True
dtype: bool

<span class="color-comment"># Series.value_counts() -&gt; int_Series</span>
&gt;&gt;&gt; <strong>s1.value_counts()</strong>  <span class="color-comment"># unique value vs counts</span>
1    3
3    2
2    2
dtype: int64

<span class="color-comment"># Series.isin() -&gt; bool_Series</span>
&gt;&gt;&gt; <strong>s1.isin([2, 3, 4])</strong>  <span class="color-comment"># Check if the value is in the given list element-wise, return bool</span>
a    False
a     True
b     True
c    False
c     True
b     True
a    False
dtype: bool
&gt;&gt;&gt; <strong>s1[s1.isin([2, 3, 4])]</strong>   <span class="color-comment"># Filter with a boolean Series</span>
a    2
b    2
c    3
b    3
dtype: int64

<span class="color-comment"># Series.isnull() -&gt; bool_Series
# Series.notnull() -&gt; bool_Series</span>
&gt;&gt;&gt; <strong>s2 = pd.Series([1, 2, np.NaN, 4, 5])</strong>
   <span class="color-comment"># We could use np.NaN (Not A Number) to indicate missing value or non-numerical value</span>
&gt;&gt;&gt; <strong>s2.isnull()</strong>   <span class="color-comment"># Check if value is NaN element-wise</span>
0    False
1    False
2     True
3    False
4    False
dtype: bool
&gt;&gt;&gt; <strong>s2.notnull()</strong>  <span class="color-comment"># Inverse of isnull()</span>
0     True
1     True
2    False
3     True
4     True
dtype: bool
&gt;&gt;&gt; <strong>s2[s2.notnull()]</strong>  <span class="color-comment"># Filter out NaN</span>
0    1.0
1    2.0
3    4.0
4    5.0
dtype: float64</pre>

<h5>Sorting: <span class="font-code">sort_index()</span>, <span class="font-code">sort_values()</span><br />
  Ranking: <span class="font-code">rank()</span></h5>
<pre class="color-example">
&gt;&gt;&gt; <strong>s1 = pd.Series([3, 2, 2, 1, 6, 8, 4], index=['a', 'd', 'b', 'c', 'c', 'e', 'a'])</strong>
&gt;&gt;&gt; <strong>s1.sort_index()</strong>
a    3
a    4
b    2
c    1
c    6
d    2
e    8
dtype: int64
&gt;&gt;&gt; <strong>s1.sort_values()</strong>
c    1
d    2
b    2
a    3
a    4
c    6
e    8
dtype: int64
&gt;&gt;&gt; <strong>s1.rank()</strong>
a    4.0
d    2.5
b    2.5
c    1.0
c    6.0
e    7.0
a    5.0
dtype: float64</pre>

<h4>Pandas' Categorical Data Type</h4>
<p>A categorical variable takes on a limited, and usually fixed, number of possible values. There are two kinds of categorical data:</p>
<ol>
<li>Nominal (Unordered): e.g., gender, social class, blood type, country.</li>
<li>Ordinal (Ordered): e.g. &quot;strongly agree&quot; vs &quot;agree&quot;, band 1, 2, 3,...</li>
</ol>

<p>Numerical operations (such as additions, divisions, ) cannot be applied to categories data.</p>

<p>Pandas supports a &quot;category&quot; data type (<code>dtype</code>). All values of categorical data are either in categories or <code>np.nan</code> (for missing data).</p>

<h5>Constructing a Categorical <span class="font-code">Series</span> 1: Using <span class="font-code">dtype='category'</span></h5>

<pre class="color-example">
<span class="color-comment"></span>&gt;&gt;&gt; <strong>s1 = pd.Series(['a', 'b', 'c', 'd', 'a'], dtype='category')</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    a
1    b
2    c
3    d
4    a
dtype: category
Categories (4, object): [a, b, c, d]
&gt;&gt;&gt; <strong>s1.dtype</strong>
CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=False)

&gt;&gt;&gt; <strong>s1.cat.categories</strong>
Index(['a', 'b', 'c', 'd'], dtype='object')
&gt;&gt;&gt; <strong>s1.cat.ordered</strong>
False
&gt;&gt;&gt; <strong>s1.cat.codes</strong>
0    0
1    1
2    2
3    3
4    0
dtype: int8

&gt;&gt;&gt; <strong>s1.value_counts()</strong>
a    2
d    1
c    1
b    1
dtype: int64</pre>

<p>Notes:</p>
<ol>
<li>The categories are inferred from the data</li>
<li>Always &quot;Unordered&quot;</li>
</ol>

<h5>Constructing a Categorical <span class="font-code">Series</span> 2: Using a <span class="font-code">CategoricalDtype</span><span class="font-code"></span></h5>

<pre class="color-example">
<span class="color-comment"># Create a customized 'CategoricalDType</span>'
&gt;&gt;&gt; <strong>from pandas.api.types import CategoricalDtype</strong>
&gt;&gt;&gt; <strong>cat = CategoricalDtype(categories=['b', 'c', 'd'], ordered=True)</strong>
&gt;&gt;&gt; <strong>cat</strong>
CategoricalDtype(categories=['b', 'c', 'd'], ordered=True)  <span class="color-comment"># ordered</span>

&gt;&gt;&gt; <strong>s1 = pd.Series(['a', 'b', 'c', 'a'], dtype=cat)</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    NaN   <span class="color-comment"># no category</span>
1      b
2      c
3    NaN
dtype: category
Categories (3, object): [b &lt; c &lt; d]
&gt;&gt;&gt; <strong>s1.min(), s1.max()</strong>
(nan, 'c')</pre>

<h5>Constructing a Categorical <span class="font-code">Series</span> 2: Converting using <span class="font-code">astype()</span></h5>
<pre class="color-example">
<span class="color-comment"></span>&gt;&gt;&gt; <strong>s1 = pd.Series(['a', 'b', 'b', 'a', 'c'])</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    a
1    b
2    b
3    a
4    c
dtype: object
&gt;&gt;&gt; <strong>s2 = s1.astype('category')</strong>
&gt;&gt;&gt; <strong>s2</strong>
0    a
1    b
2    b
3    a
4    c
dtype: category
Categories (3, object): [a, b, c]  <span class="color-comment"># Unordered</span>
&gt;&gt;&gt; <strong>s2.dtype</strong>
CategoricalDtype(categories=['a', 'b', 'c'], ordered=False)

&gt;&gt;&gt; <strong>from pandas.api.types import CategoricalDtype</strong>
&gt;&gt;&gt; <strong>cat = CategoricalDtype(categories=['b', 'c', 'd'], ordered=True)</strong>
&gt;&gt;&gt; <strong>s3 = pd.Series(['a', 'b', 'c', 'a'])</strong>
&gt;&gt;&gt; <strong>s3 = s3.astype(cat)</strong>
&gt;&gt;&gt; <strong>s3</strong>
0    NaN
1      b
2      c
3    NaN
dtype: category
Categories (3, object): [b &lt; c &lt; d]</pre>

<h5>Constructing a Categorical <span class="font-code">Series</span> 3: via Pandas' <span class="font-code">Categorical()</span></h5>

<pre class="color-example">
<span class="color-comment"></span><span class="color-comment"># Create an &quot;ordered&quot; Categorical</span>
&gt;&gt;&gt; <strong>cat = pd.Categorical(['a','b','c','b'], ordered=True, categories=['c', 'b', 'a'])</strong>
&gt;&gt;&gt; <strong>cat</strong>
[a, b, c, b]
Categories (3, object): [c &lt; b &lt; a]   <span class="color-comment"># Ordered</span>
&gt;&gt;&gt; <strong>type(cat)</strong>
&lt;class 'pandas.core.arrays.categorical.Categorical'&gt;
<span class="color-comment"># Create a Series from Categorical</span>
&gt;&gt;&gt; <strong>s1 = pd.Series(cat)</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    a
1    b
2    c
3    b
dtype: category
Categories (3, object): [c &lt; b &lt; a]
&gt;&gt;&gt; <strong>s1.min(), s1.max()</strong>
('c', 'a')</pre>

<h5>Operations on Categorical Data</h5>

<pre class="color-example">
<span class="color-comment"># Sorting Ordered Categorical Data</span>
&gt;&gt;&gt; <strong>s1 = pd.Series(['a', 'b', 'c', 'a']).astype(CategoricalDtype(ordered=True))</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    a
1    b
2    c
3    a
dtype: category
Categories (3, object): [a &lt; b &lt; c]

&gt;&gt;&gt; <strong>s1.sort_values(inplace=True)</strong>
&gt;&gt;&gt; <strong>s1</strong>
0    a
3    a
1    b
2    c
dtype: category
Categories (3, object): [a &lt; b &lt; c]</pre>

<p>[TODO] more</p>

<h4>The Pandas' <span class="font-code">DataFrame</span> Class</h4>

<p>A Pandas' <code>DataFrame</code> models a <em>labeled</em> 2D tabular data, similar to an Excel spreadsheet, or a SQL relational database table. The pandas' <code>DataFrame</code> is an extension of Pandas' 1D labeled sequences <code>Series</code> to two-dimensional. A <code>DataFrame</code> consists of a number of columns with a common row index (label), and a column header. Each column has its own data type. All elements in a column have the same data type.</p>

<img class="image-center" src="images/Python_Pandas_DataFrame.png" alt="Pandas Series" />

<p>To construct a Pandas' <code>DataFrame</code>, invoke the constructor:</p>
<pre class="color-syntax">
&gt;&gt;&gt; <strong>import pandas as pd</strong>
&gt;&gt;&gt; <strong>help(pd.DataFrame)</strong>
DataFrame(data=None, index=None, columns=None, dtype=None)
    <span class="color-comment"># data: can be a NumPy ndarray, dict, or Pandas DataFrame
    #       dict can contain Series, arrays, constants, or list-like objects
    # index: array-like or an Index object, default to RangeIndex
    # columns: array-like or an Index object, default to RangeIndex</span></pre>

<p>The <code>data</code> can be obtained in the following ways:</p>
<ul>
<li>from columns of Pandas' <code>Series</code>, or <code>list</code>, packed in a dictionary with column names.</li>
<li>from a 2D NumPy's <code>ndarray</code>.</li>
<li>from a file, such as a CSV file.</li>
<li>from another Pandas' <code>DataFrame</code>.</li>
</ul>

<h5>Creating a Pandas' <span class="font-code">DataFrame</span> 1: From columns of <span class="font-code">Series</span>, packed in a <span class="font-code">dict</span> with Column Names</h5>
<pre class="color-example">
&gt;&gt;&gt; <strong>import numpy as np</strong>
&gt;&gt;&gt; <strong>import pandas as pd</strong>
&gt;&gt;&gt; <strong>s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])</strong>
&gt;&gt;&gt; <strong>s1</strong>
a    1
b    2
c    3
dtype: int64
&gt;&gt;&gt; <strong>s2 = pd.Series([11, 33, 22, 44], index=['a', 'c', 'b', 'd'])</strong>
&gt;&gt;&gt; <strong>s2</strong>
a    11
c    33
b    22
d    44
dtype: int64
&gt;&gt;&gt; <strong>df = pd.DataFrame({'x1': s1, 'x2': s2})</strong>   <span class="color-comment"># dictionary of column-header:Series
</span>&gt;&gt;&gt; <strong>df</strong>   <span class="color-comment"># DataFrame is a 2D table with column header and row index
         # Index-align, resultant index is sorted union of both indexes</span>
    x1  x2
a  1.0  11
b  2.0  22
c  3.0  33
d  NaN  44   <span class="color-comment"># Missing value is assigned NaN (Not A Number) which is a float
             # column x1 is converted to float</span>
&gt;&gt; <strong>type(df)</strong>
&lt;class 'pandas.core.frame.DataFrame'&gt;
<span class="color-comment">
# Check Data Types</span>
&gt;&gt;&gt; <strong>df.dtypes</strong>     <span class="color-comment"># Data types of columns</span>
x1    float64
x2      int64
dtype: object

<span class="color-comment"># Select a column</span>
>>> <strong>df['x1']</strong>      <span class="color-comment"># Select a column</span>
a    1.0
b    2.0
c    3.0
d    NaN
Name: x1, dtype: float64
&gt;&gt;&gt; <strong>df.x1</strong>         <span class="color-comment"># Same as above</span>
a    1.0
b    2.0
c    3.0
d    NaN
Name: x1, dtype: float64
&gt;&gt;&gt; <strong>type(df['x1'])</strong>
&lt;class 'pandas.core.series.Series'&gt;   <span class="color-comment"># A Series</span>
&gt;&gt;&gt; <strong>df.x1.dtype</strong>   <span class="color-comment"># Data type of a column</span>
dtype('float64')

<span class="color-comment"># Select a list of columns</span>
&gt;&gt;&gt; <strong>df[['x1', 'x2']]</strong>
    x1  x2
a  1.0  11
b  2.0  22
c  3.0  33
d  NaN  44

<span class="color-comment"># Check column-header, row-index and data-value</span>
&gt;&gt;&gt; <strong>df.columns</strong>     <span class="color-comment"># columns header</span>
Index(['x1', 'x2'], dtype='object')
&gt;&gt;&gt; <strong>df.index</strong>       <span class="color-comment"># rows index</span>
Index(['a', 'b', 'c', 'd'], dtype='object')
&gt;&gt;&gt; <strong>df.values</strong>      <span class="color-comment"># data</span>
array([[ 1., 11.],
       [ 2., 22.],
       [ 3., 33.],
       [nan, 44.]])   <span class="color-comment"># Return a ndarray (of the same dtype)</span>
&gt;&gt;&gt; <strong>type(df.values)</strong><span class="color-comment"></span>
&lt;class 'numpy.ndarray'&gt;

<span class="color-comment"># Write (Save) to CSV text file</span>
&gt;&gt;&gt; <strong>df.to_csv('data_with_labels.csv')</strong>  <span class="color-comment"># default with column header and row index</span>
<span class="color-comment"># Contents of the CSV file</span>
,x1,x2
a,1.0,11
b,2.0,22
c,3.0,33
d,,44
<span class="color-comment"></span>&gt;&gt;&gt; <strong>df.to_csv('data_without_labels.csv', index=False, header=False)</strong>  <span class="color-comment"># No column header and row index</span>
<span class="color-comment"># Contents of the CSV file</span>
1.0,11
2.0,22
3.0,33
,44</pre>


<h5>Creating a Pandas' <span class="font-code">DataFrame</span> 2: Load from a CSV file</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df1 = pd.read_csv('data_with_labels.csv')</strong>   <span class="color-comment"># default with column header, no row index</span>
&gt;&gt;&gt; <strong>df1</strong>
  Unnamed: 0   x1  x2
0          a  1.0  11
1          b  2.0  22
2          c  3.0  33
3          d  NaN  44

&gt;&gt;&gt; <strong>df2 = pd.read_csv('data_with_labels.csv', index_col=0)</strong>   <span class="color-comment"># First column is the row index</span>
&gt;&gt;&gt; <strong>df2</strong>
    x1  x2
a  1.0  11
b  2.0  22
c  3.0  33
d  NaN  44

&gt;&gt;&gt; <strong>df3 = pd.read_csv('data_without_labels.csv', names=['y1', 'y2'])</strong>  <span class="color-comment"># Provide column names</span>
&gt;&gt;&gt; <strong>df3</strong>
    y1  y2
0  1.0  11
1  2.0  22
2  3.0  33
3  NaN  44

<span class="color-comment"># Read csv from Console</span>
&gt;&gt;&gt; <strong>from io import StringIO</strong>   <span class="color-comment"># Python 3</span>
&gt;&gt;&gt; <strong>rawText = StringIO(&quot;&quot;&quot;
       x1        x2        cat
    0  101.23  1.39  Medium
    1  103.26  1.86  Medium
    2  202.76  8.87  High
    3  142.40  5.25  Medium-High
    &quot;&quot;&quot;)</strong>
&gt;&gt;&gt; <strong>rawText</strong>
&lt;_io.StringIO object at ...&gt;
&gt;&gt;&gt; <strong>df4 = pd.read_csv(rawText, sep = &quot;\s+&quot;)</strong>  <span class="color-comment"># 'sep' is one or more spaces</span>
&gt;&gt;&gt; <strong>df4</strong>
       x1    x2          cat
0  101.23  1.39       Medium
1  103.26  1.86       Medium
2  202.76  8.87         High
3  142.40  5.25  Medium-High
&gt;&gt;&gt; <strong>df4.dtypes</strong>
x1     float64
x2     float64
cat     object
dtype: object</pre>

<h5>Creating a Pandas' <span class="font-code">DataFrame</span> 3: From columns of <span class="font-code">list</span>, packed in a <span class="font-code">dict</span> with Column Names</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>lst_x1 = [1, 2, 3, 4, 5]</strong>
&gt;&gt;&gt; <strong>lst_x2 = [1.1, 2.2, 3.3, 4.4, 5.5]</strong>
&gt;&gt;&gt; <strong>lst_x3 = ['a', 'b', 'c', 'd', 'e']</strong>
   <span class="color-comment"># The column lists shall have the same length</span>
&gt;&gt;&gt; <strong>df = pd.DataFrame({'x1': lst_x1, 'x2': lst_x2, 'x3': lst_x3})</strong>  <span class="color-comment"># dict of {columnName:lst}</span>
&gt;&gt;&gt; <strong>df</strong>
   x1   x2 x3
0   1  1.1  a
1   2  2.2  b
2   3  3.3  c
3   4  4.4  d
4   5  5.5  e
&gt;&gt;&gt; <strong>df.dtypes</strong>
x1      int64
x2    float64
x3     object
dtype: object

<span class="color-comment"># Notes:</span>
# df = pd.DataFrame({'x1': pd.Series(lst_x1), 'x2': pd.Series(lst_x2)})  <span class="color-comment"># Missing values get NaN</span>

<span class="color-comment"># Adding a column</span>
&gt;&gt;&gt; <strong>df['x4'] = 9</strong>   <span class="color-comment"># Scalar broadcasts to all rows</span>
&gt;&gt;&gt; <strong>df</strong>
   x1   x2 x3  x4
0   1  1.1  a   9
1   2  2.2  b   9
2   3  3.3  c   9
3   4  4.4  d   9
4   5  5.5  e   9
<span class="color-comment"># Add another column</span>
&gt;&gt;&gt; <strong>df['x5'] = [51, 52, 53, 54, 55]</strong>   <span class="color-comment"># length of list shall match index</span>
&gt;&gt;&gt; <strong>df</strong>
   x1   x2 x3  x4  x5
0   1  1.1  a   9  51
1   2  2.2  b   9  52
2   3  3.3  c   9  53
3   4  4.4  d   9  54
4   5  5.5  e   9  55
>>> df[['x1','x5', 'x2']]
   x1  x5   x2
0   1  51  1.1
1   2  52  2.2
2   3  53  3.3
3   4  54  4.4
4   5  55  5.5

<span class="color-comment"># Editing row index</span>
&gt;&gt;&gt; <strong>df.index</strong>
RangeIndex(start=0, stop=5, step=1)
&gt;&gt;&gt; <strong>df.index = ['r1', 'r2', 'r3', 'r4', 'r5']</strong>
&gt;&gt;&gt; <strong>df.index</strong>
Index(['r1', 'r2', 'r3', 'r4', 'r5'], dtype='object')
&gt;&gt;&gt; <strong>df</strong>
    x1   x2 x3  x4  x5
r1   1  1.1  a   9  51
r2   2  2.2  b   9  52
r3   3  3.3  c   9  53
r4   4  4.4  d   9  54
r5   5  5.5  e   9  55

<span class="color-comment"># Selecting columns by column names</span>
&gt;&gt;&gt; <strong>df['x3']</strong>
0    a
1    b
2    c
3    d
4    e
Name: x3, dtype: object
&gt;&gt;&gt; <strong>df.x3</strong>   <span class="color-comment"># Same as above</span>
0    a
1    b
2    c
3    d
4    e
Name: x3, dtype: object
&gt;&gt;&gt; <strong>df[['x1','x5', 'x2']]</strong>   <span class="color-comment"># Reorder</span>
   x1  x5   x2
0   1  51  1.1
1   2  52  2.2
2   3  53  3.3
3   4  54  4.4
4   5  55  5.5

<span class="color-comment"># Editing column header</span>
&gt;&gt;&gt; <strong>df.columns</strong>
Index(['x1', 'x2', 'x3', 'x4', 'x5'], dtype='object')
&gt;&gt;&gt; <strong>df.columns = ['AA', 'BB', 'CC', 'DD', 'EE']</strong>
&gt;&gt;&gt; <strong>df</strong>
    AA   BB CC  DD  EE
r1   1  1.1  a   9  51
r2   2  2.2  b   9  52
r3   3  3.3  c   9  53
r4   4  4.4  d   9  54
r5   5  5.5  e   9  55

<span class="color-comment"># Column (Series) Operations</span>
&gt;&gt;&gt; <strong>type(df['AA'])</strong>    <span class="color-comment"># Column is a Pandas' Series</span>
&lt;class 'pandas.core.series.Series'&gt;
&gt;&gt;&gt; <strong>df['AA'] += 1</strong>     <span class="color-comment"># Apply arithmetic operation</span>
&gt;&gt;&gt; <strong>df</strong>
    AA   BB CC  DD  EE
r1   2  1.1  a   9  51
r2   3  2.2  b   9  52
r3   4  3.3  c   9  53
r4   5  4.4  d   9  54
r5   6  5.5  e   9  55
&gt;&gt;&gt; <strong>del df['CC']</strong>      <span class="color-comment"># del column</span>
&gt;&gt;&gt; <strong>df</strong>
    AA   BB  DD  EE
r1   2  1.1   9  51
r2   3  2.2   9  52
r3   4  3.3   9  53
r4   5  4.4   9  54
r5   6  5.5   9  55</pre>

<h5>Creating a Pandas' <span class="font-code">DataFrame</span> 4: From NumPy's Multi-dimensional Array</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>m = np.arange(1, 13).reshape(3, 4)</strong>
&gt;&gt;&gt; <strong>m</strong>
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
&gt;&gt;&gt; <strong>df1 = pd.DataFrame(m)</strong>  <span class="color-comment"># with default column-header and row-index</span>

&gt;&gt;&gt; <strong>df2 = pd.DataFrame(m, index=['r1', 'r2', 'r3'], columns=['c1', 'c2', 'c3', 'c4'], dtype=float)</strong>
   <span class="color-comment"># Set the column-header, row-index and datatype</span>
&gt;&gt;&gt; <strong>df2</strong>
      c1    c2    c3    c4
r1  99.0   2.0   3.0   4.0
r2   5.0   6.0   7.0   8.0
r3   9.0  10.0  11.0  12.0

<span class="color-comment"># Modifying the NumPy's array</span>
&gt;&gt;&gt; <strong>m[0, 0] = 99</strong>
&gt;&gt;&gt; <strong>df1</strong>
    0   1   2   3
0  <span class="color-new">99</span>   2   3   4   <span class="color-comment"># This is affected, passed by reference</span>
1   5   6   7   8
2   9  10  11  12
&gt;&gt;&gt; <strong>df2</strong>
     c1    c2    c3    c4
r1  <span class="color-new">1.0</span>   2.0   3.0   4.0  <span class="color-comment"># This is not affected due to change in dtype</span>
r2  5.0   6.0   7.0   8.0
r3  9.0  10.0  11.0  12.0</pre>

<h5>Creating a Pandas' <span class="font-code">DataFrame</span> 5: From nested-<span class="font-code">list</span></h5>

<pre class="color-example">
<span class="color-comment"></span>&gt;&gt;&gt; <strong>data = [[1, 2, 3], [4, 5, 6]]</strong>
&gt;&gt;&gt; <strong>df = pd.DataFrame(data)</strong>   <span class="color-comment"># default column-header and row-index</span>
&gt;&gt;&gt; df
   0  1  2
0  1  2  3
1  4  5  6

&gt;&gt;&gt; <strong>df1 = pd.DataFrame([[1, 2, 3, 4]] * 3, columns=['a', 'b', 'c', 'd'])</strong>
&gt;&gt;&gt; <strong>df1</strong>
   a  b  c  d
0  1  2  3  4
1  1  2  3  4
2  1  2  3  4</pre>

<h4>Operations on <span class="font-code">DataFrame</span></h4>

<h5>Selecting a Column or a List of Columns: <span class="font-code">[colHdr|colHdrLst]</span></h5>

<p><code><em>dataframe</em>[<em>colHdr</em>|<em>colHdrLst</em>]</code>: Access a column or a list of columns</p>


<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame({'x1': [1, 2, 3, 4, 5],
                       'x2': [1.1, 2.2, 3.3, 4.4, 5.5],
                       'x3': ['a', 'b', 'c', 'd', 'e']},
                      index=['r1', 'r2', 'r3', 'r4', 'r5'])</strong>
&gt;&gt;&gt; <strong>df</strong>
    x1   x2 x3
r1   1  1.1  a
r2   2  2.2  b
r3   3  3.3  c
r4   4  4.4  d
r5   5  5.5  e
&gt;&gt;&gt; <strong>df['x2']</strong>   <span class="color-comment"># Select one column with indexing</span>
r1    1.1
r2    2.2
r3    3.3
r4    4.4
r5    5.5
Name: x2, dtype: float64
&gt;&gt;&gt; <strong>type(df['x2'])</strong>
&lt;class 'pandas.core.series.Series'&gt;   <span class="color-comment"># A one-column Series</span>
&gt;&gt;&gt; <strong>df.x2</strong>   <span class="color-comment"># Select one column with dot</span>
r1    1.1
r2    2.2
r3    3.3
r4    4.4
r5    5.5
Name: x2, dtype: float64
&gt;&gt;&gt; <strong>df[['x3', 'x1']]</strong>   <span class="color-comment"># Select a list of columns</span>
   x3  x1
r1  a   1
r2  b   2
r3  c   3
r4  d   4
r5  e   5
&gt;&gt;&gt; <strong>type(df[['x3', 'x1']])</strong>
&lt;class 'pandas.core.frame.DataFrame'&gt;   <span class="color-comment"># A multi-column DataFrame</span></pre>

<h5>Selecting (Filtering) Rows and Columns: <span class="font-code">loc[]</span>, <span class="font-code">iloc[]</span>, <span class="font-code">at[]</span>, <span class="font-code">iat[]</span></h5>

<p><code><em>dataframe</em>.loc[<em>rowIdx</em>, <em>colHdr</em>]</code>: Access a group of rows and columns by label(s) or a boolean array. Allowed inputs are:</p>
<ul>
<li>A single label, e.g., <code>'a'</code>.</li>
<li>A list or array of labels, e.g., <code>['a', 'b', 'c']</code>.</li>
<li>A slice object with labels, e.g., <code>'a':'f'</code> (both included).</li>
<li>A boolean array of the same length as the axis being sliced, e.g., [<code>True</code>, <code>False</code>, <code>True</code>].</li>
<li>A callable function with one argument (the calling <code>Series</code>, <code>DataFrame</code> or <code>Panel</code>) and that returns valid output for indexing (one of the above)</li>
</ul>

<p><code><em>dataframe</em>.iloc[<em>rowIdxI</em>, <em>colHdrI</em>]</code>: for integer-location based indexing for selection by position. Allowed inputs are:</p>
<ul>
<li>An integer, e.g., <code>5</code>.</li>
<li>A list or array of integers, e.g., <code>[4, 3, 0]</code>.</li>
<li>A slice object with <code>int</code>s, e.g., <code>1:7:2</code> (start included, end excluded).</li>
<li>A boolean array of the same length as the axis being sliced, e.g., [<code>True</code>, <code>False</code>, <code>True</code>].</li>
<li>A callable function with one argument (the calling <code>Series</code>, <code>DataFrame</code> or <code>Panel</code>) and that returns valid output for indexing (one of the above).</li>
</ul>

<p><code><em>dataframe</em>.at[<em>rowIdx</em>, <em>colHdr</em>]</code>: Access a single value for a row/column label pair.</p>

<p><code><em>dataframe</em>.iat[<em>rowIdx</em>, <em>colHdr</em>]</code>: Access a single value for a row/column integer index.</p>

<pre class="color-example">
<span class="color-comment"># Create a Pandas' DataFrame</span>
&gt;&gt;&gt; <strong>df = pd.DataFrame({'x1': [1, 2, 3, 4, 5, 6, 7], 
                       'x2': [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7], 
                       'x3': ['a', 'b', 'c', 'd', 'e', 'f', 'g']},
                      index=['r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7'])</strong>
&gt;&gt;&gt; <strong>df</strong>
    x1   x2 x3
r1   1  1.1  a
r2   2  2.2  b
r3   3  3.3  c
r4   4  4.4  d
r5   5  5.5  e
r6   6  6.6  f
r7   7  7.7  g

&gt;&gt;&gt; <strong>df.head(2)</strong>     <span class="color-comment"># First n rows, default n=5</span>
    x1   x2 x3
r1   1  1.1  a
r2   2  2.2  b
&gt;&gt;&gt; <strong>df.tail(2)</strong>     <span class="color-comment"># Last n rows</span>
    x1   x2 x3
r5   5  5.5  e
r6   6  6.6  f
r7   7  7.7  g

<span class="color-comment"></span><span class="color-comment"># Selection (Filtering) via [row-index, column-header] using loc() and iloc()</span>
&gt;&gt;&gt; <strong>help(df.loc)</strong>

<span class="color-comment"># row-index</span>
&gt;&gt;&gt; <strong>df.loc['r3']</strong>
x1      3
x2    3.3
x3      c
Name: r3, dtype: object
&gt;&gt;&gt; <strong>type(df.loc['r3'])</strong>
&lt;class 'pandas.core.series.Series'&gt;   <span class="color-comment"># return a one-column Series</span>
&gt;&gt;&gt; <strong>df.loc['r3':'r5']</strong>   <span class="color-comment"># by row start and end index, both included</span>
    x1   x2 x3
r3   3  3.3  c
r4   4  4.4  d
r5   5  5.5  e
&gt;&gt;&gt; <strong>type(df.loc['r3':'r5'])</strong>
&lt;class 'pandas.core.frame.DataFrame'&gt;  <span class="color-comment"># return a multi-column DataFrame</span>
&gt;&gt;&gt; <strong>df.loc[['r2', 'r4']]</strong>   <span class="color-comment"># list of indexes</span>
    x1   x2 x3
r2   2  2.2  b
r4   4  4.4  d

<span class="color-comment"># RowIndex and ColumnHeader</span>
&gt;&gt;&gt; <strong>df.loc['r3', 'x3']</strong>    <span class="color-comment"># Single cell</span>
'c'
&gt;&gt;&gt; <strong>df.loc[['r4', 'r2'], ['x3', 'x1']]</strong>   <span class="color-comment"># row and column lists</span>
   x3  x1
r4  d   4
r2  b   2
&gt;&gt;&gt; <strong>df.loc['r2':'r4', 'x1':'x2']</strong>  <span class="color-comment"># row and column slices</span>
    x1   x2
r2   2  2.2
r3   3  3.3
r4   4  4.4
&gt;&gt;&gt; <strong>df.loc['r2':'r5':2, 'x1':'x3':2]</strong>    <span class="color-comment"># slices with step</span>
    x1 x3
r2   2  b
r4   4  d

&gt;&gt;&gt; <strong>df.loc[[True, False, True, True, False, False, False]]</strong>  <span class="color-comment"># bool list with the same length as row axis</span>
    x1   x2 x3
r1   1  1.1  a
r3   3  3.3  c
r4   4  4.4  d
&gt;&gt;&gt; <strong>df.loc[df['x1'] > 5]</strong>   <span class="color-comment"># Conditional that returns a bool list</span>
    x1   x2 x3
r6   6  6.6  f
r7   7  7.7  g
&gt;&gt;&gt; <strong>df.loc[lambda df: df['x1'] &gt; 5]</strong>  <span class="color-comment"># A function that returns a bool list</span>
    x1   x2 x3
r6   6  6.6  f
r7   7  7.7  g

<span class="color-comment"># Using numerical indexes</span>
&gt;&gt;&gt; <strong>help(df.iloc)</strong>
&gt;&gt;&gt; <strong>df.iloc[2]</strong>    <span class="color-comment"># by row integer index (positional indexing)</span>
x1      3
x2    3.3
x3      c
Name: r3, dtype: object
&gt;&gt;&gt; <strong>df.iloc[2, 2]</strong>   <span class="color-comment"># row and column integer indexes</span>
'c'
&gt;&gt;&gt; <strong>df.iloc[2:5]</strong>   <span class="color-comment"># by start (inclusive) and end (exclusive) integer index</span>
    x1   x2 x3
r3   3  3.3  c
r4   4  4.4  d
r5   5  5.5  e
&gt;&gt;&gt; <strong>df.iloc[::3, ::2]</strong>
    x1 x3
r1   1  a
r4   4  d
r7   7  g

<span class="color-comment"># Selection (Filtering) via [row-index, column-header] using at() and iat()</span>
&gt;&gt;&gt; <strong>help(df.at)</strong>
&gt;&gt;&gt; <strong>df.at['r3', 'x2']</strong>
3.3
&gt;&gt;&gt; <strong>df['x2']['r3']</strong>   <span class="color-comment"># Same as above</span>
3.3
&gt;&gt;&gt; <strong>help(df.iat)</strong>
&gt;&gt;&gt; <strong>df.iat[2, 1]</strong>
3.3</pre>

<h5>Testing Membership: <span class="font-code">isin()</span></h5>

<pre class="color-example">&gt;&gt;&gt; <strong>df = pd.DataFrame(np.arange(1,13).reshape(3, 4))</strong>
&gt;&gt;&gt; <strong>df</strong>
   0   1   2   3
0  1   2   3   4
1  5   6   7   8
2  9  10  11  12
&gt;&gt;&gt; <strong>df.isin([5])</strong>   <span class="color-comment"># Check if the data-values are in the list</span>
       0      1      2      3
0  False  False  False  False
1   True  False  False  False
2  False  False  False  False
&gt;&gt;&gt; <strong>df.isin([5, 8, 13])</strong>
       0      1      2      3
0  False  False  False  False
1   True  False  False   True
2  False  False  False  False
&gt;&gt;&gt; <strong>df[df.isin([5, 8, 13])]</strong>   <span class="color-comment"># Filtering with a boolean DataFrame</span>
     0   1   2    3
0  NaN NaN NaN  NaN
1  5.0 NaN NaN  8.0
2  NaN NaN NaN  NaN</pre>

<h5>Operations on Row-Index</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.arange(1,13).reshape(3, 4), index=['red', 'green', 'blue'])</strong>
&gt;&gt;&gt; <strong>df</strong>
       0   1   2   3
red    1   2   3   4
green  5   6   7   8
blue   9  10  11  12
&gt;&gt;&gt; <strong>df.index</strong>
Index(['red', 'green', 'blue'], dtype='object')
&gt;&gt;&gt; <strong>df.index.is_unique</strong>
True

<span class="color-comment"># Dropping rows</span>
&gt;&gt;&gt; <strong>df.drop(['green', 'red'])</strong>   <span class="color-comment"># Drop rows with these indexes, return a new DataFrame</span>
      0   1   2   3
blue  9  10  11  12

<span class="color-comment"># Dropping columns</span>
&gt;&gt;&gt; <strong>df.drop([0, 3], axis=1)</strong>     <span class="color-comment"># axis=1 for columns</span>
        1   2
red     2   3
green   6   7
blue   10  11</pre>

<h5>Arithmetic and Comparison Operations Between a <span class="font-code">DataFrame</span> and a Scalar</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.arange(1,13).reshape(3, 4), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df</strong>
       c1  c2  c3  c4
red     1   2   3   4
green   5   6   7   8
blue    9  10  11  12
&gt;&gt;&gt; <strong>df + 10</strong>    <span class="color-comment"># apply to all values element-wise</span>
       c1  c2  c3  c4
red    11  12  13  14
green  15  16  17  18
blue   19  20  21  22
&gt;&gt;&gt; df * 2
       c1  c2  c3  c4
red     2   4   6   8
green  10  12  14  16
blue   18  20  22  24
&gt;&gt;&gt; df &lt; 8
          c1     c2     c3     c4
red     True   True   True   True
green   True   True   True  False
blue   False  False  False  False</pre>

<h5>Functions on <span class="font-code">DataFrame</span></h5>

<p>You can apply most of the NumPy's functions (such as mathematical and statistical functions) on <code>DataFrame</code>. For examples,</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.arange(1,13).reshape(3, 4), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df</strong>
       c1  c2  c3  c4
red     1   2   3   4
green   5   6   7   8
blue    9  10  11  12

<span class="color-comment"># Universal function (from NumPy) applicable to all data-values</span>
&gt;&gt;&gt; <strong>np.sqrt(df)</strong>
             c1        c2        c3        c4
red    1.000000  1.414214  1.732051  2.000000
green  2.236068  2.449490  2.645751  2.828427
blue   3.000000  3.162278  3.316625  3.464102

<span class="color-comment"># Aggregate function (from NumPy) on each column</span>
&gt;&gt;&gt; <strong>np.sum(df)</strong>
c1    15
c2    18
c3    21
c4    24
dtype: int64
&gt;&gt;&gt; <strong>np.sum(df, axis=1)</strong>   <span class="color-comment"># Row-wise</span>
red      10
green    26
blue     42
dtype: int64
&gt;&gt;&gt; <strong>np.mean(df)</strong>
c1    5.0
c2    6.0
c3    7.0
c4    8.0
dtype: float64
&gt;&gt;&gt; <strong>np.min(df)</strong>
c1    1
c2    2
c3    3
c4    4
dtype: int32
&gt;&gt;&gt; <strong>np.cumsum(df)</strong>
       c1  c2  c3  c4
red     1   2   3   4
green   6   8  10  12
blue   15  18  21  24</pre>

<h5><span class="font-code">DataFrame.apply()</span> and <span class="font-code">DataFrame.applymap()</span></h5>

<p>You can apply an arbitrary function over a DataFrame via <code>apply(<em>func</em>)</code> on each column; and <code>applymap(<em>func</em>)</code> on each element.</p>
<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.arange(1,13).reshape(3, 4), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df</strong>
       c1  c2  c3  c4
red     1   2   3   4
green   5   6   7   8
blue    9  10  11  12

<span class="color-comment"># DataFrame.apply(func), where func takes a Series and returns a scalar or Series
# apply(func) applies the func to each column (or row) of the DataFrame.</span>
&gt;&gt;&gt; <strong>help(df.apply)</strong>
&gt;&gt;&gt; <strong>df.apply(np.sum)</strong>
c1    15
c2    18
c3    21
c4    24
dtype: int64
&gt;&gt;&gt; <strong>df.apply(np.sum, axis=1)</strong>   <span class="color-comment"># Apply row-wise</span>
red      10
green    26
blue     42
dtype: int64
<span class="color-comment"># User-defined function</span>
>>> <strong>df.apply(lambda lst: lst.max() - lst.min())</strong>   <span class="color-comment"># Find the range</span>
c1    8
c2    8
c3    8
c4    8
dtype: int64

<span class="color-comment"># Check func's argument and return value</span>
&gt;&gt;&gt; <strong>def f(x): print(x, type(x)); return 1</strong>   <span class="color-comment"># Return a scalar</span>
&gt;&gt;&gt; <strong>df.apply(f)</strong>
red      1
green    5
blue     9
Name: c1, dtype: int32 &lt;class 'pandas.core.series.Series'&gt;  <span class="color-comment"># argument is a Series</span>
......
c1    1
c2    1
c3    1
c4    1
dtype: int64
&gt;&gt;&gt; <strong>df.apply(lambda s: [1, 2, 3])</strong>  <span class="color-comment"># Can return a list of the same-length</span>
       c1  c2  c3  c4
red     1   1   1   1
green   2   2   2   2
blue    3   3   3   3

&gt;&gt;&gt; <strong>df.apply(lambda s: s+1)</strong>   <span class="color-comment"># Return a Series with incremented value</span>
       c1  c2  c3  c4
red     2   3   4   5
green   6   7   8   9
blue   10  11  12  13

&gt;&gt;&gt; <strong>df.apply(lambda s: pd.Series({'min': s.min(), 'max': s.max()}))</strong>  <span class="color-comment"># Return a new Series</span>
     c1  c2  c3  c4
min   1   2   3   4
max   9  10  11  12
<span class="color-comment">
# DataFrame.applymap(func), where func takes a scalar and returns a scalar
# applymap(func) applies the func to each data-value</span>
&gt;&gt;&gt; <strong>df.applymap(lambda x: x+1)</strong><br />       c1  c2  c3  c4<br />red     2   3   4   5<br />green   6   7   8   9<br />blue   10  11  12  13
</pre>

<h5>Statistics</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame([[4, 1, 10, 2], [6 , 7, 4, 2], [8, 4, 9, 1]], index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df</strong>
       c1  c2  c3  c4
red     4   1  10   2
green   6   7   4   2
blue    8   4   9   1

&gt;&gt;&gt; <strong>help(df.describe)</strong>
&gt;&gt;&gt; <strong>df.describe()</strong>
        c1   c2         c3        c4
count  3.0  3.0   3.000000  3.000000
mean   6.0  4.0   7.666667  1.666667
std    2.0  3.0   3.214550  0.577350
min    4.0  1.0   4.000000  1.000000
25%    5.0  2.5   6.500000  1.500000
50%    6.0  4.0   9.000000  2.000000
75%    7.0  5.5   9.500000  2.000000
max    8.0  7.0  10.000000  2.000000
&gt;&gt;&gt; <strong>df.mean()</strong>
c1    6.000000
c2    4.000000
c3    7.666667
c4    1.666667
dtype: float64
&gt;&gt;&gt; <strong>df.std()</strong>   <span class="color-comment"># Standard deviation</span>
c1    2.00000
c2    3.00000
c3    3.21455
c4    0.57735
dtype: float64
&gt;&gt;&gt; <strong>df.var()</strong>    <span class="color-comment"># Variance</span>
c1     4.000000
c2     9.000000
c3    10.333333
c4     0.333333
dtype: float64
&gt;&gt;&gt; <strong>df.median()</strong>
c1    6.0
c2    4.0
c3    9.0
c4    2.0
dtype: float64

&gt;&gt;&gt; <strong>df.corr()</strong>   <span class="color-comment"># Correlation Coefficients</span>
          c1        c2        c3        c4
c1  1.000000  0.500000 -0.155543 -0.866025
c2  0.500000  1.000000 -0.933257  0.000000
c3 -0.155543 -0.933257  1.000000 -0.359211
c4 -0.866025  0.000000 -0.359211  1.000000
&gt;&gt;&gt; <strong>df.cov()</strong>    <span class="color-comment"># Covariance</span>
     c1   c2         c3        c4
c1  4.0  3.0  -1.000000 -1.000000
c2  3.0  9.0  -9.000000  0.000000
c3 -1.0 -9.0  10.333333 -0.666667
c4 -1.0  0.0  -0.666667  0.333333</pre>

<h5>Sorting on Index and value, and Ranking</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.random.randint(1, 10, (3, 4)), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df</strong>
       c1  c2  c3  c4
red     4   5   6   8
green   8   3   7   4
blue    1   1   3   5
&gt;&gt;&gt; <strong>df.sort_index()</strong>
       c1  c2  c3  c4
blue    1   1   3   5
green   8   3   7   4
red     4   5   6   8
&gt;&gt;&gt; <strong>df.sort_index(axis=1, ascending=False)</strong>
       c4  c3  c2  c1
red     8   6   5   4
green   4   7   3   8
blue    5   3   1   1
&gt;&gt;&gt; <strong>df.sort_values('c1')</strong>
       c1  c2  c3  c4
blue    1   1   3   5
red     4   5   6   8
green   8   3   7   4

<span class="color-comment"># Rank the data-values from 1 to N</span>
>>> <strong>df.rank()</strong>
        c1   c2   c3   c4
red    2.0  3.0  2.0  3.0
green  3.0  2.0  3.0  1.0
blue   1.0  1.0  1.0  2.0
>>> <strong>df.rank(axis=1)</strong>
        c1   c2   c3   c4
red    1.0  2.0  3.0  4.0
green  4.0  1.0  3.0  2.0
blue   1.5  1.5  3.0  4.0</pre>

<h5>Operations Between Two <span class="font-code">DataFrame</span>s</h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df1 = pd.DataFrame(np.arange(1,13).reshape(3, 4), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df2 = pd.DataFrame(np.arange(1,10).reshape(3, 3), index=['blue', 'green', 'red'], columns=['c1', 'c2', 'c4'])</strong>
&gt;&gt;&gt; <strong>df1</strong>
       c1  c2  c3  c4
red     1   2   3   4
green   5   6   7   8
blue    9  10  11  12
&gt;&gt;&gt; <strong>df2</strong>
       c1  c2  c4
blue    1   2   3
green   4   5   6
red     7   8   9

<span class="color-comment"># Arithmetic Operations</span>
&gt;&gt;&gt; <strong>df1 + df2</strong>    <span class="color-comment"># per [row-index, column-header]</span>
       c1  c2  c3  c4
blue   10  12 NaN  15
green   9  11 NaN  14
red     8  10 NaN  13

<span class="color-comment"># Comparison</span>
&gt;&gt;&gt; <strong>df1 &gt; df2</strong>
ValueError: Can only compare identically-labeled DataFrame objects
&gt;&gt;&gt; <strong>df3 = pd.DataFrame(np.arange(12,0,-1).reshape(3, 4), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df3</strong>
       c1  c2  c3  c4
red    12  11  10   9
green   8   7   6   5
blue    4   3   2   1
&gt;&gt;&gt; <strong>df1 &gt; df3</strong>
          c1     c2     c3     c4
red    False  False  False  False
green  False  False   True   True
blue    True   True   True   True
&gt;&gt;&gt; <strong>df1[df1 &gt; df3]</strong>
        c1    c2    c3    c4
red    NaN   NaN   NaN   NaN
green  NaN   NaN   7.0   8.0
blue   9.0  10.0  11.0  12.0</pre>

<h5>Operations Between a <span class="font-code">DataFrame</span> and a <span class="font-code">Series</span></h5>

<pre class="color-example">
&gt;&gt;&gt; <strong>df1 = pd.DataFrame(np.arange(1,13).reshape(3, 4), index=['red', 'green', 'blue'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df1</strong>
       c1  c2  c3  c4
red     1   2   3   4
green   5   6   7   8
blue    9  10  11  12
&gt;&gt;&gt; <strong>s1 = pd.Series([1, 2, 3], index=['c4', 'c3', 'c2'])</strong>
&gt;&gt;&gt; <strong>df1 + s1</strong>    <span class="color-comment"># Apply to each row aligning the column-header</span>
       c1    c2    c3    c4
red   NaN   5.0   5.0   5.0
green NaN   9.0   9.0   9.0
blue  NaN  13.0  13.0  13.0
&gt;&gt;&gt; <strong>df1 * s1</strong>
       c1    c2    c3    c4
red   NaN   6.0   6.0   4.0
green NaN  18.0  14.0   8.0
blue  NaN  30.0  22.0  12.0</pre>


<h4>Handling Missing Data</h4>
<p>Missing data are assigned <code>NaN</code> (Not A Number). You can use functions <code><em>dataframe</em>.isnull()</code> to check for <code>NaN</code>, or <code><em>dataframe</em>.fillna(<em>value</em>)</code> to fill <code>NaN</code> with <code><em>value</em></code>.</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame({'c1': pd.Series([1, 2, 3]), 'c2': pd.Series([11, 22, 33, 44, 55])})</strong>
&gt;&gt;&gt; <strong>df</strong>
    c1  c2
0  1.0  11
1  2.0  22
2  3.0  33
3  NaN  44
4  NaN  55
&gt;&gt;&gt; <strong>len(df)</strong>
5
&gt;&gt;&gt; <strong>df.isnull()</strong>
      c1     c2
0  False  False
1  False  False
2  False  False
3   True  False
4   True  False
&gt;&gt;&gt; <strong>df[df['c1'].isnull()]</strong>
   c1  c2
3 NaN  44
4 NaN  55
&gt;&gt;&gt; <strong>len(df[df['c1'].isnull()])</strong>
2
&gt;&gt;&gt; <strong>df[~df['c1'].isnull()]</strong>
    c1  c2
0  1.0  11
1  2.0  22
2  3.0  33
&gt;&gt;&gt; <strong>df = df[~df['c1'].isnull()]</strong>   <span class="color-comment"># Remove missing data rows</span>
&gt;&gt;&gt; <strong>df</strong>
    c1  c2
0  1.0  11
1  2.0  22
2  3.0  33

&gt;&gt;&gt; <strong>df = pd.DataFrame({'c1': pd.Series([1, 2, 3]), 'c2': pd.Series([11, 22, 33, 44, 55])})</strong>
&gt;&gt;&gt; <strong>df.fillna(99)</strong>
     c1  c2
0   1.0  11
1   2.0  22
2   3.0  33
3  99.0  44
4  99.0  55</pre>

<h4>Query the Data</h4>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame({'c1': pd.Series([1, 2, 3]), 'c2': pd.Series([11, 22, 33, 44, 55])})</strong>
&gt;&gt;&gt; <strong>df</strong>
    c1  c2
0  1.0  11
1  2.0  22
2  3.0  33
3  NaN  44
4  NaN  55
<span class="color-comment">
# <em>dataFrame</em>.query(exprStr), with &amp; for AND, | for OR, and ~ for NOT.</span>
&gt;&gt;&gt; <strong>help(df.query)</strong>
&gt;&gt;&gt; <strong>df.query('c1 &lt; 2')</strong>
    c1  c2
0  1.0  11
&gt;&gt;&gt; <strong>df.query('c1 &lt; 2 | c2 &lt;= 32')</strong>
    c1  c2
0  1.0  11
1  2.0  22
&gt;&gt;&gt; <strong>df.query('~(c1 &lt; 2 | c2 &lt;= 32)')</strong>
    c1  c2
2  3.0  33
3  NaN  44
4  NaN  55
&gt;&gt;&gt; <strong>df.query('c2 > c1')</strong>
    c1  c2
0  1.0  11
1  2.0  22
2  3.0  33</pre>

<h4>Hierarchical Multi-Level Indexing</h4>
<p>For supporting multi-dimensional data in 2D tabular structure of <code>DataFrame</code>.</p>

<pre class="color-example">
<span class="color-comment"># Multi-Level row-index</span>
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.random.randint(1, 10, (8, 2)), 
        index=[['i1', 'i1', 'i1', 'i2', 'i2', 'i3', 'i3', 'i3'], ['a', 'b', 'c', 'a', 'c', 'a', 'b', 'd']],
        columns=['c1', 'c2'])</strong>
&gt;&gt;&gt; <strong>df</strong>
      c1  c2
i1 a   8   3
   b   9   8
   c   7   3
i2 a   9   3
   c   9   2
i3 a   4   3
   b   7   1
   d   5   2
&gt;&gt;&gt; <strong>df.index</strong>
MultiIndex(levels=[['i1', 'i2', 'i3'], ['a', 'b', 'c', 'd']],
           labels=[[0, 0, 0, 1, 1, 2, 2, 2], [0, 1, 2, 0, 2, 0, 1, 3]])
&gt;&gt;&gt; <strong>df.loc['i2']</strong>
   c1  c2
a   8   4
c   1   1
&gt;&gt;&gt; <strong>df.loc['i2', 'c']</strong>
c1    1
c2    1
Name: (i2, c), dtype: int32</pre>

<pre class="color-example">
<span class="color-comment"># Multi-Level row-index and column-header</span>
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.random.randint(1, 10, (5, 6)),
        index=[['i1', 'i1', 'i1', 'i2', 'i2'], ['a', 'b', 'c', 'a', 'c']],
        columns=[['c1', 'c1', 'c1', 'c2', 'c2', 'c2'], ['x', 'y', 'z', 'x', 'y', 'z']])</strong>
>>> <strong>df</strong>
     c1       c2
      x  y  z  x  y  z
i1 a  2  1  9  3  2  8
   b  4  3  6  6  3  1
   c  8  4  8  7  3  5
i2 a  6  6  1  7  1  8
   c  9  1  8  7  3  5
&gt;&gt;&gt; <strong>df.index</strong>
MultiIndex(levels=[['i1', 'i2'], ['a', 'b', 'c']],
           labels=[[0, 0, 0, 1, 1], [0, 1, 2, 0, 2]])
&gt;&gt;&gt; <strong>df.columns</strong>
MultiIndex(levels=[['c1', 'c2'], ['x', 'y', 'z']],
           labels=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; <strong>df['c2']</strong>
      x  y  z
i1 a  3  2  8
   b  6  3  1
   c  7  3  5
i2 a  7  1  8
   c  7  3  5
&gt;&gt;&gt; <strong>df['c2', 'y']</strong>
i1  a    4
    b    4
    c    1
i2  a    2
    c    3
Name: (c2, y), dtype: int32
&gt;&gt;&gt; <strong>df['c2']['y']</strong>
i1  a    2
    b    3
    c    3
i2  a    1
    c    3
Name: y, dtype: int32</pre>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.random.randint(1, 10, 8),
        index=[['i1', 'i1', 'i1', 'i2', 'i2', 'i3', 'i3', 'i3'], ['a', 'b', 'c', 'a', 'c', 'a', 'b', 'd']])</strong>
&gt;&gt;&gt; <strong>df</strong>
      0
i1 a  3
   b  3
   c  3
i2 a  1
   c  2
i3 a  9
   b  7
   d  1
&gt;&gt;&gt; <strong>df.unstack()</strong>
      0
      a    b    c    d
i1  3.0  3.0  3.0  NaN
i2  1.0  NaN  2.0  NaN
i3  9.0  7.0  NaN  1.0</pre>

<h4>Grouping</h4>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame({'Cat 1': ['A', 'C', 'B', 'A', 'B', 'C', 'D'],
                       'Cat 2': ['X', 'Z', 'Y', 'Y', 'X', 'Z', 'Z'],
                       'Value': np.random.randint(1, 10, 7)})</strong>
&gt;&gt;&gt; <strong>df</strong>
  Cat 1 Cat 2  Value
0     A     X      9
1     C     Z      9
2     B     Y      2
3     A     Y      7
4     B     X      4
5     C     Z      5
6     D     Z      2

<span class="color-comment"># List unique values</span>
&gt;&gt;&gt; <strong>df['Cat 1'].unique()</strong>
array(['A', 'C', 'B', 'D'], dtype=object)
&gt;&gt;&gt; <strong>df['Cat 2'].unique()</strong>
array(['X', 'Z', 'Y'], dtype=object)
&gt;&gt;&gt; <strong>df['Value'].unique()</strong>
array([3, 9, 6, 5, 1], dtype=int64)
&gt;&gt;&gt; <strong>df['Cat 1'].min()</strong>
'A'
&gt;&gt;&gt; <strong>df['Value'].max()</strong>
9
&gt;&gt;&gt; <strong>df['Cat 1'].sum()</strong>  <span class="color-comment"># concatenation</span>
'ACBABCD'
&gt;&gt;&gt; <strong>df['Cat 1'].describe()</strong>
count     7
unique    4
top       B
freq      2
Name: Cat 1, dtype: object

<span class="color-comment"># Group by one column</span>
&gt;&gt;&gt; <strong>group_cat1 = df.groupby('Cat 1')</strong>
&gt;&gt;&gt; <strong>group_cat1.size()</strong>
Cat 1
A    2
B    2
C    2
D    1
dtype: int64
&gt;&gt;&gt; <strong>group_cat1.count()</strong>
       Cat 2  Value
Cat 1
A          2      2
B          2      2
C          2      2
D          1      1
&gt;&gt;&gt; <strong>group_cat1.describe()</strong>
      Value
      count mean       std  min  25%  50%  75%  max
Cat 1
A       2.0  8.0  1.414214  7.0  7.5  8.0  8.5  9.0
B       2.0  3.0  1.414214  2.0  2.5  3.0  3.5  4.0
C       2.0  7.0  2.828427  5.0  6.0  7.0  8.0  9.0
D       1.0  2.0       NaN  2.0  2.0  2.0  2.0  2.0
&gt;&gt;&gt; <strong>group_cat1.sum()</strong>
       Value
Cat 1
A         16
B          6
C         14
D          2
&gt;&gt;&gt; <strong>group_cat1.aggregate(np.sum)</strong>
       Value
Cat 1
A         16
B          6
C         14
D          2
&gt;&gt;&gt; <strong>group_cat1.agg([np.sum, np.mean])</strong>
      Value
        sum mean
Cat 1
A        16    8
B         6    3
C        14    7
D         2    2

<span class="color-comment"># Group by two columns</span>
&gt;&gt;&gt; <strong>group_cat1_cat2 = df.groupby(['Cat 1', 'Cat 2'])</strong>
&gt;&gt;&gt; <strong>group_cat1_cat2.size()</strong>
Cat 1  Cat 2
A      X        1
       Y        1
B      X        1
       Y        1
C      Z        2
D      Z        1
dtype: int64
&gt;&gt;&gt; <strong>group_cat1_cat2.count()</strong>
             Value
Cat 1 Cat 2
A     X          1
      Y          1
B     X          1
      Y          1
C     Z          2
D     Z          1
&gt;&gt;&gt; <strong>group_cat1_cat2.describe()</strong>
            Value
            count mean       std  min  25%  50%  75%  max
Cat 1 Cat 2
A     X       1.0  9.0       NaN  9.0  9.0  9.0  9.0  9.0
      Y       1.0  7.0       NaN  7.0  7.0  7.0  7.0  7.0
B     X       1.0  4.0       NaN  4.0  4.0  4.0  4.0  4.0
      Y       1.0  2.0       NaN  2.0  2.0  2.0  2.0  2.0
C     Z       2.0  7.0  2.828427  5.0  6.0  7.0  8.0  9.0
D     Z       1.0  2.0       NaN  2.0  2.0  2.0  2.0  2.0</pre>

<h3 id="pandas_data">Pandas Data Analysis</h3>

<p>Data Analysis involved these steps:</p>
<ol>
<li>Data Preparation</li>
<li>Data Transformation (Map)</li>
<li>Data Aggregation (Reduce)</li>
</ol>

<h4>Data Preparation: Loading/Saving Data to Files</h4>

<p>Pandas supports reading and writing to files in many formats:</p>
<ul>
<li><code>read_csv()</code>, <code>to_csv()</code>: Comma-Separated Values</li>
<li><code>read_table(file, sep='\t')</code>: <code>sep</code> takes regex, such as <code>'\s+'</code> (one or more spaces)</li>
<li><code>read_josn()</code>, <code>to_json()</code></li>
<li><code>read_html()</code>, <code>to_html()</code></li>
<li><code>read_excel()</code>, <code>to_excel()</code>: MS Excel</li>
<li><code>read_hdf()</code>, <code>to_hdf()</code>: Hierarchical Data Format</li>
<li><code>read_sql()</code>, <code>to_sql()</code></li>
<li><code>read_stata()</code>, <code>to_stata()</code></li>
<li><code>read_clipboard()</code>, <code>to_clipboard()</code></li>
<li><code>read_pickle()</code>, <code>to_pickle()</code>: Python Object Serialization</li>
</ul>
<p>You need to invoke <code>read_xxx()</code> via <code>pandas</code>, and <code>to_xxx()</code> via <code>DataFrame</code>.</p>

<pre class="color-example">
&gt;&gt;&gt; <strong>df = pd.DataFrame(np.arange(1, 13).reshape(3, 4), index=['r1', 'r2', 'r3'], columns=['c1', 'c2', 'c3', 'c4'])</strong>
&gt;&gt;&gt; <strong>df</strong>
    c1  c2  c3  c4
r1   1   2   3   4
r2   5   6   7   8
r3   9  10  11  12

<span class="color-comment"># CSV</span>
&gt;&gt;&gt; <strong>df.to_csv('data.csv')</strong>
,c1,c2,c3,c4<br />r1,1,2,3,4<br />r2,5,6,7,8<br />r3,9,10,11,12
&gt;&gt;&gt; <strong>df.to_csv('data_no_label.csv', index=False, header=False)</strong>
1,2,3,4
5,6,7,8
9,10,11,12
&gt;&gt;&gt; <strong>df_in = pd.read_csv('data.csv')</strong>
&gt;&gt;&gt; <strong>df_in</strong>
  Unnamed: 0  c1  c2  c3  c4
0         r1   1   2   3   4
1         r2   5   6   7   8
2         r3   9  10  11  12
&gt;&gt;&gt; <strong>df_in = pd.read_csv('data.csv', index_col=0)</strong>
&gt;&gt;&gt; <strong>df_in</strong>
    c1  c2  c3  c4
r1   1   2   3   4
r2   5   6   7   8
r3   9  10  11  12
&gt;&gt;&gt; <strong>df_in1 = pd.read_table('data.csv', sep=',', index_col=0)</strong>
&gt;&gt;&gt; <strong>df_in1</strong>
.....

<span class="color-comment"># JSON</span>
&gt;&gt;&gt; <strong>df.to_json('data.json')</strong>
{&quot;c1&quot;:{&quot;r1&quot;:1,&quot;r2&quot;:5,&quot;r3&quot;:9},
 &quot;c2&quot;:{&quot;r1&quot;:2,&quot;r2&quot;:6,&quot;r3&quot;:10},
 &quot;c3&quot;:{&quot;r1&quot;:3,&quot;r2&quot;:7,&quot;r3&quot;:11},
 &quot;c4&quot;:{&quot;r1&quot;:4,&quot;r2&quot;:8,&quot;r3&quot;:12}}
&gt;&gt;&gt; <strong>df_in = pd.read_json('data.json')</strong>
&gt;&gt;&gt; <strong>df_in</strong>
    c1  c2  c3  c4
r1   1   2   3   4
r2   5   6   7   8
r3   9  10  11  12

<span class="color-comment"># HTML</span>
&gt;&gt;&gt; <strong>df.to_html('data.html')</strong>
   <span class="color-comment"># in HTML &lt;table&gt; of &lt;tr&gt; rows of &lt;td&gt; columns. Check it out</span>
&gt;&gt;&gt; <strong>df_in = pd.read_html('data.html')</strong>

<span class="color-comment"># SQL - need a database connection</span>

<span class="color-comment"># Excel</span>
&gt;&gt;&gt; <strong>df.to_excel('data.xls')</strong>
   <span class="color-comment"># Check out the resultant xls</span>
&gt;&gt;&gt; <strong>df_in = pd.read_excel('data.xls')</strong>
</pre>

<h4>Data Preparation: Merging <span class="font-code">merge()</span></h4>

<p>Similar to a SQL JOIN operation between tables through one or more shared keys.</p>

<p>[TODO]</p>


<h3 id="matplotlib_pandas">Pandas and Matplotlib</h3>

<h4>Example 1: Line Chart</h4>

<pre class="color-example">
<span class="color-comment"># Pandas-Matplotlib Line Plot: sin(x), cos(x), cos(x**2) for x=[-2*pi, 2*pi]</span>
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
<span class="color-comment"># Generate x: linearly spaced in degree interval, both ends included</span>
x = np.linspace(-2*np.pi, 2*np.pi, 721)
<span class="color-comment"># Generate y's</span>
sx, cx, cx2 = np.sin(x), np.cos(x), np.cos(x**2)
<span class="color-comment"># Create Pandas DataFrame</span>
df = pd.DataFrame({'sin(x)': sx, 'cos(x)': cx, 'cos(x**2)': cx2}, index=x)
df.index.name = 'x'
print(df.head())

<span class="color-comment"># Plot through DataFrame and get axes handle for further customizing</span>
ax = df.plot.line(title='Sines and Cosines (Pandas-Matplotlib Line Plot)',
                  xlim=(-2*np.pi, 2*np.pi), ylim=(-1, 1))
<span class="color-comment"># Set the x-tick locations and labels</span>
ax.set_xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi]) 
ax.set_xticklabels([r'$-2\pi$', r'$-\pi$', r'$0$', r'$+\pi$', r'$+2\pi$']) # Using latex symbol
<span class="color-comment"># Set ylabel. xlabel picked up from index-column's header</span>
ax.set_ylabel('y')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pandas_LineSineCosine.png" alt="line plot" />

<h4>Example 3: Bar Chart</h4>
<pre class="color-example">
<span class="color-comment"># Pandas-Matplotlib Bar Chart</span>
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
<span class="color-comment"># Setup DataFrame</span>
x = ['2020', '2021', '2022', '2023', '2024']
y = np.random.randint(1, 101, len(x))  <span class="color-comment"># 5 values in [1, 100]</span>
df = pd.DataFrame({'Espresso': y}, index=x)
df.index.name='Year'
print(df.head())

<span class="color-comment"># Plot bar chart</span>
ax = df.plot.bar(title='Coffee &amp; Tea Sales (Pandas-Matplotlib Bar Chart)')
ax.set_ylabel('Sales')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pandas_Bar.png" alt="bar chart" />

<h4>Example 4: Bar Chart (Grouped and Stacked)</h4>
<pre class="color-example">
<span class="color-comment"># Pandas-Matplotlib Grouped and Stacked Bar Charts</span>
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
import numpy as np
import pandas as pd

<span class="color-comment"># Setup x, y and Pandas DataFrame</span>
x = ['2020', '2021', '2022', '2023', '2024']
y1 = np.array([1, 6, 3, 5, 2])
y2 = np.array([2, 2, 4, 5, 1])
y3 = np.array([3, 3, 2, 3, 1])
ycmap1 = ListedColormap(['#5B9BD5', '#ED7D31', '#70AD47'])
ycmap2 = ListedColormap(['#FF6666', '#66FF66', '#6666FF'])
df = pd.DataFrame({'espresso': y1, 'Cappuccino': y2, 'Latte': y3}, index=x)
df.index.name = 'Year'
print(df.head())  <span class="color-comment"># Show sample records</span>

<span class="color-comment"># Create a figure with 2 subplots and get their handles</span>
fig, (ax0, ax1) = plt.subplots(2, 1)

df.plot.bar(ax=ax0, figsize=(6.4, 6.4), cmap=ycmap1,
            title='Coffee &amp; Tea Sales (Pandas-Matplotlib Grouped Bar Chart)')
ax0.set_ylabel('Sales')

df.plot.bar(ax=ax1, stacked=True, cmap=ycmap2,
            title='Coffee &amp; Tea Sales (Pandas-Matplotlib Stacked Bar Chart)')
ax1.set_ylabel('Sales')

plt.tight_layout()  <span class="color-comment"># To prevent overlapping of subplots</span>
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pandas_BarStacked.png" alt="bar chart" />

<h4>Example 5: Histogram (Bar Chart)</h4>

<pre class="color-example">
<span class="color-comment"># Pandas-Matplotlib Histogram</span>
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

<span class="color-comment"># Set up Pandas DataFrame, for marks of [0, 100], in 10 bins
</span>y = np.random.normal(65, 15, 500)  <span class="color-comment"># Normal Distributed at mean and std dev</span>
df = pd.DataFrame({'Mark': y})
print(df.head())

<span class="color-comment"># Setup bins and plot</span>
bins = np.arange(0, 101, 10)  <span class="color-comment"># bins are [0, 10), [10, 19), ... [90, 100]</span>
ax = df.plot.hist(bins=bins, width=8, xlim=(0, 100), legend=False,
                  title='Histogram (Pandas-Matplotlib)')  <span class="color-comment"># Bar from x to x+8</span>
ax.set_xlabel('Mark')
ax.set_ylabel('Number of Students')
ax.set_xticks(np.arange(5, 100, 10)-1)  <span class="color-comment"># 4, 14, 24, ...</span>
ax.set_xticklabels(['0-9', '10-19', '20-29', '30-39', '40-49', '50-59', '60-69', '70-79', '80-89', '90-100'])
ax.tick_params(axis='x', rotation=90)
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pandas_Histogram.png" alt="histogram" />

<h4>Example 6: Pie Chart</h4>

<pre class="color-example">
<span class="color-comment"># Pandas-Matplotlib Pie Chart</span>
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
<span class="color-comment"># Setup Pandas DataFrame</span>
x = ['2020', '2021', '2022', '2023', '2024']
y = [5, 3, 6, 2, 3]
df = pd.DataFrame({'Sales': y}, index=x)
df.index.name = "Year"
print(df.head())

explode = (0, 0, 0, 0.2, 0)   <span class="color-comment"># &quot;explode&quot; the forth slice by 0.2</span>
ax = df.plot.pie(subplots=True, explode=explode, startangle=90, legend=False,
                 title='Pie Chart (Pandas-Matplotlib)')
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pandas_Pie.png" alt="Pie chart" />

<h4>Example 7: Scatter Chart</h4>

<pre class="color-example">
<span class="color-comment"># Pandas-Matplotlib Scatter Plot
# for 2 categories of 25 points each, randomly generated</span>
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib.colors import ListedColormap

<span class="color-comment"># Set up x, y and DataFrame</span>
xy1 = np.random.normal(8, 1, 50).reshape(-1, 2)  <span class="color-comment"># cat1: [x1, y1] 25 samples</span>
xy1 = np.column_stack((xy1, np.zeros(25))) <span class="color-comment"># Add a column for cat</span>
xy2 = np.random.normal(4, 2, 50).reshape(-1, 2)  <span class="color-comment"># cat2: [x2, y2] 25 samples</span>
xy2 = np.column_stack((xy2, np.ones(25)))  <span class="color-comment"># Add a column for cat</span>
xy = np.vstack((xy1, xy2))
df = pd.DataFrame({'x': xy[:,0], 'y': xy[:,1], 'cat': xy[:,2]})  <span class="color-comment"># Specify column names</span>
print(df.head())

cmap = ListedColormap(['#FF6666', '#6666FF'])
<span class="color-comment"># Need axes for setting xlabel (colorbar has another axes)</span>
ax = plt.subplot(1, 1, 1)
df.plot.scatter(x='x', y='y', c='cat', ax=ax, colormap=cmap, 
                title='Scatter Plot (Pandas-Matplotlib)')
ax.set_xlabel('x')
<span class="color-comment"># very hard to set colorbar ticks and ticklabels</span>
plt.show()</pre>

<img class="image-center" src="images/Matplotlib_Pandas_Scatter.png" alt="Scatter Plot" />



<h3 id="scikit-learn">Machine Learning with scikit-learn</h3>

<h4>Terminology</h4>

<p><span class="line-heading">Machine Learning</span>: Development of algorithms that build <em>models</em> on the data, and make predictions.</p>

<img class="image-center" src="images/Python_ML_Model.png" alt="ML Model" />
<p><span class="line-heading">Data</span>: Data is usually organized in 2D tables. Each row is a  sample (or observation, record, instance). Each column is a feature or a response.</p>

<ol>
<li><span class="line-heading">Features (or Attributes, Predictors, Independent Variables, Regressors, Covariate, Input, X)</span>: Features are inputs to the model. Features are organized in a <code>(num_samples, num_features)</code> array.</li>
<li><span class="line-heading">Response  (or Target, Outcome, Label, Dependent Variable, Output, Y)</span>: Response (or target) is the output the model, representing the outcome that we want to predict. The response array is usually 1-dimensional with length of <code>num_samples</code>.</li>

</ol>


<p><span class="line-heading">Types of Machine Learning</span>: Machine Learning can be broadly classified into:</p>
<ol>
<li><span class="line-heading">Supervised Learning</span>: The data consists of input features and output target we want to predict.
  <ol>
<li><span class="line-heading">Classification</span>: the output target is categorical (i.e., it belongs to two or more categories or classes). Applicable methods include K-Nearest Neighbors (KNN) Classifier, Support Vector Machine Classifier (SVC).</li>
<li><span class="line-heading">Regression</span>: the output target is ordered and continuous. Applicable methods includes Linear Regression, Support Vector Machine Regression (SVR).</li>
</ol>
</li>
<li><span class="line-heading">Unsupervised Learning</span>: The data does not contain the output target value.
  <ol>
<li><span class="line-heading">Clustering</span>: to group the similar inputs into clusters (classes)</li>
<li><span class="line-heading">Dimensionality Reduction</span>: to reduce the dimensions of the inputs, such as the lower dimensional outputs convey much more information.</li>
</ol>
</li>
</ol>


<p><span class="line-heading">Training Set and Test Set</span>: Data are split into training set (for building the model) and test set (for testing and evaluating the model).</p>

<p><span class="line-heading">Raw Data Types</span>: Raw data can come in many types:</p>
<ol>
<li>Categorical: 
<ol>
<li>Nominal: no intrinsic order, e.g., cat A, B, C,...</li>
<li>Ordinal: has a predetermined order, e.g., band 1, 2, 3 with ordering</li>
</ol>
</li>
<li>Numerical:
<ol>
<li>discrete: can be counted with distinct values</li>
<li>continuous: from analog measurements</li>
</ol></li>
</ol>

<p><span class="line-heading">Raw Data Formats</span>: Raw data could take the format of:</p>
<ul>
<li>CSV (Comma-Separated Values)</li>
<li>JSON (JavaScript Object Notation)</li>
<li>XLS (Excel Spreadsheet)</li>
<li>XML (Extensible Markup Language)</li>
<li>HTML (Hypertext Markup Language)</li>
<li>HDF (Hierarchical Data Format)</li>
<li>SQL (Structure Query Language)</li>
<li>Others</li>
</ul>

<h5>Data Analysis Process</h5>
<p>The data analysis process consists of these stages:</p>
<ol>
<li>Problem identification and definition.</li>
<li>Data preparation: gathering, extraction, cleaning, transformation.</li>
<li>Data exploration and visualization.</li>
<li>Predictive Modeling: classification models (categorical data), regression models (numeric data), clustering models (descriptive data)</li>
<li>Model validation and testing: training set, validation (testing) set.</li>
<li>Deployment and interpretation of predictive results.</li>
</ol>


<h4>The Iris Flower Dataset (for Supervised Classification)</h4>

<p>The Iris Flower Dataset is used for the first time by Sir Ronald Fisher in 1936. It is often
also called Anderson Iris Dataset, after the person who collected the data. The dataset has:</p>
<ul>
<li>4 input features (the length and width of the sepals, and the length and width of the petals). Input features are numerical and continuous.</li>
<li>1 output target of 3 categories (species of iris - Iris silky, virginica Iris, and Iris versicolor). Target is categorical and nominal (unordered).</li>
<li>150 samples, 50 samples per output category, no missing data.</li>
</ul>

<p>You can load the iris dataset from scikit-learn as follows:</p>

<pre class="color-example">&gt;&gt;&gt; <strong>from sklearn import datasets</strong>
&gt;&gt;&gt; <strong>iris = datasets.load_iris()</strong>
&gt;&gt;&gt; <strong>type(iris)</strong>
&lt;class 'sklearn.utils.Bunch'&gt;

<span class="color-comment"># Check out the dataset</span>
&gt;&gt;&gt; <strong>iris</strong>
{'data': array([[5.1, 3.5, 1.4, 0.2],    <span class="color-comment"># Input Features: NumPy's ndarray of 150x4</span>
                ......
               [5.9, 3. , 5.1, 1.8]]),
 'target': array([0, 0, 0, 0, ....]),    <span class="color-comment"># Output target [0, 1, 2]: NumPy's ndarray of 150</span>
 'target_names': array(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10'),
 'DESCR': 'Iris Plants Database ....'
 'feature_names': ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']}

&gt;&gt;&gt; <strong>print(iris.DESCR)</strong>
Data Set Characteristics:
    :Number of Instances: 150 (50 in each of three classes)
    :Number of Attributes: 4 numeric, predictive attributes and the class
    :Attribute Information:
        - sepal length in cm
        - sepal width in cm
        - petal length in cm
        - petal width in cm
        - class:
                - Iris-Setosa
                - Iris-Versicolour
                - Iris-Virginica
    :Summary Statistics:
    ============== ==== ==== ======= ===== ====================
                    Min  Max   Mean    SD   Class Correlation
    ============== ==== ==== ======= ===== ====================
    sepal length:   4.3  7.9   5.84   0.83    0.7826
    sepal width:    2.0  4.4   3.05   0.43   -0.4194
    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)
    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)
    ============== ==== ==== ======= ===== ====================

<span class="color-comment"># Check out the input features</span>
&gt;&gt;&gt; <strong>iris.data</strong>
array([[5.1, 3.5, 1.4, 0.2], ...])   <span class="color-comment"># NumPy's 2D ndarray, numerical and continuous</span>
&gt;&gt;&gt; <strong>type(iris.data)</strong>
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; <strong>iris.data.dtype</strong>
dtype('float64')
&gt;&gt;&gt; <strong>iris.data.shape</strong>
(150, 4)
&gt;&gt;&gt; <strong>iris.feature_names</strong>
['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']

<span class="color-comment"># Check out the output target</span>
&gt;&gt;&gt; <strong>iris.target</strong>
array([0, 0, 0, 0, 0, 0, 0, 0, 0, ...])  <span class="color-comment"># NumPy's 1D ndarray, categorical and nominal</span>
&gt;&gt;&gt; <strong>type(iris.target)</strong>
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; <strong>iris.target.dtype</strong>
dtype('int32')
&gt;&gt;&gt; <strong>iris.target.shape</strong>
(150,)
&gt;&gt;&gt; <strong>iris.target_names</strong>
array(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')</pre>

<h5>Check the Statistics of the Categories</h5>

<pre class="color-example">
import numpy as np
import pandas as pd
from sklearn import datasets
<span class="color-comment"># Setup DataFrame</span>
iris = datasets.load_iris()
<span class="color-comment"># Shorten the feature names to fit the display</span>
for i in range(len(iris.feature_names)):
    iris.feature_names[i] = iris.feature_names[i][0:-5]

df = pd.DataFrame(iris.data, columns=iris.feature_names)
df['category'] = iris.target  <span class="color-comment"># Add the output target column</span>
</pre>

<pre class="color-example">
df.dtypes</pre>

<pre class="output">
sepal length    float64
sepal width     float64
petal length    float64
petal width     float64
category          int32
dtype: object</pre>

<pre class="color-example">
<span class="color-comment"># Print samples</span>
df.head()</pre>
<pre class="output">
   sepal length  sepal width  petal length  petal width  category
0           5.1          3.5           1.4          0.2         0
1           4.9          3.0           1.4          0.2         0
2           4.7          3.2           1.3          0.2         0
3           4.6          3.1           1.5          0.2         0
4           5.0          3.6           1.4          0.2         0</pre>

<pre class="color-example">
<span class="color-comment"># Setup Pandas printing format for float</span>
pd.options.display.float_format = '{:,.2f}'.format</pre>

<pre class="color-example">
<span class="color-comment"># Describe ALL Categories</span>
df.describe()</pre>
<pre class="output">
       sepal length  sepal width  petal length  petal width  category
count        150.00       150.00        150.00       150.00    150.00
mean           5.84         3.06          3.76         1.20      1.00
std            0.83         0.44          1.77         0.76      0.82
min            4.30         2.00          1.00         0.10      0.00
25%            5.10         2.80          1.60         0.30      0.00
50%            5.80         3.00          4.35         1.30      1.00
75%            6.40         3.30          5.10         1.80      2.00
max            7.90         4.40          6.90         2.50      2.00</pre>

<pre class="color-example">
<span class="color-comment"># Describe Category 0</span>
print('Cat 0:', iris.target_names[0])
df.loc[df['category'] == 0].describe()</pre>
<pre class="output">Cat 0: setosa
       sepal length  sepal width  petal length  petal width  category
count         50.00        50.00         50.00        50.00     50.00
mean           5.01         3.43          1.46         0.25      0.00
std            0.35         0.38          0.17         0.11      0.00
min            4.30         2.30          1.00         0.10      0.00
25%            4.80         3.20          1.40         0.20      0.00
50%            5.00         3.40          1.50         0.20      0.00
75%            5.20         3.68          1.58         0.30      0.00
max            5.80         4.40          1.90         0.60      0.00</pre>

<pre class="color-example">
<span class="color-comment"># Describe Category 1</span>
print('Cat 1:', iris.target_names[1])
df.loc[df['category'] == 1].describe()</pre>
<pre class="output">
Cat 1: versicolor
       sepal length  sepal width  petal length  petal width  category
count         50.00        50.00         50.00        50.00     50.00
mean           5.94         2.77          4.26         1.33      1.00
std            0.52         0.31          0.47         0.20      0.00
min            4.90         2.00          3.00         1.00      1.00
25%            5.60         2.52          4.00         1.20      1.00
50%            5.90         2.80          4.35         1.30      1.00
75%            6.30         3.00          4.60         1.50      1.00
max            7.00         3.40          5.10         1.80      1.00</pre>

<pre class="color-example">
<span class="color-comment"># Describe Category 2</span>
print('Cat 2:', iris.target_names[2])
df.loc[df['category'] == 2].describe()</pre>
<pre class="output">
Cat 2: virginica
       sepal length  sepal width  petal length  petal width  category
count         50.00        50.00         50.00        50.00     50.00
mean           6.59         2.97          5.55         2.03      2.00
std            0.64         0.32          0.55         0.27      0.00
min            4.90         2.20          4.50         1.40      2.00
25%            6.23         2.80          5.10         1.80      2.00
50%            6.50         3.00          5.55         2.00      2.00
75%            6.90         3.18          5.88         2.30      2.00
max            7.90         3.80          6.90         2.50      2.00</pre>

<h5>Scatter Plot for Each of the Input Feature vs. Category</h5>
<p>It is very hard to visualize the statistics of the categories. Let's do a scatter plot for each of the input feature vs. category.</p>

<pre class="color-example">
<span class="color-comment"># Scatter plot for each of the input features vs output category</span>
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn import datasets
iris = datasets.load_iris()

<span class="color-comment"># Scatter plot on each of input feature columns</span>
fig, ax = plt.subplots(2, 2, figsize=(8.0, 6.4))
fig.suptitle('Input Feature vs. Category')
for feature_col in [0, 1, 2, 3]:  <span class="color-comment"># for each feature</span>
    ax_row, ax_col = feature_col//2, feature_col%2
    ax[ax_row][ax_col].scatter(iris.data[:, feature_col], iris.target, c='red', s=8)
    ax[ax_row][ax_col].set_xlabel(iris.feature_names[feature_col])
    ax[ax_row][ax_col].set_ylabel('category')
    ax[ax_row][ax_col].set_yticks([0, 1, 2])
    ax[ax_row][ax_col].set_yticklabels([0, 1, 2])

    <span class="color-comment"># Overlay with the mean</span>
    means = [iris.data[:, feature_col][iris.target==0].mean(),
             iris.data[:, feature_col][iris.target==1].mean(),
             iris.data[:, feature_col][iris.target==2].mean()]
    ax[ax_row][ax_col].scatter(means, [0, 1, 2], c='blue')

fig.tight_layout()           <span class="color-comment"># Prevent subplots overlap</span>
fig.subplots_adjust(top=0.9) <span class="color-comment"># Prevent figure-title overlaps</span>
plt.show()</pre>

<img class="image-center" src="images/iris_each_feature_cat.png" alt="Each Feature vs Category" />

<p>Observation: Each of input feature is closely related to the output category except sepal width.</p>
<ol>
<li>Sepal Length: cat 0 has the smallest, cat 2 has the largest.</li>
<li>Sepal Width: not quite related.</li>
<li>Petal Length: cat 0 has the smallest, cat 2 has the largest, clearly separated.</li>
<li>Petal Width:</li>
</ol>
<p>Correlation coefficient is not applicable to categorical nominal (unordered) data.</p>

<h5>Scatter Plot of Sepal Length/Width vs. Category</h5>
<pre class="color-example">
<span class="color-comment"># Scatter plot for sepal length and width vs. category</span>
import matplotlib.pyplot as plt
from sklearn import datasets
iris = datasets.load_iris()
x_col = 0  <span class="color-comment"># sepal length column</span>
y_col = 1  <span class="color-comment"># sepal width column</span>
x = iris.data[:, x_col]
y = iris.data[:, y_col]
targets = iris.target
target_names = iris.target_names
feature_names = iris.feature_names
<span class="color-comment"># Hard code instead of using a loop for clarity</span>
plt.scatter(x[targets == 0], y[targets == 0], c='#FF6666', label=target_names[0])
plt.scatter(x[targets == 1], y[targets == 1], c='#66FF66', label=target_names[1])
plt.scatter(x[targets == 2], y[targets == 2], c='#6666FF', label=target_names[2])
plt.xlabel(feature_names[x_col])
plt.ylabel(feature_names[y_col])
plt.legend()
plt.xlim(x.min()-0.5, x.max()+0.5)
plt.ylim(y.min()-0.5, y.max()+0.5)
plt.show()</pre>
<img class="image-center" src="images/iris_sepal_length_width_cat.png" alt="sepal length and width" />

<p>Observation: Cat 0 (setosa) is clearly separated, but Cat 1 (vesicolor) and Cat 2 (Virginica) overlap.</p>

<h5>Scatter Plot of Petal Length/Width vs. Category</h5>

<pre class="color-example">
<span class="color-comment"># Scatter plot for petal length vs petal width with legend and color settings</span>
import matplotlib.pyplot as plt
from sklearn import datasets
iris = datasets.load_iris()
x_col = 2  <span class="color-comment"># petal length column</span>
y_col = 3  <span class="color-comment"># petal width column</span>
x = iris.data[:, x_col]
y = iris.data[:, y_col]
targets = iris.target
target_names = iris.target_names
feature_names = iris.feature_names
plt.scatter(x[targets == 0], y[targets == 0], c='#FF6666', label=target_names[0])
plt.scatter(x[targets == 1], y[targets == 1], c='#66FF66', label=target_names[1])
plt.scatter(x[targets == 2], y[targets == 2], c='#6666FF', label=target_names[2])
plt.xlabel(feature_names[x_col])
plt.ylabel(feature_names[y_col])
plt.legend()
plt.xlim(x.min()-0.5, x.max()+0.5)
plt.ylim(y.min()-0.5, y.max()+0.5)
plt.show()</pre>

<img class="image-center" src="images/iris_petal_length_width_cat.png" alt="petal length/width" />

<p>Observation: Cat 0 (setosa) is clearly separated. Cat 1 (vesicolor) and Cat 2 (Virginica) are reasonably separated.</p>

<h4>K-Nearest Neighbor (KNN) Learning Algorithm</h4>

<p>The KNN is among the simplest of all machine learning algorithms. It can be used for <em>classification</em> or <em>regression</em>. The steps are:</p>
<ol>
  <li>Find the k nearest neighbors to the test sample and their labels/values.</li>
<li>For classification, label the test sample by the majority vote. For regression, assign the average.</li>
</ol>

<img class="image-center" src="images/Python_KNN.png" alt="KNN" />

<p>In the case of k=1, the test sample will follow its nearest neighbor.</p>

<p>The number of neighbors (k) can be:</p>
<ol>
<li>a user-defined constant (k-nearest neighbor learning).</li>
<li>vary based on the local density of points (radius-based neighbor learning).</li>
</ol>

<p>You could assign weights to the contributions of the neighbors, so that the nearer neighbors contribute more to the average/vote than the distant ones. A common weighting scheme assigns each neighbor a weight of <code>1/d</code>, where <code>d</code> is the distance to the neighbor.</p>

<p>The distance could be measured in:</p>
<ul>
<li>Euclidean distance: most commonly used.</li>
<li>Manhattan distance:</li>
<li>Minkowski distance: The Minkowski distance is a metric in a normed vector space which can be considered as a generalization of both the Euclidean distance (p=2) and the Manhattan distance (p=1).
<img class="image-center" src="images/Python_Minkowski_Distance.png" alt="Minkowski Distance" />
</li>
<li>Hamming distance: the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different.</li>
</ul>


<p>KNN is:</p>
<ol>
<li>Non-Parametric: there is no assumption for underlying data distribution. KNN decision boundary could be irregular.</li>
<li>a Non-generalizing Lazy Learner: there is no need for training of the model. It simply remembers all its training data, possible transformed into a fast indexing structure such as a Ball Tree or KD Tree. All computation is deferred until classification (known as lazy learner).</li>
</ol>

<p>KNN suffers from &quot;curse of dimensions&quot; (Euclidean distance is useless in high dimensions because all vectors are almost equidistant to the search query vector). It is also sensitive to the local structure of the data.</p>

<h4>KNN on Iris Dataset</h4>

<p>Scikit-learn supports KNN via module <code>sklearn.neighbors</code> (@ <a href="https://scikit-learn.org/stable/modules/neighbors.html">https://scikit-learn.org/stable/modules/neighbors.html</a>).</p>

<h5>K-Nearest Neighbors (KNN) Supervised Classification</h5>

<p>In supervised learning, you need to provide both the input features and output target.</p>

<p>scikit-learn implements two  nearest neighbors  classifiers:</p>
<ol>
<li><code>KNeighborsClassifier</code> implements learning based on the k nearest neighbors of each query point, where k is an integer value specified by the user. The optimal choice of the value is highly data-dependent: in general a larger k suppresses the effects of noise, but makes the classification boundaries less distinct.</li>
<li><code>RadiusNeighborsClassifier</code> implements learning based on the number of neighbors within a fixed radius r of each training point, where r is a floating-point value specified by the user. This is a better choice if the data is not uniformly sampled.</li>
</ol>

<p>Three algorithms are supported: <code>BallTree</code>, <code>KDTree</code>, and a brute-force approach based on <code>sklearn.metrices.pairwise</code> (i.e., compare with each of the training samples), which can be chosen via keyword argument <code>algorithm='auto'|'ball_tree'|kd_tree'|'brute'</code>. When the default <code>'auto'</code> is used, it attempts to determine the best approach from the training data.</p>

<pre class="color-syntax">
&gt;&gt;&gt; <strong>from sklearn.neighbors import KNeighborsClassifier</strong>
&gt;&gt;&gt; <strong>help(KNeighborsClassifier)</strong>
KNeighborsClassifier(n_neighbors=5, weights='uniform', algorithm='auto', leaf_size=30, 
         p=2, metric='minkowski', metric_params=None, n_jobs=None, **kwargs)
    <span class="color-comment"># n_neighbors: number of neighbors to use by default for queries
    # weights: 'uniform', 'distance' (weight points by the inverse of their distance), or a callable.
    # algorithm: 'auto'|'ball_tree'|kd_tree'|'brute'
    # leaf_size: Leaf size passed to BallTree or KDTree
    # metric: distance measurement.
    # n_jobs: the number of parallel jobs to run for neighbors search</span>

&gt;&gt;&gt; <strong>from sklearn.neighbors import RadiusNeighborsClassifier</strong>
&gt;&gt;&gt; <strong>help(RadiusNeighborsClassifier)</strong>
RadiusNeighborsClassifier(radius=1.0, weights='uniform', algorithm='auto', leaf_size=30,
        p=2, metric='minkowski', outlier_label=None, metric_params=None, n_jobs=None, **kwargs)
    <span class="color-comment"># radius: Range of parameter space to use by default for queries</span></pre>

<p>Scikit-learn/SciPy provides many distance metrices:</p>

<ul>
<li>from <code>scikit-learn</code>: <code>['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 'manhattan']</code></li>
<li>from <code>scipy.spatial.distance</code>: <code>['braycurtis', 'canberra', 'chebyshev', 'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']</code></li>
</ul>

<p>Example: Iris Flower Dataset</p>

<pre class="color-example">
<span class="color-comment"># KNN Supervised Classification</span>
import numpy as np
from sklearn import datasets
iris = datasets.load_iris()

<span class="color-comment"># Prepare data (features and target) for training</span>
x = iris.data    <span class="color-comment"># features</span>
y = iris.target

<span class="color-comment"># Split the data into training set and test set</span>
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.15)  # <span class="color-comment">Randomized</span>
print('Number of Training Set samples:', len(x_train))
print('Number of Test Set samples:', len(x_test))

<span class="color-comment"># KNN Supervised Classifier</span>
from sklearn.neighbors import KNeighborsClassifier
n_neighbors, weights = 5, 'uniform'<br />knn = KNeighborsClassifier(n_neighbors=n_neighbors, weights=weights)<br />knn.fit(x_train, y_train)      <span class="color-comment"># Provide the features and target</span>

<span class="color-comment"># Get the prediction on test set</span>
y_predict = knn.predict(x_test)

<span class="color-comment"># Compare prediction and actual</span>
print(y_predict == y_test)

<span class="color-comment"># Check Accuracy</span>
from sklearn import metrics
print(&quot;Accuracy is:&quot;, metrics.accuracy_score(y_test, y_predict))</pre>

<pre class="output">
Number of Training Set samples: 127
Number of Test Set samples: 23
[ True False  True  True  True  True  True False  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True]
Accuracy is: 0.9130434782608695</pre>

<p>Observation: With the training-testing set split of 85%:15%, 2 of the test set samples fail.</p>

<p>Try:</p>
<ul>
<li>Try <code>k</code> (<code>n_neighbors</code>) of <code>5</code>, <code>10</code>,  <code>15</code></li>
<li>Try <code>weights='distance'</code> (instead of <code>'uniform'</code>)</li>
<li>Use <code>10%</code>, <code>15%</code>, <code>20%</code> for test set.</li>
</ul>


<h5>KNN Classifier Decision Boundary for Sepal Length/Width</h5>
<pre class="color-example">
<span class="color-comment"># Plot the Decision Boundary using only 2 input features: Sepal length and width</span>
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from sklearn import datasets, neighbors

<span class="color-comment"># Prepare data for training - only use sepal length and width</span>
iris = datasets.load_iris()
xy = iris.data[:, 0:2] <span class="color-comment"># Input - sepal length (x) and width (y</span>)
z = iris.target        <span class="color-comment"># Output - species</span>
x_min, x_max = xy[:,0].min()-0.5, xy[:,0].max()+0.5
y_min, y_max = xy[:,1].min()-0.5, xy[:,1].max()+0.5

<span class="color-comment"># Setup color meshgrid</span>
step = 0.02
xx, yy = np.meshgrid(np.arange(x_min, x_max, step), np.arange(y_min, y_max, step))
cmap_rgb_light = ListedColormap(['#FFCCCC','#CCFFCC','#CCCCFF'])  <span class="color-comment"># for 3 classes</span>

<span class="color-comment"># Run KNN supervised classifier</span>
n_neighbors = 15     <span class="color-comment"># default is 5</span>
weights = 'uniform'  <span class="color-comment"># default, to try 'distance'</span>
knn = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, weights=weights)
knn.fit(xy, z)       <span class="color-comment"># Features and target</span>
<span class="color-comment"># Run prediction on all points on the meshgrid</span>
z_predict = knn.predict(np.c_[xx.ravel(), yy.ravel()])  <span class="color-comment"># column stack</span>
z_predict = z_predict.reshape(xx.shape)  <span class="color-comment"># back to 2D</span>

<span class="color-comment"># Plot color mesh on prediction (decision boundary)</span>
plt.pcolormesh(xx, yy, z_predict, cmap=cmap_rgb_light)

<span class="color-comment"># Overlay the training points</span>
x, y = xy[:, 0], xy[:, 1]
cmap_rgb_dark = ListedColormap(['#FF4444','#44FF44','#4444FF'])  <span class="color-comment"># darker</span>
plt.scatter(x, y, c=z, cmap=cmap_rgb_dark, s=12)  <span class="color-comment"># s: marker size</span>

plt.xlim(xx.min(), xx.max())
plt.ylim(yy.min(), yy.max())
plt.xlabel(iris.feature_names[0])
plt.ylabel(iris.feature_names[1])
plt.title('KNN Classifier Decision Boundary on Sepal length and width')
plt.show()</pre>

<img class="image-center" src="images/iris_sepal_length_width_boundary.png" alt="sepal length/width decision boundary" />

<p>Notes:</p>
<ul>
<li>The decision boundary is irregular.</li>
<li>Try other values for <code>n_neighbors</code> and <code>weights='distance'</code>.</li>
<li>Try on petal length and width</li>
</ul>

<h5>KNN - Unsupervised Nearest Neighbors</h5>

<p>In unsupervised learning, you provide the input features, but do not need to provide the output target.</p>

<p>The <code>sklearn.neighbors.NearestNeighbors</code> implements unsupervised nearest neighbors learning. It acts as a uniform interface to three algorithms: <code>BallTree</code>, <code>KDTree</code>, and a brute-force approach based on <code>sklearn.metrices.pairwise</code> (i.e., compare with each of the training samples), which can be chosen via keyword argument <code>algorithm='auto'|'ball_tree'|kd_tree'|'brute'</code>. When the default <code>'auto'</code> is used, it attempts to determine the best approach from the training data.</p>

<pre class="color-syntax">
&gt;&gt;&gt; <strong>from sklearn.neighbors import NearestNeighbors</strong>
&gt;&gt;&gt; <strong>help(NearestNeighbors)</strong>
NearestNeighbors(n_neighbors=5, radius=1.0, algorithm='auto', leaf_size=30,
                 metric='minkowski', p=2, metric_params=None, n_jobs=None, **kwargs)
    <span class="color-comment"># n_neighbors: number of neighbors to use by default queries
    # radius: range of parameter space to use by default queries
    # algorithm: 'auto'|'ball_tree'|kd_tree'|'brute'
    # leaf_size: Leaf size passed to BallTree or KDTree
    # metric: distance measurement.
    # n_jobs: the number of parallel jobs to run for neighbors search</span></pre>


<p>Example: Iris Flower Dataset</p>
<pre class="color-example">
<span class="color-comment"># KNN - Find K Nearest Neighbors via Unsupervised Learning</span>
import numpy as np
from sklearn import datasets
iris = datasets.load_iris()

from sklearn.neighbors import NearestNeighbors
knn = NearestNeighbors()  <span class="color-comment"># Construct an instance of KNN default k=5, weights='uniform'</span>
knn.fit(iris.data)        <span class="color-comment"># Only training sample, no target for unsupervised training</span>

<span class="color-comment"># Find the K-nearest neighbors for a test sample</span>
test = np.array([5.3, 2.1, 2.2, 2.4])
test = test.reshape(1, -1)  <span class="color-comment"># reshape to column vector</span>
results = knn.kneighbors(test, 7)
print(results)  <span class="color-comment"># (distances, indexes) of the nearest neighbors</span>
print(iris.data[results[1][0]])    <span class="color-comment"># Get the features of the nearest neighbors</span>
print(iris.target[results[1][0]])  <span class="color-comment"># Get the target of the nearest neighbors</span></pre>

<pre class="output">
(array([[1.59059737, 1.81659021, 1.8493242 , 1.93649167, 1.97484177,
        2.01494417, 2.06397674]]),      <span class="color-comment"># distance to the nearest neighbors, sorted</span>
 array([[98, 93, 57, 60, 64, 79, 59]],  <span class="color-comment"># indexes of the nearest neighbors</span>
 dtype=int64))
[[5.1 2.5 3.  1.1]  <span class="color-comment"># features</span>
 [5.  2.3 3.3 1. ]
 [4.9 2.4 3.3 1. ]
 [5.  2.  3.5 1. ]
 [5.6 2.9 3.6 1.3]
 [5.7 2.6 3.5 1. ]
 [5.2 2.7 3.9 1.4]]
[1 1 1 1 1 1 1]      <span class="color-comment"># target</span></pre>


<h5>Reducing the  Feature's Dimension via PCA</h5>
<pre class="color-example">
<span class="color-comment"># Reduce the feature dimension from 4 to 3 via PCA</span>
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from mpl_toolkits.mplot3d import Axes3D
from sklearn import datasets, decomposition
iris = datasets.load_iris()

<span class="color-comment"># Run PCA</span>
iris_reduced = decomposition.PCA(n_components=3).fit_transform(iris.data)
print('Sample output records')
print(iris_reduced[:5])
np.savetxt('iris_reduced.csv', iris_reduced, delimiter=',')  <span class="color-comment"># Save for further operation</span>

<span class="color-comment"># Scatter Plot 3D</span>
fig = plt.figure()
ax = Axes3D(fig)
ax.set_title('Iris Dataset reduced by PCA', size=14)
cmap_rgb_dark = ListedColormap(['#FF4444','#44FF44','#4444FF'])
ax.scatter(iris_reduced[:,0], iris_reduced[:,1], iris_reduced[:,2], 
           c=iris.target, cmap=cmap_rgb_dark)
ax.set_xlabel('1st eigenvector')
ax.set_ylabel('2nd eigenvector')
ax.set_zlabel('3rd eigenvector')
plt.show()</pre>
<pre class="output">
Sample records
[[-2.68412563  0.31939725 -0.02791483]   <span class="color-comment"># 3D feature</span>
 [-2.71414169 -0.17700123 -0.21046427]
 [-2.88899057 -0.14494943  0.01790026]
 [-2.74534286 -0.31829898  0.03155937]
 [-2.72871654  0.32675451  0.09007924]]</pre>
 
<img class="image-center" src="images/iris_pca.png" alt="PCA" />

<h5>KNN Classifier with Reduced Dimension</h5>

<pre class="color-example">
<span class="color-comment"># KNN Supervised Classification on reduced dimension</span>
import numpy as np
from sklearn import datasets
iris = datasets.load_iris()

<span class="color-comment"># Prepare data (features and target) for training</span>
x = np.loadtxt('iris_reduced.csv', delimiter=',')  <span class="color-comment"># Retrieved from save file</span>
y = iris.target

<span class="color-comment"># Split the data into training set and test set</span>
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.15)  <span class="color-comment"># Randomized</span>
print('Number of Training Set samples:', len(x_train))
print('Number of Test Set samples:', len(x_test))

<span class="color-comment"># KNN Supervised Classifier</span>
from sklearn.neighbors import KNeighborsClassifier
n_neighbors, weights = 10, 'distance'
knn = KNeighborsClassifier(n_neighbors=n_neighbors, weights=weights)
knn.fit(x_train, y_train)      <span class="color-comment"># Provide the features and target</span>

<span class="color-comment"># Get the prediction on test set</span>
y_predict = knn.predict(x_test)

<span class="color-comment"># Compare prediction and actual</span>
print(y_predict == y_test)

<span class="color-comment"># Check Accuracy</span>
from sklearn import metrics
print('Accuracy is:', metrics.accuracy_score(y_test, y_predict))</pre>

<pre class="output">
Number of Training Set samples: 127
Number of Test Set samples: 23
[ True  True  True  True  True  True  True  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True]
Accuracy is: 1.0</pre>

<p>Observations: With the reduced dimension, the accuracy is <code>100%</code>.</p>

<h5>Nearest Centroid Classifier</h5>

<p>The <code>NearestCentroid</code> classifier is a simple algorithm that represents each class by the centroid of its members. It is similar to the label updating phase of the <code>sklearn.KMeans</code> algorithm. It  has no parameters to choose, making it a good baseline classifier. It does, however, suffer on non-convex classes, as well as when classes have drastically different variances, as equal variance in all dimensions is assumed.</p>

<pre class="color-syntax">
NearestCentroid(metric='euclidean', shrink_threshold=None)</pre>

<p>For example,</p>

<pre class="color-example">
<span class="color-comment"># Plot the Decision Boundary for Nearest Centroid Classifier
# using only 2 input features: Sepal length and width</span>
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from sklearn import datasets, neighbors

<span class="color-comment"># Prepare data for training - only use sepal length and width</span>
iris = datasets.load_iris()
xy = iris.data[:, 0:2] <span class="color-comment"># Input - sepal length (x) and width (y)</span>
z = iris.target        <span class="color-comment"># Output - species</span>
x_min, x_max = xy[:,0].min()-0.5, xy[:,0].max()+0.5
y_min, y_max = xy[:,1].min()-0.5, xy[:,1].max()+0.5

<span class="color-comment"># Setup color meshgrid</span>
step = 0.02
xx, yy = np.meshgrid(np.arange(x_min, x_max, step), np.arange(y_min, y_max, step))
cmap_rgb_light = ListedColormap(['#FFCCCC','#CCFFCC','#CCCCFF'])  <span class="color-comment"># for 3 classes</span>

<span class="color-comment"># Run Nearest Centroid Classifier</span>
knn = neighbors.NearestCentroid()
knn.fit(xy, z)       <span class="color-comment"># Features and target</span>
<span class="color-comment"># Run prediction on all points on the meshgrid</span>
z_predict = knn.predict(np.c_[xx.ravel(), yy.ravel()])  <span class="color-comment"># column stack</span>
z_predict = z_predict.reshape(xx.shape)  <span class="color-comment"># back to 2D</span>

<span class="color-comment"># Plot color mesh on prediction (decision boundary)</span>
plt.pcolormesh(xx, yy, z_predict, cmap=cmap_rgb_light)

<span class="color-comment"># Overlay the training points</span>
x, y = xy[:, 0], xy[:, 1]
cmap_rgb_dark = ListedColormap(['#FF4444','#44FF44','#4444FF'])  <span class="color-comment"># darker</span>
plt.scatter(x, y, c=z, cmap=cmap_rgb_dark, s=12)  <span class="color-comment"># s: marker size</span>

plt.xlim(xx.min(), xx.max())
plt.ylim(yy.min(), yy.max())
plt.xlabel(iris.feature_names[0])
plt.ylabel(iris.feature_names[1])
plt.title('Nearest Centroid Classifier Decision Boundary on Sepal length and width')
plt.show()</pre>

<img class="image-center" src="images/iris_sepal_length_width_boundary_centroid.png" alt="Nearest Centroid" />

<h5>Nearest Shrunken Centroid Classifier</h5>

<p>The <code>NearestCentroid</code> classifier has a parameter <code>shrink_threshold</code>, which implements the <em>nearest shrunken centroid classifier</em> that removes noisy features from the classification. The value of each feature for each centroid is first divided by the within-class variance of that feature. It it then reduced by <code>shrink_threshold</code>. If the resultant value crosses zero, it is set to zero. In effect, this removes the feature from affecting the classification. This is useful for removing noisy features.</p>

<p>Example: Modify the above program for <code>shrink_threshold</code> of 0.1, 0.2, 0.3.</p>

<p>[TODO] Compare</p>

<h5>KNN Regressors</h5>

<p>Neighbors-based regression can be used in cases where the data labels are continuous rather than categorical. The label assigned to a query point is computed based on the average of its nearest neighbors.</p>
<p>scikit-learn implements two nearest neighbors regressors: <code>KNeighborsRegressor</code> based on the nearest k neighbors of each query point, where k is an integer value specified by the user. <code>RadiusNeighborsRegressor</code> based on the neighbors within a fixed radius r of the query point, where r is a floating-point value specified by the user.</p>

<p>Example: [TODO] Iris Flower Dataset are not applicable to regression as its target is categorical, not continuous.</p>

<h5>Correlation</h5>
<p>[TODO]</p>

<h4>Wine Dataset</h4>

<p>This dataset is the result of a chemical analysis of wines grown in the same region in Italy using three different cultivars.</p>

<ul>
<li>13 Input Features: 'alcohol', 'malic_acid', 'ash', 'alcalinity_of_ash', 'magnesium', 'total_phenols', 'flavanoids', 'nonflavanoid_phenols', 'proanthocyanins', 'color_intensity', 'hue', 'od280/od315_of_diluted_wines', 'proline'.</li>
<li>Target: 3 type of cultivars ('class_0', 'class_1', 'class_2')</li>
<li>Samples: 178 (class_0: 59, class_1: 71, class_2: 48)</li>
</ul>

<p>You can load the Wine dataset from scikit-learn's <code>datasets</code>:</p>
<pre class="color-example">
from sklearn import datasets
wine = datasets.load_wine()
print(wind.DESCP)
</pre>
<pre class="output">
Wine recognition dataset
------------------------
    :Number of Instances: 178 (50 in each of three classes)
    :Number of Attributes: 13 numeric, predictive attributes and the class
    :Attribute Information:
 		- Alcohol
 		- Malic acid
 		- Ash
		- Alcalinity of ash  
 		- Magnesium
		- Total phenols
 		- Flavanoids
 		- Nonflavanoid phenols
 		- Proanthocyanins
		- Color intensity
 		- Hue
 		- OD280/OD315 of diluted wines
 		- Proline

    - class:
            - class_0
            - class_1
            - class_2
		
    :Summary Statistics:
    
    ============================= ==== ===== ======= =====
                                   Min   Max   Mean     SD
    ============================= ==== ===== ======= =====
    Alcohol:                      11.0  14.8    13.0   0.8
    Malic Acid:                   0.74  5.80    2.34  1.12
    Ash:                          1.36  3.23    2.36  0.27
    Alcalinity of Ash:            10.6  30.0    19.5   3.3
    Magnesium:                    70.0 162.0    99.7  14.3
    Total Phenols:                0.98  3.88    2.29  0.63
    Flavanoids:                   0.34  5.08    2.03  1.00
    Nonflavanoid Phenols:         0.13  0.66    0.36  0.12
    Proanthocyanins:              0.41  3.58    1.59  0.57
    Colour Intensity:              1.3  13.0     5.1   2.3
    Hue:                          0.48  1.71    0.96  0.23
    OD280/OD315 of diluted wines: 1.27  4.00    2.61  0.71
    Proline:                       278  1680     746   315
    ============================= ==== ===== ======= =====

    :Missing Attribute Values: None
    :Class Distribution: class_0 (59), class_1 (71), class_2 (48)</pre>

<h5>KNN Supervised Classifier</h5>

<pre class="color-example">
<span class="color-comment"># KNN Classifier for Wine dataset</span>
from sklearn import datasets
wine = datasets.load_wine()

<span class="color-comment"># Split data into training set and test set</span>
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(
        wine.data, wine.target, test_size=0.2)

<span class="color-comment"># Generate KNN Classifier model</span>
from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors=15, weights='distance')
<span class="color-comment"># Train the model using the training sets</span>
knn.fit(x_train, y_train)   <span class="color-comment"># Feature, target</span>
<span class="color-comment"># Predict the response for test dataset</span>
y_pred = knn.predict(x_test)

<span class="color-comment"># Evaluate model</span>
print(y_pred == y_test)  <span class="color-comment"># Check predication results</span>
from sklearn import metrics
print('Accuracy:', metrics.accuracy_score(y_test, y_pred))</pre>

<pre class="output">
[ True  True  True False  True  True  True  True False  True  True  True
 False False  True  True False  True  True False False  True False False
 False  True  True  True  True False  True  True  True  True  True False]
Accuracy: 0.6666666666666666</pre>

<p>Observations: Accuracy is <code>66%</code>.</p>

<h3>Case Studies</h3>

<h5>Case Study 1</h5>
<p>[TODO]</p>

<h5>Case Study 2</h5>
<p>[TODO]</p>



<!-- @@ start change in v1 -->
<p class="references">REFERENCES &amp; RESOURCES</p>

<ol>
<li>Scikit-Learn Documentation @ <a href="https://scikit-learn.org/stable/documentation.html">https://scikit-learn.org/stable/documentation.html</a>.</li>
<li>Fabio Nelli, Python Data Analytics, Apress, 2015.</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: Python (Ubuntu) 2.7 and 3.7<br />
Last modified: December, 2018</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
