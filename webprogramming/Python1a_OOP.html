<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- for responsive web design -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- for SEO -->
<meta name="description" content="Python Tutorial - Object-Oriented Programming (OOP)">
<meta name="keywords" content="Python, Tutorial, OOP">
<title>Python Tutorial - Object-Oriented Programming (OOP)</title>

<!-- @@ v3 header changes starts here after <title> -->
<!-- My custom CSS v3 -->
<link rel="stylesheet" href="../css/programming_notes_v3.css">
<!-- Prism Syntax Highlighter -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.css" rel="stylesheet" />
<!-- favicon -->
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
</head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header">
<p>c</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>Table of Contents <a id="show-toc" href="Python1a_OOP.html#show-toc">(Hide)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<!-- @@ v3 header changes ends here before "content-header" <h1> and <h2>"" -->
<div id="content-header">
<h1>Python</h1>
<h2>Object Oriented Programming (OOP)</h2>
</div>

<div id="content-main">

<!-- @@ end change in v1 -->

<p>I assume that you are familiar with the OOP concepts (such as class and instance, composition, inheritance and polymorphism), and you know some OO languages such as Java/C++/C#. This article is not an introduction to OOP.</p>

<h3 id="basics">Python OOP Basics</h3>

<h4>OOP Basics</h4>
<p>A <em>class</em> is a blueprint (or template) of entities (things) of the same kind. An <em>instance</em> is a particular realization of a class.</p>

<p>Unlike C++/Java, Python supports both class objects and instance objects. In fact, everything in Python is object, including class object.</p>

<p>An object contains <em>attributes</em>: <em>data attributes</em> (or <em>static attribute</em> or <em>variables</em>) and dynamic behaviors called <em>methods</em>. In UML diagram, objects are represented by 3-compartment boxes: name, data attributes and methods, as shown below:</p>

<img class="image-center" src="../java/images/OOP_ThreeCompartment.png" alt="OOP_ThreeCompartment.png" />

<p>To access an attribute, use &quot;dot&quot; operator in the form of <code><em>class_name</em>.<em>attr_name</em></code> or <code><em>instance_name</em>.<em>attr_name</em></code>.</p>

<p>To construct an instance of a class, invoke the constructor in the form of <code><em>instance_name</em> = <em>class_name</em>(<em>args</em>)</code>.</p>

<img class="image-center" src="../java/images/OOP_Objects.png" alt="OOP_Objects.png" />


<h4>Example 1: Getting Started with a <code>Circle</code> class</h4>

<p>Let's write a module called <code>circle</code> (to be saved as <code>circle.py</code>), which contains a <code>Circle</code> class. The <code>Circle</code> class shall contain a data attribute <code>radius</code> and a method <code>get_area()</code>, as shown in the following class diagram.</p>

<img class="image-center" src="images/Python_Circle.png" alt="Circle class diagram" />

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
circle.py: The circle module, which defines a Circle class.
"""
from math import pi
 
class Circle:    # For Python 2 use: "class Circle(object):"
    """A Circle instance models a circle with a radius"""
 
    def __init__(self, radius=1.0):
        """Initializer with default radius of 1.0"""
        self.radius = radius  # Create an instance variable radius
 
    def __str__(self):
        """Return a descriptive string for this instance, invoked by print() and str()"""
        return 'This is a circle with radius of {:.2f}'.format(self.radius)
 
    def __repr__(self):
        """Return a formal string that can be used to re-create this instance, invoked by repr()"""
        return 'Circle(radius={})'.format(self.radius)
 
    def get_area(self):
        """Return the area of this Circle instance"""
        return self.radius * self.radius * pi
 
# For Testing under Python interpreter
# If this module is run under Python interpreter, __name__ is '__main__'.
# If this module is imported into another module, __name__ is 'circle' (the module name).
if __name__ == '__main__':
    c1 = Circle(2.1)      # Construct an instance
    print(c1)             # Invoke __str__(): This is a circle with radius of 2.10
    print(c1.get_area())  # 13.854423602330987
    print(c1.radius)      # 2.1
    print(str(c1))        # Invoke __str__(): This is a circle with radius of 2.10
    print(repr(c1))       # Invoke __repr__(): Circle(radius=2.1)

    c2 = Circle()         # Default radius
    print(c2)
    print(c2.get_area())  # Invoke member method
 
    c2.color = 'red'  # Create a new attribute for this instance via assignment
    print(c2.color)
    #print(c1.color)  # Error - c1 has no attribute color
 
    # Test doc-strings
    print(__doc__)                  # This module
    print(Circle.__doc__)           # Circle class
    print(Circle.get_area.__doc__)  # get_area() method
 
    print(isinstance(c1, Circle)) # True
    print(isinstance(c2, Circle)) # True
    print(isinstance(c1, str))    # False</code></pre>


<p>Run this script, and check the outputs:</p>

<pre class="output">
This is a circle with radius of 2.10
13.854423602330987
2.1
This is a circle with radius of 2.10
Circle(radius=2.1)
This is a circle with radius of 1.00
3.141592653589793
red

circle.py: The circle module, which defines a Circle class.

A Circle instance models a circle with a radius
Return the area of this Circle instance
True
True
False</pre>


<h5>How It Works?</h5>

<ol>
<li>By convention, module names (and package names) are in lowercase (optionally joined with underscore if it improves readability). Class names are initial-capitalized (i.e., CamelCase). Variable and method names are also in lowercase.  <br>Following the convention, this module is called <code>circle</code> (in lowercase) and is to be saved as &quot;<code>circle.py</code>&quot; (the module name is the filename - there is no explicit way to name a module). The class is called <code>Circle</code> (in CamelCase). It contains a data attribute (instance variable) <code>radius</code> and a method <code>get_area()</code>.</li>

<li><span class="lead-code">class Circle:</span> (Line 8): define the <code>Circle</code> class.<br>NOTES: In Python 2, you need to write &quot;<code>class Circle(object):</code>&quot; to create a so-called <em>new-style</em> class by inheriting from the default superclass <code>object</code>.  Otherwise, it will create a <em>old-style</em> class. The <em>old-style</em> classes should no longer be used. In Python 3, &quot;<code>class Circle:</code>&quot; inherits from <code>object</code> by default.</li>

<li><span class="lead-code">self</span> (Line 11, 15, 19, 23): The first parameter of all the member methods shall be an object called <code>self</code> (e.g., <code>get_area(self)</code>, <code>__init__(self, ...)</code>), which binds to this instance (i.e., itself) during invocation.</li>

<li>You can invoke a method via the dot operator, in the form of <em><code>obj_name</code></em><code>.<em>method_name</em>()</code>. However, Python differentiates between instance objects and class objects:

<ul>
<li>For class objects: You can invoke a method via:
  <pre class="example">
<strong><em>class_name</em></strong>.<em>method_name</em>(<em>instance_name</em>, ...)</pre>
where an <code><em>instance_name</em></code> is passed into the method as the argument  <code>'self'</code>.</li>

<li>For instance objects: Python converts an instance method call from:
<pre class="example">
<strong><em>instance_name</em></strong>.<em>method_name</em>(...)</pre>
to
<pre class="example">
<strong><em>class_name</em></strong>.<em>method_name</em>(<strong><em>instance_name</em></strong>, ...)</pre>
where the <code><em>instance_name</em></code> is passed into the method as the argument  <code>'self'</code>.
</li>
</ul>
I will elaborate on this later.</li>

<li><span class="lead">Constructor </span> <span class="lead-code">__init__()</span> (Line 11): You can construct an instance of a class by invoking its constructor, in the form of <code><em>class_name</em>(...)</code>, e.g.,
  <pre class="example">
c1 = Circle(1.2)
c2 = Circle()      <span class="comment"># radius default</span></pre>
Python first creates a plain <code>Circle</code> object. It then invokes the <code>Circle</code>'s <code>__init__(self, radius)</code> with <code>self</code> bound to the newly created instance, as follows:
<pre class="example">
Circle.__init__(c1, 1.2)
Circle.__init__(c2)       <span class="comment"># radius default</span></pre>
Inside the <code>__init__()</code> method, the <code>self.radius = radius</code> creates and attaches an instance variable <code>radius</code> under the instances <code>c1</code> and <code>c2</code>.<br>Take note that:
<ul>
<li><code>__init__()</code> is not really the constructor, but an <em>initializer</em> to create the instance variables.</li>
<li><code>__init__()</code> shall never return a value.</li>
<li><code>__init__()</code> is optional and can be omitted if there is no instance variables.</li>
</ul>
</li>

<li>There is no need to declare instance variables. The variable assignment statements in <code>__init__()</code> create the instance variables.</li>
<li>Once instance <code>c1</code> was created, invocation of instance method <code>c1.get_area()</code> (Line 33) is translated to <code>Circle.getArea(c1)</code> where <code>self</code> is bound to <code>c1</code>. Within the method, <code>self.radius</code> is bound to <code>c1.radius</code>, which was created during the initialization.</li>

<li>You can dynamically add an attribute after an object is constructed via assignment, as in <code>c2.color='red'</code> (Line 39). This is unlike other OOP languages like C++/Java.</li>

<li>You can place doc-string for module, class, and method immediately after their declaration. The doc-string can be retrieved via attribute <code>__doc__</code>. Doc-strings are strongly recommended for proper documentation.</li>

<li>There is no &quot;private&quot; access control. All attributes are &quot;public&quot; and visible to all.</li>

<li>[TODO] unit-test and doc-test</li>
<li>[TODO] more</li>
</ol>
    

<h4>Inspecting the Instance and Class Objects</h4>

<p>Run the <code>circle.py</code> script under the Python Interactive Shell. The script creates one class object <code>Circle</code> and two instance objects <code>c1</code> and <code>c2</code>.</p>
<pre class="command">
$ <strong>cd /<em>path</em>/<em>to</em>/<em>module_directory</em></strong>
$ <strong>python3</strong>
&gt;&gt;&gt; <strong>exec(open('circle.py').read())</strong>
......

&gt;&gt;&gt; <strong>dir()</strong>        <span class="comment"># Return the list of names in the current local scope</span>
['<span class="new">Circle'</span>, '__built-ins__', '__doc__', '__file__', '__loader__', '__name__',
 '__package__', '__spec__', '<span class="new">c1</span>', '<span class="new">c2</span>', 'pi']
&gt;&gt;&gt; <strong>__name__</strong>
'__main__'

<span class="comment"># Inspect &quot;instance&quot; object c1</span>
&gt;&gt;&gt; <strong>dir(c1)</strong>      <span class="comment"># List all attributes including built-ins</span>
['__class__', '__dict__', '__doc__', '__init__', '__str__', '<span class="new">get_area</span>', '<span class="new">radius</span>', ...]
&gt;&gt;&gt; <strong>vars(c1)</strong>     <span class="comment"># Return a dictionary of instance variables kept in __dict__</span>
{'radius': 2.1}
&gt;&gt;&gt; <strong>c1.__dict__</strong>  <span class="comment"># Same as vars(c1)</span>
{'radius': 2.1}
&gt;&gt;&gt; <strong>c1.__class__</strong>
&lt;class '__main__.Circle'&gt;
&gt;&gt;&gt; <strong>type(c1)</strong>     <span class="comment"># Same as c1.__class__</span>
&lt;class '__main__.Circle'&gt;
&gt;&gt;&gt; <strong>c1.__doc__</strong>
'A Circle instance models a circle with a radius'
&gt;&gt;&gt; <strong>c1.__module__</strong>
'__main__'
&gt;&gt;&gt; <strong>c1.__init__</strong>
&lt;bound method Circle.__init__ of Circle(radius=2.100000)&gt;
&gt;&gt;&gt; <strong>c1.__str__</strong>
&lt;bound method Circle.__str__ of Circle(radius=2.100000)&gt;
&gt;&gt;&gt; <strong>c1.__str__()</strong>  <span class="comment"># or str(c1), or print(c1)</span>
'This is a circle with radius of 2.10'
&gt;&gt;&gt; <strong>c1.__repr__()</strong>  <span class="comment"># or repr(c1)</span>
'Circle(radius=2.100000)'
&gt;&gt;&gt; <strong>c1</strong>  <span class="comment"># same as c1.__repr__()</span>
Circle(radius=2.100000)
&gt;&gt;&gt; <strong>c1.radius</strong>
2.1
&gt;&gt;&gt; <strong>c1.get_area</strong>
&lt;bound method Circle.get_area of Circle(radius=2.100000)&gt;
&gt;&gt;&gt; <strong>c1.get_area()</strong>  <span class="comment"># Same as Circle.get_area(c1)</span>
13.854423602330987

<span class="comment"># Inspect &quot;instance&quot; object c2</span>
&gt;&gt;&gt; <strong>dir(c2)</strong>
['<span class="new">color</span>', 'get_area', 'radius', ...]
&gt;&gt;&gt; <strong>type(c2)</strong>  <span class="comment"># or c2.__class__</span>
&lt;class '__main__.Circle'&gt;
&gt;&gt;&gt; <strong>vars(c2)</strong>  <span class="comment"># or c2.__dict__</span> 
{'radius': 1.0, <span class="new">'color': 'red'</span>}
&gt;&gt;&gt; <strong>c2.radius</strong>
1.0
&gt;&gt;&gt; <strong>c2.color</strong>
'red'
&gt;&gt;&gt; <strong>c2.__init__</strong>
&lt;bound method Circle.__init__ of Circle(radius=1.000000)&gt;


<span class="comment"># Inspect the &quot;class&quot; object Circle</span>
&gt;&gt;&gt; <strong>dir(Circle)</strong>   <span class="comment"># List all attributes for Circle object</span>
['__class__', '__dict__', '__doc__', '__init__', '__str__', '<span class="new">get_area</span>', ...]
&gt;&gt;&gt; <strong>help(Circle)</strong>  <span class="comment"># Show documentation</span>
......
&gt;&gt;&gt; <strong>Circle.__class__</strong>
&lt;class 'type'&gt;
&gt;&gt;&gt; <strong>Circle.__dict__</strong>   <span class="comment"># or vars(Circle)</span>
mappingproxy({'__init__': ..., 'get_area': ..., '__str__': ..., '__dict__': ...,
 '__doc__': 'A Circle instance models a circle with a radius', '__module__': 
 '__main__'})
&gt;&gt;&gt; <strong>Circle.__doc__</strong>
'A Circle instance models a circle with a radius'
&gt;&gt;&gt; <strong>Circle.__init__</strong>
&lt;function Circle.__init__ at 0x7fb325e0cbf8&gt;
&gt;&gt;&gt; <strong>Circle.__str__</strong>
&lt;function Circle.__str__ at 0x7fb31f3ee268&gt;
&gt;&gt;&gt; <strong>Circle.__str__(c1)</strong>  <span class="comment"># Same as c1.__str__() or str(c1) or print(c1)</span>
'This is a circle with radius of 2.10'
&gt;&gt;&gt; <strong>Circle.get_area</strong>
&lt;function Circle.get_area at 0x7fb31f3ee2f0&gt;
&gt;&gt;&gt; <strong>Circle.get_area(c1)</strong>  <span class="comment"># Same as c1.get_area()</span>
13.854423602330987</pre>

<h4>Class Objects vs Instance Objects</h4>

<p>As illustrated in the above example, there are two kinds of objects in Python's OOP model: class objects and instance objects, which is quite different from other OOP languages (such as Java/C++).</p>

<p>Class objects provide default behavior and serve as factories for generating instance objects. Instance objects are the real objects created by your application. An instance object has its own namespace. It copies all the names from the class object from which it was created.</p>

<p>The <code>class</code> statement creates a class object of the given class name. Within the class definition, you can create class variables via assignment statements, which are shared by all the instances.  You can also define methods, via the <code>def</code>s, to be shared by all the instances.</p>

<p>When an instance is created, a new namespace is created, which is initially empty. It clones the class object and attaches all the class attributes. The <code>__init__()</code> is then invoked to create (initialize) instance variables, which are only available to this particular instance.</p>

<p>[TODO] more</p> 
  

<h4><code>__str__()</code> vs. <code>__repr__()</code></h4>

<p>The built-in functions <code>print(<em>obj</em>)</code> and <code>str(<em>obj</em>)</code> invoke <code><em>obj</em>.__str__()</code> implicitly.  If <code>__str__()</code> is not defined, they invoke <code>obj.__repr__()</code>.</p>

<p>The built-in function <code>repr(<em>obj</em>)</code> invokes <code><em>obj</em>.__repr__()</code> if defined; otherwise <code><em>obj</em>.__str__()</code>.</p>

<p>When you inspect an object (e.g., <code>c1</code>) under the interactive prompt, Python invokes <code><em>obj</em>.__repr__()</code>. The default (inherited) <code>__repr__()</code> returns the <code><em>obj</em></code>'s address.</p>

<p>The <code>__str__()</code> is used for printing an &quot;informal&quot; descriptive string of this object. The <code>__repr__()</code> is used to present an &quot;official&quot; (or canonical) string representation of this object, which should look like a valid Python expression that could be used to re-create the object (i.e., <code>eval(repr(<em>obj</em>)) == <em>obj</em></code>). In our <code>Circle</code> class, <code>repr(c1)</code> returns <code>'Circle(radius=2.100000)'</code>.  You can use &quot;<code>c1 = Circle(radius=2.100000)</code>&quot; to re-create instance <code>c1</code>.</p>
<p><code>__str__()</code> is meant for the users; while <code>__repr__()</code> is meant for the developers for debugging the program. All classes should have both the <code>__str__()</code> and <code>__repr__()</code>.</p>

<p>You could re-direct <code>__repr__()</code> to <code>__str__()</code> (but not recommended) as follows:</p>
<pre class="example">
    def __repr__(self):
        <span class="comment">&quot;&quot;&quot;Return a formal string invoked by repr()&quot;&quot;&quot;</span>
        return self.__str__()   <span class="comment"># or Circle.__str__(self)</span></pre>

<h4>Import</h4>

<h5>Importing the <code>circle</code> module</h5>

<p>When you use &quot;<code>import circle</code>&quot;, a namespace for <code>circle</code> is created under the current scope. You need to reference the <code>Circle</code> class as <code>circle.Circle</code>.</p>

<pre class="command">
$ <strong>cd /<em>path</em>/<em>to</em>/<em>module_directory</em></strong>
$ <strong>python3</strong>
&gt;&gt;&gt; <strong>import circle</strong>  <span class="comment"># circle module</span>
&gt;&gt;&gt; <strong>dir()</strong>          <span class="comment"># Current local scope</span>
['__built-ins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', <span class="new">'circle'</span>]
&gt;&gt;&gt; <strong>dir(circle)</strong>    <span class="comment"># The circle module</span>
[<span class="new">'Circle'</span>, '__built-ins__', '__doc__', '__name__', 'pi', ...]
&gt;&gt;&gt; <strong>dir(circle.Circle)</strong>  <span class="comment"># Circle class</span>
['__class__', '__doc__', '__init__', '__str__', 'get_area', ...]
&gt;&gt;&gt; <strong>__name__</strong>            <span class="comment"># of  current scope</span>
'__main__'
&gt;&gt;&gt; <strong>circle.__name__</strong>     <span class="comment"># of  circle module</span>
'circle'
&gt;&gt;&gt; <strong>c1 = circle.Circle(1.2)</strong>
&gt;&gt;&gt; <strong>dir(c1)</strong>
['__class__', '__doc__', '__str__', 'get_area', 'radius', ...]
&gt;&gt;&gt; <strong>vars(c1)</strong>
{'radius': 1.2}</pre>

<h5>Importing the <code>Circle</code> class of the <code>circle</code> module</h5>

<p>When you import the <code>Circle</code> class via &quot;<code>from circle import Circle</code>&quot;, the <code>Circle</code> class is added to the current scope, and you can reference the <code>Circle</code> class directly.</p>

<pre class="command">
&gt;&gt;&gt; <strong>from circle import Circle</strong>
&gt;&gt;&gt; <strong>dir()</strong>
[<span class="new">'Circle'</span>, '__built-ins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
&gt;&gt;&gt; <strong>c1 = Circle(3.4)</strong>
&gt;&gt;&gt; <strong>vars(c1)</strong>
{'radius': 3.4}</pre>


<h4>Class Definition Syntax</h4>

<p>The syntax is:</p>

<pre class="syntax">
<strong>class</strong> <em>class_name</em><strong>(</strong><em>superclass</em>_1, ...<strong>):</strong>
    <span class="comment">&quot;&quot;&quot;Class doc-string&quot;&quot;&quot;</span>
   
    <em>class_var_1 = value_1</em>  <span class="comment"># Class variables</span>
    ......
   
    <strong>def __init__(self,</strong> <em>arg_1</em>, ...<strong>):</strong>
        <span class="comment">&quot;&quot;&quot;Initializer&quot;&quot;&quot;</span>
        <strong>self.</strong><em>instance_var_1</em> = <em>arg_1</em>  <span class="comment"># Attach instance variables by assignment</span>
        ......
      
    <strong>def __str__(self):</strong>
        <span class="comment">&quot;&quot;&quot;For printf() and str()&quot;&quot;&quot;</span>
        ......
      
    <strong>def __repr__(self):</strong>
        <span class="comment">&quot;&quot;&quot;For repr() and interactive prompt&quot;&quot;&quot;</span>
        ......
      
    <strong>def</strong> <em>method_name</em><strong>(self,</strong> *<em>args</em>, **<em>kwargs</em><strong>)</strong>:
        <span class="comment">&quot;&quot;&quot;Method doc-string&quot;&quot;&quot;</span>
        ......</pre>
      
<h4>Example 2: The <code>Point</code> class and Operator Overloading</h4>

<p>In this example, we shall define a <code>Point</code> class, which models a 2D point with x and y coordinates. We shall also overload the operators <code>'+'</code> and <code>'*'</code> by overriding the so-called <em>magic</em> methods <code>__add__()</code> and <code>__mul__()</code>.</p>

<img class="image-center" src="images/Python_PointClass.png" alt="Point class diagram" />

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""
point.py: The point module, which defines the Point class
"""
 
class Point:    # In Python 2, use: class Point(object):
    """A Point instance models a 2D point with x and y coordinates"""
 
    def __init__(self, x = 0, y = 0):
        """Initializer, which creates the instance variables x and y with default of (0, 0)"""
        self.x = x
        self.y = y
 
    def __str__(self):
        """Return a descriptive string for this instance"""
        return '({}, {})'.format(self.x, self.y)
 
    def __repr__(self):
        """Return a command string to re-create this instance"""
        return 'Point(x={}, y={})'.format(self.x, self.y)
 
    def __add__(self, right):
        """Override the '+' operator: create and return a new instance"""
        p = Point(self.x + right.x, self.y + right.y)
        return p
 
    def __mul__(self, factor):
        """Override the '*' operator: modify and return this instance"""
        self.x *= factor
        self.y *= factor
        return self
 
# Test
if __name__ == '__main__':
    p1 = Point()
    print(p1)      # (0.00, 0.00)
    p1.x = 5
    p1.y = 6
    print(p1)      # (5.00, 6.00)
    p2 = Point(3, 4)
    print(p2)      # (3.00, 4.00)
    print(p1 + p2) # (8.00, 10.00) Same as p1.__add__(p2)
    print(p1)      # (5.00, 6.00) No change
    print(p2 * 3)  # (9.00, 12.00) Same as p1.__mul__(p2)
    print(p2)      # (9.00, 12.00) Changed</code></pre>

<h5>How It Works?</h5>

<ol>
<li>Python supports operator overloading (like C++ but unlike Java). You can overload <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, <code>'/'</code>, <code>'//'</code> and <code>'%'</code> by overriding member methods <code>__add__()</code>, <code>__sub__()</code>, <code>__mul__()</code>, <code>__truediv__()</code>, <code>__floordiv__()</code> and <code>__mod__()</code>, respectively. You can overload other operators too (to be discussed later).</li>

<li>In this example, the <code>__add__()</code> returns a new instance; whereas the <code>__mul__()</code> multiplies into this instance and returns this instance, for academic purpose.</li>

</ol>

<h4>The <code>getattr()</code>, <code>setattr()</code>, <code>hasattr()</code> and <code>delattr()</code> Built-in Functions</h4>

<p>You can access an object's attribute via the dot operator by hard-coding the attribute name, provided you know the attribute name in compile time.</p>
<p>For example, you can use：</p>
<ul>
<li><span class="lead-code"><em>obj_name</em>.<em>attr_name</em></span>: to read an attribute</li>
<li><span class="lead-code"><em>obj_name</em>.<em>attr_name</em> = <em>value</em></span>: to write value to an attribute</li>
<li><span class="lead-code">del <em>obj_name</em>.<em>attr_name</em></span>: to delete an attribute</li>
</ul>

<p>Alternatively, you can use built-in functions like <code>getattr()</code>, <code>setattr()</code>, <code>delattr()</code>, <code>hasattr()</code>, by using a variable to hold an attribute name, which will be bound during runtime.</p>
<ul>
<li><span class="lead-code">hasattr(<em>obj_name</em>, <em>attr_name</em>) -&gt; bool</span>: returns <code>True</code> if the <em><code>obj_name</code></em> contains the <code><em>atr_name</em></code>.</li>

<li><span class="lead-code">getattr(<em>obj_name</em>, <em>attr_name</em>[, <em>default</em>]) -&gt; <em>value</em></span>: returns the value of the <code><em>attr_name</em></code> of the <code><em>obj_name</em></code>, equivalent to <code><em>obj_name</em>.<em>attr_name</em></code>. If the <code><em>attr_name</em></code> does not exist, it returns the <code><em>default</em></code> if present; otherwise, it raises <code>AttributeError</code>.</li>

<li><span class="lead-code">setattr(<em>obj_name</em>, <em>attr_name</em>, <em>attr_value</em>)</span>: sets a value to the attribute, equivalent to <code><em>obj_name</em>.<em>attr_name</em> = <em>value</em></code>.</li>

<li><span class="lead-code">delattr(<em>obj_name</em>, <em>attr_name</em>)</span>: deletes the named attribute, equivalent to <code>del <em>obj_name</em>.<em>attr_name</em></code>.</li>
</ul>

<p>For example:</p>

<pre class="example">
class MyClass:
    <span class="comment">&quot;&quot;&quot;This class contains an instance variable called myvar&quot;&quot;&quot;</span>
    def __init__(self, myvar):
        self.myvar = myvar

myinstance = MyClass(8)
print(myinstance.myvar)              <span class="output">#8</span>
print(getattr(myinstance, 'myvar'))  <span class="output">#8</span>
print(getattr(myinstance, 'no_var', 'default'))  <span class="output">#default</span>
attr_name = 'myvar'
print(getattr(myinstance, attr_name))  <span class="comment"># Using a variable</span>

setattr(myinstance, 'myvar', 9)  <span class="comment"># Same as myinstance.myvar = 9</span>
print(getattr(myinstance, 'myvar'))  <span class="output">#9</span>

print(hasattr(myinstance, 'myvar'))  <span class="output">#True</span>
delattr(myinstance, 'myvar')
print(hasattr(myinstance, 'myvar'))  <span class="output">#False</span></pre>


<h4>Class Variable vs. Instance Variables</h4>

<p>Class variables are shared by all the instances, whereas instance variables are specific to that particular instance.</p>

<pre class="example">
class MyClass:
    count = 0  <span class="comment"># Total number of instances</span>
               <span class="comment"># A class variable shared by all the instances</span>

    def __init__(self):
        <span class="comment"># Update class variable</span>
        self.__class__.count += 1   <span class="comment"># Increment count</span>
                                    <span class="comment"># or MyClass.count += 1</span>
        <span class="comment"># Create instance variable: an 'id' of the instance in running numbers</span>
        self.id = self.__class__.count

    def get_id(self):
        return self.id

    def get_count(self):
        return self.__class__.count

if __name__ == '__main__':
    print(MyClass.count)                <span class="output">#0</span>
    
    myinstance1 = MyClass()
    print(MyClass.count)                <span class="output">#1</span>
    print(myinstance1.get_id())         <span class="output">#1</span>
    print(myinstance1.get_count())      <span class="output">#1</span>
    print(myinstance1.__class__.count)  <span class="output">#1</span>
    
    myinstance2 = MyClass()
    print(MyClass.count)                <span class="output">#2</span>
    print(myinstance1.get_id())         <span class="output">#1</span>
    print(myinstance1.get_count())      <span class="output">#2</span>
    print(myinstance1.__class__.count)  <span class="output">#2</span>
    print(myinstance2.get_id())         <span class="output">#2</span>
    print(myinstance2.get_count())      <span class="output">#2</span>
    print(myinstance2.__class__.count)  <span class="output">#2</span></pre>

<h5>Private Variables?</h5>

<p>Python does not support access control. In other words, all attributes are &quot;public&quot; and are accessible by ALL. There are no &quot;private&quot; attributes like C++/Java.</p>

<p>However, by convention:</p>
<ul>
<li>Names begin with an underscore <code>_</code> are meant for internal use, and are not recommended to be accessed outside the class definition.</li>
<li>Names begin with double underscores <code>__</code> and not end with double underscores are further hidden from direct access through <em>name mangling</em> (or <em>rename</em>).</li>
<li>Names begin and end with double underscores (such as <code>__init__</code>, <code>__str__</code>, <code>__add__</code>) are special <em>magic</em> methods (to be discussed later).</li>
</ul>

<p>For example,</p>

<pre class="example">
class MyClass:
    def __init__(self):
        self.myvar = 1       <span class="comment"># public</span>
        self._myvar = 2      <span class="comment"># meant for internal use (private). 'Please' don't access directly</span>
        self.__myvar = 3     <span class="comment"># name mangling</span>
        self.__myvar_ = 4    <span class="comment"># name mangling</span>
        self.__myvar__ = 5   <span class="comment"># magic attribute</span>

    def print(self):
        <span class="comment"># All variables can be used within the class definition</span>
        print(self.myvar)
        print(self._myvar)
        print(self.__myvar)
        print(self.__myvar_)
        print(self.__myvar__)

if __name__ == '__main__':
    myinstance1 = MyClass()
    print(myinstance1.myvar)
    print(myinstance1._myvar)
    <span class="comment"># Variables beginning with __ are not accessible outside the class except those ending with __</span>
    #print(myinstance1.__myvar)    <span class="error"># AttributeError</span>
    #print(myinstance1.__myvar_)   <span class="error"># AttributeError</span>
    print(myinstance1.__myvar__)

    myinstance1.print()

    print(dir(myinstance1))
    <span class="comment"># ['_MyClass__myvar', '_MyClass__myvar_', '__myvar__', '_myvar', ...]
    # Variables beginning with __ are renamed by prepending with an underscore and classname (called name mangling)</span></pre>


<h4>Class Method, Instance Method and Static Method</h4>

<h5>Class Method (Decorator <code>@classmethod</code>)</h5>

<p>A class method belongs to the class and is a function of the class. It is declared with the <code>@classmethod</code> decorator. It accepts the class as its first argument. For example,</p>

<pre class="command">
&gt;&gt;&gt; <strong>class MyClass:
        <span class="new">@classmethod</span>
        def hello(cls):
           print('Hello from', cls.__name__)</strong>
 
&gt;&gt;&gt; <strong>MyClass.hello()</strong>
Hello from MyClass

<span class="comment">% Can be invoked via an instance too</span>
&gt;&gt;&gt; <strong>myinstance1 = MyClass()</strong>
&gt;&gt;&gt; <strong>myinstance1.hello()</strong></pre>

<h5>Instance Method</h5>

<p>Instance methods are the most common type of method. An instance method is invoked by an instance object (and not a class object). It takes the instance (<code>self</code>) as its first argument.  For example,</p>

<pre class="command">
&gt;&gt;&gt; <strong>class MyClass:
        def hello(self):
            print('Hello from', self.__class__.__name__)</strong>
 
&gt;&gt;&gt; <strong>myinstance1 = MyClass()</strong>
&gt;&gt;&gt; <strong>myinstance1.hello()</strong>
Hello from MyClass
&gt;&gt;&gt; <strong>MyClass.hello()</strong>  <span class="comment"># Cannot invoke via a class object</span>
TypeError: hello() missing 1 required positional argument: 'self'

&gt;&gt;&gt; <strong>MyClass.hello(myinstance1)</strong>  <span class="comment"># But can explicitly pass an instance object</span>
Hello from MyClass</pre>

<h5>Static Method (Decorator <code>@staticmethod</code>)</h5>

<p>A static method is declared with a <code>@staticmethod</code> decorator. It &quot;doesn't know its class&quot; and is attached to the class for convenience. It does not depends on the state of the object and could be a separate function of a module. A static method can be invoked via a class object or instance object. For example,</p>

<pre class="command">
&gt;&gt;&gt; <strong>class MyClass:
        <span class="new">@staticmethod</span>
        def hello():
            print('Hello, world')</strong>
 
&gt;&gt;&gt; <strong>myinstance1 = MyClass()</strong>
&gt;&gt;&gt; <strong><strong>myinstance</strong>1.hello()</strong>
<span class="output">Hello, world</span>
&gt;&gt;&gt; <strong>MyClass.hello()</strong>  <span class="comment"># Don't need argument self</span>
<span class="output">Hello, world</span></pre>


<h4>Example 3: Getter and Setter</h4>

<p>In this example, we shall rewrite the <code>Circle</code> class to access the instance variable via the getter and setter. We shall rename the instance variable to <code>_radius</code> (meant for internal use only or private), with &quot;public&quot; getter <code>get_radius()</code> and setter <code>set_radius()</code>, as follows:</p>

<img class="image-center" src="images/Python_CircleGetterSetter.png" alt="Circle class with getter and setter" />

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""circle.py: The circle module, which defines the Circle class"""
from math import pi
 
class Circle:
    """A Circle instance models a circle with a radius"""
 
    def __init__(self, _radius = 1.0):
        """Initializer with default radius of 1.0"""
        # Change from radius to _radius (meant for internal use)
        # You should access through the getter and setter.
        self.set_radius(_radius)   # Call setter
 
    def set_radius(self, _radius):
        """Setter for instance variable radius with input validation"""
        if _radius &lt; 0:
            raise ValueError('Radius shall be non-negative')
        self._radius = _radius
 
    def get_radius(self):
        """Getter for instance variable radius"""
        return self._radius
 
    def get_area(self):
        """Return the area of this Circle instance"""
        return self.get_radius() * self.get_radius() * pi  # Call getter
 
    def __repr__(self):
        """Return a command string to recreate this instance"""
        # Used by str() too as __str__() is not defined
        return 'Circle(radius={})'.format(self.get_radius())  # Call getter
 
if __name__ == '__main__':
    c1 = Circle(1.2)        # Constructor and Initializer
    print(c1)               # Invoke __repr__(). Output: Circle(radius=1.200000)
    print(vars(c1))         # Output: {'_radius': 1.2}
    print(c1.get_area())    # Output: 4.52389342117
    print(c1.get_radius())  # Run Getter. Output: 1.2
    c1.set_radius(3.4)      # Test Setter
    print(c1)               # Output: Circle(radius=3.400000)
    c1._radius = 5.6        # Access instance variable directly (NOT recommended but permitted)
    print(c1)               # Output: Circle(radius=5.600000)
 
    c2 = Circle()  # Default radius
    print(c2)      # Output: Circle(radius=1.000000)
 
    c3 = Circle(-5.6)  # ValueError: Radius shall be non-negative</code></pre>
        
<h5>How It Works?</h5>

<ol>
<li>While there is no concept of &quot;private&quot; attributes in Python, we could still rewrite our <code>Circle</code> class with &quot;public&quot; getter/setter, as in the above example. This is often done because the getter and setter need to carry out certain processing, such as data conversion in getter, or input validation in setter.</li>

<li>We renamed the instance variable <code>_radius</code> (Line 9), with a leading underscore to denote it &quot;private&quot; (but it is still accessible to all). According to Python naming convention, names beginning with a underscore are to be treated as &quot;private&quot;, i.e., it shall not be used outside the class. We named our &quot;public&quot; getter and setter <code>get_radius()</code> and <code>set_radius()</code>, respectively.</li>

<li>In the constructor, we invoke the setter to set the instance variable (Line 13), instead of assign directly, as the setter may perform tasks like input validation. Similarly, we use the getter in <code>get_area()</code> (Line 27) and <code>__repr__()</code> (Line 32).</li>
</ol>

<h4>Example 4: Creating a <code>property</code> object via the <code>property()</code> Built-in Function</h4>

<p>Add the following into the <code>Circle</code> class in the previous example:</p>

<pre class="example">
class Circle:
    ......
    <span class="comment"># Add a new property object called radius, given its getter and setter
    # Place this line after get_radius() and set_radius()</span>
    radius = property(get_radius, set_radius)</pre>

<p>This creates a new <code>property</code> object (instance variable) called <code>radius</code>, with the given getter/setter (which operates on the existing instance variable <code>_radius</code>). Recall that we have renamed our instance variable to <code>_radius</code>, so they do not crash.</p>

<p>You can now use this new property <code>radius</code>, just like an ordinary instance variable, e.g.,</p>

<pre class="example">
c1 = Circle(1.2)

<span class="comment"># Access (read/write) the new property radius directly</span>
print(c1.radius)    <span class="comment"># Run get_radius() to read _radius</span>
                    <span class="output">#1.2</span>
c1.radius = 3.4     <span class="comment"># Run set_radius() to change _radius</span>
print(c1.radius)    <span class="comment"># Run get_radius() to read _radius</span>
                    <span class="output">#3.4</span>
print(vars(c1))     <span class="output">#{'_radius': 3.4}</span>
print(dir(c1))      <span class="output">#['_radius', 'get_radius', 'radius', 'set_radius', ...]</span>

<span class="comment"># The existing instance variable _radius, getter and setter are still available</span>
c1._radius = 5.6
print(c1._radius)       <span class="output">#5.6</span>
c1.set_radius(7.8)
print(c1.get_radius())  <span class="output">#7.8</span>

print(type(c1.radius))       <span class="output">#&lt;class 'float'&gt;</span>
print(type(c1._radius))      <span class="output">#&lt;class 'float'&gt;</span>
print(type(Circle.radius))   <span class="output">#&lt;class 'property'&gt;</span>
print(type(Circle._radius))  <span class="error">#AttributeError: type object 'Circle' has no attribute '_radius'</span></pre>

<p>The built-in function <code>property()</code> has the following signature:</p>

<pre class="syntax">
property(fn_get=None, fn_set=None, fn_del=None, doc=None)</pre>

<p>You can specify a delete function, as well as a doc-string. For example,</p>

<pre class="example">
class Circle:
    ......
   
    def del_radius(self):
        del self._radius
      
    radius = property(get_radius, set_radius, del_radius, "Radius of this circle")</pre>

<h5>More on <code>property</code> object</h5>
<p>[TODO]</p>

<h4>Example 5: Creating a property via the <code>@property</code> Decorator</h4>

<p>In the above example, the statement:</p>

<pre class="example">
radius = property(get_radius, set_radius, del_radius)</pre>

<p>is equivalent to:</p>

<pre class="example">
<span class="comment"># Create an empty property, getter, setter and deleter set to None</span>
radius = property()
<span class="comment"># Assign getter, setter and deleter functions</span>
radius.getter(self.get_radius)
radius.setter(self.set_radius)
radius.deleter(self.del_radius)</pre>

<p>These can be implemented via decorators <code>@property</code>, <code>@<em>varname</em>.setter</code> and <code>@<em>varname</em>.deleter</code>, respectively. For example,</p>

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""circle.py: The circle module, which defines the Circle class"""
from math import pi
 
class Circle:
    """A Circle instance models a circle with a radius"""
 
    def __init__(self, radius = 1.0):
        """Initializer with default radius of 1.0"""
        self.radius = radius   # Call decorated setter
 
    @property
    def radius(self):
        """Radius of this circle"""  # doc-string here
        # Define getter here
        return self._radius  # Read the hidden instance variable _radius
    # Equivalent to:
    # def get_radius(self):
    #    return self._radius
    # radius = property(get_radius)   # Define a property with getter
 
    @radius.setter
    def radius(self, radius):
        """Setter for instance variable radius with input validation"""
        if radius &lt; 0:
           raise ValueError('Radius shall be non-negative')
        self._radius = radius  # Set a hidden instance variable _radius
 
    @radius.deleter
    def radius(self):
        """Deleter for instance variable radius"""
        del self._radius  # Delete the hidden instance variable _radius
 
    def get_area(self):
        """Return the area of this Circle instance"""
        return self.radius * self.radius * pi  # Call decorated getter
 
    def __repr__(self):
        """Self description for this Circle instance, used by print(), str() and repr()"""
        return 'Circle(radius={})'.format(self.radius)  # Call decorated getter
 
if __name__ == '__main__':
    c1 = Circle(1.2)
    print(c1)               # Output: Circle(radius=1.200000)
    print(vars(c1))         # Output: {'_radius': 1.2}
    print(dir(c1))          # Output: ['_radius', 'radius', ...]]
    c1.radius = 3.4         # Setter
    print(c1.radius)        # Getter. Output: 3.4
    print(c1._radius)       # hidden instance variable. Output: 3.4
    #print(c1.get_radius()) # AttributeError: 'Circle' object has no attribute 'get_radius'
 
    c2 = Circle()         # Default radius
    print(c2)             # Output: Circle(radius=1.000000)
 
    c3 = Circle(-5.6)     # ValueError: Radius shall be non-negative</code></pre>

<h5>How It Works?</h5>

<ol>

<li>We use a hidden instance variable called <code>_radius</code> to store the radius, which is set in the setter, after input validation.</li>

<li>We renamed the getter from <code>get_radius()</code> to <code>radius</code>, and used the decorator <code>@property</code> to decorate the getter.</li>

<li>We also renamed the setter from <code>set_radius()</code> to <code>radius</code>, and use the decorator <code>@radius.setter</code> to decorate the setter.</li>

<li>[TODO] more</li>
</ol>

<h3 id="inheritance">Inheritance and Polymorphism</h3>

<h4>Example 6: The <code>Cylinder</code> class as a subclass of <code>Circle</code> class</h4>

<p>In this example, we shall define a <code>Cylinder</code> class, as a subclass of <code>Circle</code>. The <code>Cylinder</code> class shall inherit attributes <code>radius</code> and <code>get_area()</code> from the superclass <code>Circle</code>, and add its own attributes <code>height</code> and <code>get_volume()</code>.</p>

<img class="image-center" src="images/Python_CylinderCircle.png" alt="Cylinder and Circle classes" />

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""cylinder.py: The cylinder module, which defines the Cylinder class"""
from circle import Circle  # Using the Circle class in the circle module
 
class Cylinder(Circle):
    """The Cylinder class is a subclass of Circle"""
 
    def __init__(self, radius = 1.0, height = 1.0):
        """Initializer"""
        super().__init__(radius)  # Invoke superclass' initializer (Python 3)
            # OR
            # super(Cylinder, self).__init__(radius)   (Python 2)
            # Circle.__init__(self, radius)            Explicit superclass class
        self.height = height
 
    def __str__(self):
        """Self Description for print() and str()"""
        # If __str__ is missing in the subclass, print() will invoke the superclass version!
        return 'Cylinder(radius={},height={})'.format(self.radius, self.height)

    def __repr__(self):
        """Formal Description for repr()"""
        # If __repr__ is missing in the subclass, repr() will invoke the superclass version!
        return self.__str__()   # re-direct to __str__() (not recommended)
 
    def get_volume(self):
        """Return the volume of the cylinder"""
        return self.get_area() * self.height  # Inherited get_area()
 
# For testing
if __name__ == '__main__':
    cy1 = Cylinder(1.1, 2.2)  # Output: Cylinder(radius=1.10,height=2.20)
    print(cy1)                # Invoke __str__()
    print(cy1.get_area())     # Use inherited superclass' method
    print(cy1.get_volume())   # Invoke its method
    print(cy1.radius)
    print(cy1.height)
    print(str(cy1))           # Invoke __str__()
    print(repr(cy1))          # Invoke __repr__()
 
    cy2 = Cylinder()          # Default radius and height
    print(cy2)                # Output: Cylinder(radius=1.00,height=1.00)
    print(cy2.get_area())
    print(cy2.get_volume())
 
    print(dir(cy1))
        # ['get_area', 'get_volume', 'height', 'radius', ...]
    print(Cylinder.get_area)
        # &lt;function Circle.get_area at 0x7f490436b378&gt;
        # Inherited from the superclass
    print(Circle.get_area)
        # &lt;function Circle.get_area at 0x7f490436b378&gt;
 
    print(issubclass(Cylinder, Circle))  # True
    print(issubclass(Circle, Cylinder))  # False
    print(isinstance(cy1, Cylinder))     # True
    print(isinstance(cy1, Circle))       # True (A subclass object is also a superclass object)
    print(Cylinder.__base__)             # Show superclass: &lt;class 'circle.Circle'&gt;
    print(Circle.__subclasses__())       # Show a list of subclasses: [&lt;class '__main__.Cylinder'&gt;]
 
    c1 = Circle(3.3)
    print(c1)                        # Output: This is a circle with radius of 3.30
    print(isinstance(c1, Circle))    # True
    print(isinstance(c1, Cylinder))  # False (A superclass object is NOT a subclass object)</code></pre>

<h5>How It Works?</h5>

<ol>
<li>When you construct a new instance of <code>Cylinder</code> via:
<pre class="example">
cy1 = Cylinder(1.1, 2.2)</pre>
Python first creates a plain <code>Cylinder</code> object and invokes the <code>Cylinder</code>'s <code>__init__()</code> with <code>self</code> binds to  the newly created <code>cy1</code>, as follows:
<pre class="example">
Cylinder.__init__(cy1, 1.1, 2.2)</pre>
Inside the <code>__init__()</code>, the <code>super().__init__(radius)</code> invokes the superclass' <code>__init__()</code>. (You can also explicitly call <code>Circle.__init__(self, radius)</code> but you need to hardcode the superclass' name.) This creates a superclass instance with <code>radius</code>. The next statement <code>self.height = height</code> creates the instance variable <code>height</code> for <code>cy1</code>.
<br>Take note that Python does not call the superclass' constructor automatically (unlike Java/C++).</li>

<li>If <code>__str__()</code> or <code>__repr__()</code> is missing in the subclass, <code>str()</code> and <code>repr()</code> will invoke the superclass version. Try commenting out <code>__str__()</code> and <code>__repr__()</code> and check the results.</li>
</ol>


<h5><code>super()</code></h5>

<p>There are two ways to invoke a superclass method:</p>

<ol>
<li>via explicit classname: e.g.,
<pre class="example">
Circle.__init__(self)
Circle.get_area(self)</pre></li>

<li>via <code>super()</code>: e.g.,
<pre class="example">
super().__init__(radius)                <span class="comment"># Python 3</span>
super(Cylinder, self).__init__(radius)  <span class="comment"># Python 2: super(this_class_name, self)</span>

super().get_area()                <span class="comment"># Python 3</span>
super(Cylinder, self).get_area()  <span class="comment"># Python 2</span></pre>

</li>
</ol>
<p>You can avoid hard-coding the superclass' name with <code>super()</code>. This is recommended, especially in multiple inheritance as it can resolve some conflicts (to be discussed later).</p>

<p>The <code>super()</code> method returns a proxy object that delegates method calls to a parent or sibling class. This is useful for accessing inherited methods that have been overridden in a class.</p>

    
<h4>Example 7: Method Overriding</h4>

<p>In this example, we shall override the <code>get_area()</code> method to return the surface area of the cylinder. We also rewrite the <code>__str__()</code> method, which also overrides the inherited method.  We need to rewrite the <code>get_volume()</code> to use the superclass' <code>get_area()</code>, instead of this class.</p>

<img class="image-center" src="images/Python_CylinderCircleOverride.png" alt="Cylinder Override" />

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""cylinder.py: The cylinder module, which defines the Cylinder class"""
from math import pi
from circle import Circle  # Using the Circle class in the circle module
 
class Cylinder(Circle):
    """The Cylinder class is a subclass of Circle"""
 
    def __init__(self, radius = 1.0, height = 1.0):
        """Initializer"""
        super().__init__(radius)  # Invoke superclass' initializer
        self.height = height
 
    def __str__(self):
        """Self Description for print() and str()"""
        return 'Cylinder({}, height={})'.format(super().__repr__(), self.height)
                # Use superclass' __repr__()
 
    def __repr__(self):
        """Formal Description for repr()"""
        return self.__str__()   # re-direct to __str__() (not recommended)
 
    # Override
    def get_area(self):
        """Return the surface area the cylinder"""
        return 2.0 * pi * self.radius * self.height
 
    def get_volume(self):
        """Return the volume of the cylinder"""
        return super().get_area() * self.height  # Use superclass' get_area()
 
# For testing
if __name__ == '__main__':
    cy1 = Cylinder(1.1, 2.2)
    print(cy1)              # Invoke __str__(): Cylinder(Circle(radius=1.1), height=2.2)
    print(cy1.get_area())   # Invoke overridden version
    print(cy1.get_volume()) # Invoke its method
    print(cy1.radius)
    print(cy1.height)
    print(str(cy1))         # Invoke __str__()
    print(repr(cy1))        # Invoke __repr__()
 
    cy2 = Cylinder()        # Default radius and height
    print(cy2)              # Invoke __str__(): Cylinder(Circle(radius=1.0), height=1.0)
    print(cy2.get_area())
    print(cy2.get_volume())
 
    print(dir(cy1))
        # ['get_area', 'get_volume', 'height', 'radius', ...]
    print(Cylinder.get_area)
        # &lt;function Cylinder.get_area at 0x7f505f464488&gt;
    print(Circle.get_area)
        # &lt;function Circle.get_area at 0x7f490436b378&gt;</code></pre>


<ol>
<li>In Python, the overridden version replaces the inherited version, as shown in the above function references.</li>

<li>To access superclass' version of a method, use:
<ul>
<li>For Python 3: <code>super().<em>method_name</em>(*<em>args</em>)</code>, e.g., <code>super().get_area()</code></li>
<li>For Python 2: <code>super(<em>this_class</em>, self).<em>method_name</em>(*<em>args</em>)</code>, e.g., <code>super(Cylinder, self).get_area()</code></li>
<li>Explicitly via the class name: <code><em>superclass</em>.<em>method-name</em>(self, *<em>args</em>)</code>, e.g., <code>Circle.get_area(self)</code></li>
</ul>
</li>
</ol>

<h4>Example 8: <code>Shape</code> and its subclasses</h4>

<img class="image-center" src="images/Python_ShapeAndSubclasses.png" alt="Shape and subclasses" />

<pre><code class="language-python line-numbers">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
"""sh.py: The sh module. It contains a superclass Shape and 3 subclasses Circle, Rectangle and Square"""
from math import pi
 
class Shape:
    """The superclass Shape with a color"""
    def __init__(self, color = 'red'):
        """Initializer"""
        self.color = color
 
    def __str__(self):
        """Self description for print() and str()"""
        return 'Shape(color={})'.format(self.color)
 
    def __repr__(self):
        """Representative description for repr()"""
        return self.__str__()  # re-direct to __str__() (not recommended)
 
class Circle(Shape):
    """The Circle class: a subclass of Shape with a radius"""
    def __init__(self, radius = 1.0, color = 'red'):
        """Initializer"""
        super().__init__(color)  # Call superclass' initializer
        self.radius = radius
 
    def __str__(self):
        """Self description for print() and str()"""
        return 'Circle({}, radius={})'.format(super().__str__(), self.radius)
 
    def __repr__(self):
        """Representative description for repr()"""
        return self.__str__()  # re-direct to __str__() (not recommended)
 
    def get_area(self):
        return self.radius * self.radius * pi
 
class Rectangle(Shape):
    """The Rectangle class: a subclass of Shape wit a length and width"""
    def __init__(self, length = 1.0, width = 1.0, color = 'red'):
        """Initializer"""
        super().__init__(color)
        self.length = length
        self.width = width
 
    def __str__(self):
        """Self description for print() and str()"""
        return 'Rectangle({}, length={}, width={})'.format(super().__str__(), self.length, self.width)
 
    def __repr__(self):
        """Representative description for repr()"""
        return self.__str__()  # re-direct to __str__() (not recommended)
 
    def get_area(self):
        return self.length * self.width
 
class Square(Rectangle):
    """The Square class: a subclass of Rectangle having the same length and width"""
    def __init__(self, side = 1.0, color = 'red'):
        """Initializer"""
        super().__init__(side, side, color)
 
    def __str__(self):
        """Self description for print() and str()"""
        return 'Square({})'.format(super().__str__())
 
# For Testing
if __name__ == '__main__':
    s1 = Shape('orange')
    print(s1)                # Shape(color=orange)
    print(s1.color)          # orange
    print(str(s1))           # Shape(color=orange)
    print(repr(s1))          # Shape(color=orange)
 
    c1 = Circle(1.2, 'orange')
    print(c1)                # Circle(Shape(color=orange), radius=1.2)
    print(c1.get_area())     # 4.523893421169302
    print(c1.color)          # orange
    print(c1.radius)         # 1.2
    print(str(c1))           # Circle(Shape(color=orange), radius=1.2)
    print(repr(c1))          # Circle(Shape(color=orange), radius=1.2)
 
    r1 = Rectangle(1.2, 3.4, 'orange')
    print(r1)                # Rectangle(Shape(color=orange), length=1.2, width=3.4)
    print(r1.get_area())     # 4.08
    print(r1.color)          # orange
    print(r1.length)         # 1.2
    print(r1.width)          # 3.4
    print(str(r1))           # Rectangle(Shape(color=orange), length=1.2, width=3.4)
    print(repr(r1))          # Rectangle(Shape(color=orange), length=1.2, width=3.4)
 
    sq1 = Square(5.6, 'orange')
    print(sq1)               # Square(Rectangle(Shape(color=orange), length=5.6, width=5.6))
    print(sq1.get_area())    # 31.359999999999996
    print(sq1.color)         # orange
    print(sq1.length)        # 5.6
    print(sq1.width)         # 5.6
    print(str(sq1))          # Square(Rectangle(Shape(color=orange), length=5.6, width=5.6))
    print(repr(sq1))         # Square(Rectangle(Shape(color=orange), length=5.6, width=5.6))</code></pre>


<h4>Multiple Inheritance</h4>

<p>Python supports multiple inheritance, which is defined in the form of &quot;<code>class <em>class_name</em>(<em>base_class_</em>1, <em>base_class_</em>2,...):</code>&quot;.</p>


<h5>Mixin Pattern</h5>

<p>The simplest and most useful pattern of multiple inheritance is called mixin. A mixin is a superclass that is not meant to exist on its own, but meant to be inherited by some sub-classes to provide extra functionality.</p>

<p>[TODO]</p>

<h5>Diamond Problem</h5>

<p>Suppose that two classes <code>B</code> and <code>C</code> inherit from a superclass <code>A</code>, and <code>D</code> inherits from both <code>B</code> and <code>C</code>. If <code>A</code> has a method called <code>m()</code>, and <code>m()</code> is overridden by <code>B</code> and/or <code>C</code>, then which version of <code>m()</code> is inherited by <code>D</code>?</p>

<img class="image-center" src="images/Python_DiamondProblem.png" alt="Diamond problem" />

<p>Let's look at Python's implementation.</p>

<h5>Example 1</h5>

<pre class="example">
class A:
    def m(self):
        print('in Class A')

class B(A):
    def m(self):
        print('in Class B')
    
class C(A):
    def m(self):
        print('in Class C')

<span class="comment"># Inherits from B, then C. It does not override m()</span>
class D1(B, C):  
    pass

<span class="comment"># Different order of subclass list</span>
class D2(C, B):
    pass

<span class="comment"># Override m()</span>
class D3(B, C):
    def m(self):
        print('in Class D3')

if __name__ == '__main__':
    x = D1()
    x.m()   <span class="comment"># 'in Class B' (first in subclass list)</span>

    x = D2()
    x.m()   <span class="comment"># 'in Class C' (first in subclass list)</span>
    
    x = D3()
    x.m()   <span class="comment"># 'in Class D3' (overridden version)</span></pre>

<h5>Example 2</h5>
<p>Suppose the overridden <code>m()</code> in <code>B</code> and <code>C</code> invoke <code>A</code>'s <code>m()</code> explicitly.</p>

<pre class="example">
class A:
    def m(self):
        print('in Class A')

class B(A):
    def m(self):
        A.m(self)
        print('in Class B')
    
class C(A):
    def m(self):
        A.m(self)
        print('in Class C')

class D(B, C):
    def m(self):
        B.m(self)
        C.m(self)
        print('in Class D')

if __name__ == '__main__':
    x = D()
    x.m()</pre>

<p>The output is:</p>

<pre class="output">
in Class A
in Class B
in Class A
in Class C
in Class D</pre>

<p>Take note that <code>A</code>'s <code>m()</code> is run twice, which is typically not desired. For example, suppose that <code>m()</code> is the <code>__init__()</code>, then <code>A</code> will be initialized twice.</p>

<h5>Example 3: Using <code>super()</code></h5>

<pre class="example">
class A:
    def m(self):
        print('in Class A')

class B(A):
    def m(self):
        super().m()
        print('in Class B')
    
class C(A):
    def m(self):
        super().m()
        print('in Class C')

class D(B, C):
    def m(self):
        super().m()
        print('in Class D')

if __name__ == '__main__':
    x = D()
    x.m()</pre>

<pre class="output">
in Class A
in Class C
in Class B
in Class D</pre>

<p>With <code>super()</code>, <code>A</code>'s <code>m()</code> is only run once.  This is because <code>super()</code> uses the so-called Method Resolution Order (MRO) to <em>linearize</em> the superclass.  Hence, <code>super()</code> is strongly recommended for multiple inheritance, instead of explicit class call.</p>

<h5>Example 4: Let's look at <code>__init__()</code></h5>

<pre class="example">
class A:
    def __init__(self):
        print('init A')
    
class B(A):
    def __init__(self):
        super().__init__()
        print('init B')
    
class C(A):
    def __init__(self):
        super().__init__()
        print('init C')

class D(B, C):
    def __init__(self):
        super().__init__()
        print('init D')

if __name__ == '__main__':
    d = D()
    <span class="comment"># init A
    # init C
    # init B
    # init D</span>
    
    c = C()
    <span class="comment"># init A
    # init C</span>
    
    b = B()
    <span class="comment"># init A
    # init B</span></pre>
    
<p>Each superclass is initialized exactly once, as desired.</p>

<p>You can check the MRO via the <code>mro()</code> member method:</p>

<pre class="example">
&gt;&gt;&gt; <strong>D.mro()</strong>
[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]
&gt;&gt;&gt; <strong>C.mro()</strong>
[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]
&gt;&gt;&gt; <strong>B.mro()</strong>
[&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</pre>

<h4>Abstract Methods</h4>

<p>An abstract method has no implementation, and therefore cannot be called. The subclasses shall override the abstract methods inherited and provides their own implementations.</p>

<p>In Python 3, you can use decorator <code>@abstractmethod</code> to mark an abstract method. For example,</p>

<pre class="example">
<span class="new">@abstractmethod</span>
def method_name(self, ...):
    pass</pre>

<p>[TODO] more</p>

<h4>Polymorphism</h4>

<p>Polymorphism in OOP is the ability to present the same interface for differing underlying implementations. For example, a polymorphic function can be applied to arguments of different types, and it behaves differently depending on the type of the arguments to which they are applied.</p>

<p>Python is implicitly polymorphic, as type are associated with objects instead of variable references.</p>
<p>[TODO] more</p>

<h3 id="advanced">Advanced OOP in Python</h3>

<h4 id="magicMethod">Magic Methods</h4>

<p>A <em>magic method</em> is an object's member methods that begins and ends with double underscore, e.g., <code>__init__()</code>, <code>__str__()</code>, <code>__repr__()</code>, <code>__add__()</code>, <code>__len__()</code>.</p>

<p>As an example, we list the magic methods in the <code>int</code> class:</p>
<pre class="example">
&gt;&gt;&gt; <strong>dir(int)</strong>
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', ...]</pre>

<p>In Python, <strong>built-in operators and functions invoke the corresponding magic methods</strong>. For example, operator <code>'+'</code> invokes <code>__add__()</code>, built-in function <code>len()</code> invokes <code>__len__()</code>. Even though the magic methods are invoked <em>implicitly</em> via built-in operators and functions, you can also call them explicitly, e.g., <code>'abc'.__len__()</code> is the same as <code>len('abc')</code>.</p>

<p>The following table summarizes the commonly-used magic methods and their invocation.</p>

<table class="table-zebra" style="width:90%">
  <tr>
    <th>Magic Method</th>
    <th>Invoked Via</th>
    <th>Invocation Syntax</th>
  </tr>
  <tr>
    <td><code>__lt__(self, right)<br>__gt__(self, right)<br>__le__(self, right)<br>__ge__(self, right)<br>__eq__(self, right)<br>__ne__(self, right)</code></td>
    <td>Comparison Operators</td>
    <td><code>self &lt; right<br>self &gt; right<br>self &lt;= right<br>self &gt;= right<br>self == right<br>self != right</code></td>
  </tr>
  
  <tr>
    <td><code>__add__(self, right)<br>__sub__(self, right)<br>__mul__(self, right)<br>__truediv__(self, right)<br>__floordiv__(self, right)<br>__mod__(self, right)<br>__pow__(self, right)</code></td>
    <td>Arithmetic Operators</td>
    <td><code>self + right<br>self - right<br>self * right<br>self / right<br>self // right<br>self % right<br>self ** right</code></td>
  </tr>

  <tr>
    <td><code>__and__(self, right)<br>__or__(self, right)<br>__xor__(self, right)<br>__invert__(self)<br>__lshift__(self, n)<br>__rshift__(self, n)</code></td>
    <td>Bitwise Operators</td>
    <td><code>self &amp; right<br>self | right<br>self ^ right<br>~self<br>self &lt;&lt; n<br>self &gt;&gt; n</code></td>
  </tr>
  
  <tr>
    <td><code>__str__(self)<br>__repr__(self)<br>__sizeof__(self)</code></td>
    <td>Built-in Function Call</td>
    <td><code>str(self), print(self)<br>repr(self)<br>sizeof(self)</code></td>
  </tr>
  
  <tr>
    <td><code>__len__(self)<br>__contains__(self, item)<br>__iter__(self)<br>__next__(self)<br>__getitem__(self, key)<br>__setitem__(self, key, value)<br>__delitem__(self, key)</code></td>
    <td>Sequence Operators &amp; Built-in Functions</td>
    <td><code>len(self)<br>item in self<br>iter(self)<br>next(self)<br>self[key]<br>self[key] = value<br>del self[key]</code></td>
  </tr>

  <tr>
    <td><code>__int__(self)<br>__float__(self)<br>__bool__(self)<br>__oct__(self)<br>__hex__(self)</code></td>
    <td>Type Conversion Built-in Function Call</td>
    <td><code>int(self)<br>float(self)<br>bool(self)<br>oct(self)<br>hex(self)</code></td>
  </tr>
  
  <tr>
    <td><code>__init__(self, *args)<br>__new__(cls, *args)</code></td>
    <td>Constructor / Initializer</td>
    <td><code>x = ClassName(*args)</code></td>
  </tr>

  <tr>
    <td><code>__del__(self)</code></td>
    <td>Operator <code>del</code></td>
    <td><code>del x</code></td>
  </tr>

  <tr>
    <td><code>__index__(self)</code></td>
  <td>Convert this object to an index</td>
    <td><code>x[self]</code></td>
  </tr>

  <tr>
    <td><code>__radd__(self, left)<br>
__rsub__(self, left)<br>
...</code></td>
  <td>RHS (Reflected) addition, subtraction, etc.</td>
    <td><code>left + self<br>
left - self<br>
...</code></td>
  </tr>

<tr>
    <td><code>__iadd__(self, right)<br>
__isub__(self, right)<br>
...</code></td>
    <td>In-place addition, subtraction, etc</td>
    <td><code>self += right<br>
self -= right<br>
...</code></td>
  </tr>

  <tr>
    <td><code>__pos__(self)<br>
__neg__(self)</code></td>
    <td>Unary Positive and Negate operators</td>
    <td><code>+self<br>
-self</code></td>
  </tr>

  <tr>
    <td><code>__round__(self)<br>
__floor__(self)<br>
__ceil__(self)<br>
__trunc__(self)</code></td>
    <td>Function Call</td>
    <td><code>round(self)<br>
floor(self)<br>
ceil(self)<br>
trunc(self)</code></td>
  </tr>

  <tr>
    <td><code>__getattr__(self, name)<br>
__setattr__(self, name, value)<br>
__delattr__(self, name)</code></td>
    <td>Object's attributes</td>
    <td><code>self.name<br>
self.name = value<br>
del self.name</code></td>
  </tr>

  <tr>
    <td><code>__call__(self, *args, **kwargs)</code></td>
    <td>Callable Object</td>
    <td><code>obj(*args, **kwargs);</code></td>
  </tr>

  <tr>
    <td><code>__enter__(self), __exit__(self)</code></td>
    <td>Context Manager <code>with</code>-statement</td>
    <td>&nbsp;</td>
  </tr>
</table>

<h4>Construction and Initialization</h4>

<p>When you use <code>x = ClassName(*args)</code> to construct an instance of <code>x</code>, Python first calls <code>__new__(cls, *args)</code> to create an instance, it then invokes <code>__init__(self, *args)</code> (the initializer) to initialize the instance.</p>

<h4>Operator Overloading</h4>

<p>Python supports <em>operators overloading</em> (like C++) via overriding the corresponding magic functions.</p>

<h5>Example</h5>
<p>To Override the <code>'=='</code> operator for the <code>Circle</code> class:</p>

<pre class="example">
class <strong>Circle</strong>:
    def __init__(self, radius):
        <span class="comment">&quot;&quot;&quot;Initializer&quot;&quot;&quot;</span>
        self.radius = radius

    def __eq__(self, right):
        <span class="comment">&quot;&quot;&quot;Override operator '==' to compare the two radius&quot;&quot;&quot;</span>
        if self.__class__.__name__ == right.__class__.__name__:  <span class="comment"># Check class type</span>
            return self.radius == right.radius   <span class="comment"># Compare radius</span>
        raise TypeError(&quot;not a 'Circle' object&quot;)

if __name__ == '__main__':
    print(Circle(8) == Circle(8))   <span class="comment"># True</span>
    print(Circle(8) == Circle(88))  <span class="comment"># False</span>
    print(Circle(8) == 'abc')       <span class="comment"># TypeError</span></pre>

<p>[TODO] more examples</p>


<h4>Iterable and Iterator: <code>iter()</code> and <code>next()</code></h4>

<p>Python iterators are supported by two magic member methods: <code>__iter__(self)</code> and <code>__next__(self)</code>.</p>
<ul>
<li>The Iterable object (such as list) shall implement the <code>__iter__(self)</code> member method to return an iterator object. This method can be invoked explicitly via &quot;<code>iterable.__iter__()</code>&quot;, or implicitly via &quot;<code>iter(iterable)</code>&quot; or &quot;<code>for item in iterable</code>&quot; loop.</li>

<li>The returned iterator object shall implement the <code>__next__(self)</code> method to return the next item, or raise <code>StopIeration</code> if there is no more item. This method can be invoked explicitly via &quot;<code>iterator.__next__()</code>&quot;, or implicitly via &quot;<code>next(iterator)</code>&quot; or within the &quot;<code>for item in iterable</code>&quot; loop.</li>
</ul>

<h5>Example 1:</h5>
<p>A <code>list</code> is an <code>iterable</code> that supports <code>iterator</code>.</p>

<pre class="example">
<span class="comment"># Using iter() and next() built-in functions</span>
&gt;&gt;&gt; <strong>lst_itr = iter([11, 22, 33])</strong>  <span class="comment"># Get an iterator from a list</span>
&gt;&gt;&gt; <strong>lst_itr</strong>
&lt;list_iterator object at 0x7f945e438550&gt;
&gt;&gt;&gt; <strong>next(lst_itr)</strong>
11
&gt;&gt;&gt; <strong>next(lst_itr)</strong>
22
&gt;&gt;&gt; <strong>next(lst_itr)</strong>
33
&gt;&gt;&gt; <strong>next(lst_itr)</strong>  <span class="comment"># No more item, raise StopIteration</span>
...... 
StopIteration

<span class="comment"># Using __iter__() and __next__() member methods</span>
&gt;&gt;&gt; <strong>lst_itr2 = [44, 55].__iter__()</strong>
&gt;&gt;&gt; <strong>lst_itr2</strong>
&lt;list_iterator object at 0x7f945e4385f8&gt;
&gt;&gt;&gt; <strong>lst_itr2.__next__()</strong>
44
&gt;&gt;&gt; <strong>lst_itr2.__next__()</strong>
55
&gt;&gt;&gt; <strong>lst_itr2.__next__()</strong>
StopIteration

<span class="comment"># The &quot;for each in iterable&quot; loop uses iterator implicitly</span>
&gt;&gt;&gt; <strong>for item in [11, 22, 33]: 
        print(item)</strong></pre>

<h5>Example 2:</h5>

<p>Let's implement our own iterator.  The following <code>RangeDown(min, max)</code> is similar to <code>range(min, max + 1)</code>, but counting down. In this example, the iterable and iterator are in the same class.</p>

<pre class="example">
class <strong>RangeDown</strong>:
    <span class="comment">&quot;&quot;&quot;Iterator from max down to min (both inclusive)&quot;&quot;&quot;</span>

    def __init__(self, min, max):
        self.current = max + 1
        self.min = min

    def __iter__(self):
        return self

    def __next__(self):
        self.current -= 1
        if self.current &lt; self.min:
            raise StopIteration
        else:
            return self.current
          
if __name__ == '__main__':
    <span class="comment"># Use iter() and next()</span>
    itr = iter(RangeDown(6, 8))
    print(next(itr))   <span class="comment"># 8</span>
    print(next(itr))   <span class="comment"># 7</span>
    print(next(itr))   <span class="comment"># 6</span>
    #print(next(itr))  <span class="comment"># StopIteration</span>

    <span class="comment"># Iterate in for-in loop</span>
    for i in RangeDown(6, 8):
        print(i, end=" ")  <span class="comment"># 8 7 6</span>
    print()

    <span class="comment"># Use __iter__() and __next__()</span>
    itr2 = RangeDown(9, 10).__iter__()
    print(itr2.__next__())  <span class="comment"># 10</span>
    print(itr2.__next__())  <span class="comment"># 9</span>
    print(itr2.__next__())  <span class="comment"># StopIteration</span></pre>


<h5>Example 3:</h5>

<p>Let's separate the <code>iterable</code> and <code>iterator</code> in two classes.</p>

<pre class="example">
class <strong>RangeDown</strong>:
    <span class="comment">&quot;&quot;&quot;Iterable from max down to min (both inclusive)&quot;&quot;&quot;</span>
    def __init__(self, min, max):
        self.min = min
        self.max = max

    def __iter__(self):
        return RangeDownIterator(self.min, self.max)

class <strong>RangeDownIterator</strong>:
    def __init__(self, min, max):
        self.min = min
        self.current = max + 1

    def __next__(self):
        self.current -= 1
        if self.current &lt; self.min:
            raise StopIteration
        else:
            return self.current
    
if __name__ == '__main__':
    itr = iter(RangeDown(6, 8))
    print(next(itr))   <span class="comment"># 8</span>
    print(next(itr))   <span class="comment"># 7</span>
    print(next(itr))   <span class="comment"># 6</span>
    #print(next(itr))  <span class="comment"># StopIteration</span></pre>


<h4>Generator and <code>yield</code></h4>

<p>A generator function is a function that can produce a sequence of results instead of a single value.  A generator function returns a generator iterator object, which is a special type of iterator where you can obtain the next elements via <code>next()</code>.</p>

<p>A generator function is like an ordinary function, but instead of using <code>return</code> to return a value and exit, it uses <code>yield</code> to produce a new result. A function which contains <code>yield</code> is automatically a generator function.</p>

<p>Generators are useful to create iterators.</p>

<h5>Example 1: A Simple Generator</h5>

<pre class="example">
&gt;&gt;&gt; <strong>def my_simple_generator():
        yield(11)
        yield(22)
        yield(33)</strong>
   
&gt;&gt;&gt; <strong>g1 = my_simple_generator()</strong>
&gt;&gt;&gt; <strong>g1</strong>
&lt;generator object my_simple_generator at 0x7f945e441990&gt;
&gt;&gt;&gt; <strong>next(g1)</strong>
11
&gt;&gt;&gt; <strong>next(g1)</strong>
22
&gt;&gt;&gt; <strong>next(g1)</strong>
33
&gt;&gt;&gt; <strong>next(g1)</strong>
......
StopIteration
&gt;&gt;&gt; <strong>for item in my_simple_generator(): print(item, end=' ')</strong>
11 22 33</pre>

<h5>Example 2</h5>

<p>The following generator function <code>range_down(min, max)</code> implements the count-down version of <code>range(min, max+1)</code>.</p>

<pre class="example">
&gt;&gt;&gt; <strong>def range_down(min, max):</strong>
   <span class="comment">&quot;&quot;&quot;A generator function contains yield statement and creates a generator iterator object&quot;&quot;&quot;</span>
   <strong>current = max
   while current &gt;= min:
       yield current</strong>  <span class="comment"># Produce a result each time it is run</span>
       <strong>current -= 1</strong>   <span class="comment"># Count down</span>

&gt;&gt;&gt; <strong>range_down(5, 8)</strong>
&lt;generator object range_down at 0x7f5e34fafc18&gt;  <span class="comment"># A generator function returns a generator object</span>

<span class="comment"># Using the generator in the for-in loop</span>
&gt;&gt;&gt; <strong>for i in range_down(5, 8):
   print(i, end=" ")</strong>  <span class="comment"># 8 7 6 5</span>

<span class="comment"># Using iter() and next()</span>
&gt;&gt;&gt; <strong>itr = range_down(2, 4)</strong>  <span class="comment"># or iter(range_down(2, 4))</span>
&gt;&gt;&gt; <strong>itr</strong>
&lt;generator object range_down at 0x7f230d53a168&gt;
&gt;&gt;&gt; <strong>next(itr)</strong>
4
&gt;&gt;&gt; <strong>next(itr)</strong>
3
&gt;&gt;&gt; <strong>next(itr)</strong>
2
&gt;&gt;&gt; <strong>next(itr)</strong>
StopIteration

<span class="comment"># Using __iter__() and __next__()</span>
&gt;&gt;&gt; <strong>itr2 = range_down(5, 6).__iter__()</strong>
&gt;&gt;&gt; <strong>itr2</strong>
&lt;generator object range_down at 0x7f230d53a120&gt;
&gt;&gt;&gt; <strong>itr2.__next__()</strong>
6
&gt;&gt;&gt; <strong>itr2.__next__()</strong>
5
&gt;&gt;&gt; <strong>itr2.__next__()</strong>
StopIteration</pre>

<p>Each time the <code>yield</code> statement is run, it produce a new value, and updates the state of the generator iterator object.</p>

<h5>Example 3</h5>

<p>We can have generators which produces infinite value.</p>


<pre class="example">
from math import sqrt, ceil

def gen_primes(number):
    <span class="comment">&quot;&quot;&quot;A generator function to generate prime numbers, starting from number&quot;&quot;&quot;</span>
    while True:   <span class="comment"># No upperbound!</span>
        if is_prime(number):
            yield number
        number += 1


def is_prime(number:int) -&gt; int:
    if number &lt;= 1:
        return False

    factor = 2
    while (factor &lt;= ceil(sqrt(number))):
        if number % factor == 0: return False
        factor += 1

    return True


if __name__ == '__main__':
    g = gen_primes(8)     <span class="comment"># From 8</span>
    for i in range(100):  <span class="comment"># Generate 100 prime numbers</span>
        print(next(g))</pre>

<h5>Generator Expression</h5>

<p>A generator expression has a similar syntax as a list/dictionary comprehension (for generating a list/dictionary), but surrounded by braces and produce a generator iterator object. (Note: braces are used by tuples, but they are immutable and thus cannot be comprehended.) For example,</p>

<pre class="example">
&gt;&gt;&gt; <strong>a = (x*x for x in range(1,5))</strong>
&gt;&gt;&gt; <strong>a</strong>
&lt;generator object &lt;genexpr&gt; at 0x7f230d53a2d0&gt;
&gt;&gt;&gt; <strong>for item in a: print(item, end=' ')</strong>
1 4 9 16 
&gt;&gt;&gt; <strong>sum(a)</strong>  <span class="comment"># Applicable to functions that consume iterable</span>
30
&gt;&gt;&gt; <strong>b = (x*x for x in range(1, 10) if x*x % 2 == 0)</strong>
&gt;&gt;&gt; <strong>for item in b: print(item, end=' ')</strong>
4 16 36 64 

<span class="comment"># Compare with list/dictionary comprehension for generating list/dictionary</span>
&gt;&gt;&gt; <strong>lst = [x*x for x in range(1, 10)]</strong>
&gt;&gt;&gt; <strong>lst</strong>
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; <strong>dct = {x:x*x for x in range(1, 10)}</strong>
&gt;&gt;&gt; <strong>dct</strong>
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</pre>

<h4>Callable: <code>__call__()</code></h4>

<p>In Python, you can call an object to execute some codes, just like calling a function. This is done by providing a <code>__call__()</code> member method.  For example,</p>

<pre class="example">
class MyCallable:

    def __init__(self, value):
        self.value = value

    def __call__(self):
        return 'The value is %s' % self.value

if __name__ == '__main__':
    <span class="comment"># Construct an instance</span>
    obj = MyCallable(88)
    <span class="comment"># Call the instance, invoke __call__()</span>
    print(obj())  <span class="comment"># Output: The value is 88</span></pre>
    
<h4>Context Manager: <code>__enter__()</code> and <code>__exit__()</code></h4>

<p>[TODO]</p>




<h3 id="unittest">Unit Testing</h3>

<p>Testing is CRTICALLY IMPORTANT in software development. Some people actually advocate &quot;Write Test First (before writing the codes)&quot; (in so called Test-Driven Development (TDD)). You should at least write your tests  alongside your development.</p>

<p>In python, you can carry out unit testing via built-in modules <code>unittest</code> and <code>doctest</code>.</p>


<h4><code>unittest</code> Module</h4>

<p>The <code>unittest</code> module supports all features needed to run unit tests:</p>
<ul>
<li><span class="lead">Test Case</span>: contains a set of <em>test methods</em>, supported by <code>testunit.TestCase</code> class.</li>
<li><span class="lead">Test Suite</span>: a collection of test cases, or test suites, or both; supported by <code>testunit.TestSuite</code> class.</li>
<li><span class="lead">Test Fixture</span>: Items and preparations needed to run a test; supported via the <code>setup()</code> and <code>tearDown()</code> methods in <code>unittest.TestCase</code> class.</li>
<li><span class="lead">Test Runner</span>: run the tests and report the results; supported via <code>unittest.TestRunner</code>, <code>unittest.TestResult</code>, etc.</li>
</ul>


<h5>Example 1: Writing Test Case</h5>

<pre class="example">
<span class="comment">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
&quot;&quot;&quot;
unittest_eg1.py: Unit test example
&quot;&quot;&quot;</span>
import <span class="new">unittest</span>

<span class="comment"># Define a function to be unit-tested</span>
def my_sum(a, b):
    <span class="comment">&quot;&quot;&quot;Return a + b&quot;&quot;&quot;</span>
    return a + b

<span class="comment"># Define a test case, which consists of a set of test methods.</span>   
class <strong>TestMySum(unittest.TestCase)</strong>:  <span class="comment"># subclass of TestCase</span>
    def test_positive_inputs(self):
        result = my_sum(8, 80)
        self.assertEqual(result, 88)

    def test_negative_inputs(self):
        result = my_sum(-9, -90)
        self.assertEqual(result, -99)

    def test_mixed_inputs(self):
        result = my_sum(8, -9)
        self.assertEqual(result, -1)

    def test_zero_inputs(self):
        result = my_sum(0, 0)
        self.assertEqual(result, 0)

<span class="comment"># Run the test cases in this module</span>
if __name__ == '__main__':
    unittest.main()</pre>
   
<p>The expected outputs are:</p>
<pre class="output">
....
----------------------------------------------------------------------
Ran 4 tests in 0.001s
OK</pre>

<h5>How It Works?</h5>

<ol>
<li>You can create a test case by sub-classing <code>unittest.TestCase</code>.</li>

<li>A test case contains test methods. The test method names shall begin with <code>test</code>.</li>

<li>You can use the generic <code>assert</code> statement to compare the test result with the expected result:
<pre class="command">
assert test, [msg]
    <span class="comment"># if test is True, do nothing; else, raise AssertError with the message</span></pre></li>

<li>You can also use the <code>assertXxx()</code> methods provided by <code>unittest.TestCase</code> class. These method takes an optional argument <code>msg</code> that holds a message to be display if assertion fails. For examples,

<ul>
<li><code>assertEqual(a, b, [msg])</code>: <code>a == b</code></li>
<li><code>assertNotEqual(a, b, [msg])</code>: <code>a != b</code></li>
<li><code>assertTrue(a, [msg])</code>: <code>bool(x)</code> is <code>True</code></li>
<li><code>assertFalse(a, [msg])</code>: <code>bool(x)</code> is <code>False</code></li>
<li><code>assertIsNone(expr, [msg])</code>: <code>x is None</code></li>
<li><code>assertIsNotNone(expr, [msg])</code>: <code>x is not None</code></li>
<li><code>assertIn(a, b, [msg])</code>: <code>a in b</code></li>
<li><code>assertNotIn(a, b, [msg])</code>: <code>a not in b</code></li>
<li><code>assertIs(obj1, obj2, [msg])</code>: <code>obj1 is obj2</code></li>
<li><code>assertIsNot(obj1, obj2, [msg])</code>: <code>obj1 is not obj2</code></li>
<li><code>assertIsInstance(obj, cls, [msg])</code>: <code>isinstance(obj, cls)</code></li>
<li><code>assertIsNotInstance(obj, cls, [msg])</code>: <code>not isinstance(obj, cls)</code></li>
<li><code>assertGreater(a, b, [msg])</code>: <code>a &gt; b</code></li>
<li><code>assertLess(a, b, [msg])</code>: <code>a &lt; b</code></li>
<li><code>assertGreaterEqual(a, b, [msg])</code>: <code>a &gt;= b</code></li>
<li><code>assertLessEqual(a, b, [msg])</code>: <code>a &lt;= b</code></li>
<li><code>assertAlmostEqual(a, b, [msg])</code>: <code>round(a-b, 7) == 0</code></li>
<li><code>assertNotAlmostEqual(a, b, [msg])</code>: <code>round(a-b, 7) != 0</code></li>
<li><code>assertRegex(text, regex, [msg])</code>: <code>regex.search(text)</code></li>
<li><code>assertNotRegex(text, regex, [msg])</code>: <code>not regex.search(text)</code></li>
<li><code>assertDictEqual(a, b, [msg])</code>: </li>
<li><code>assertListEqual(a, b, [msg])</code>: </li>
<li><code>assertTupleEqual(a, b, [msg])</code>: </li>
<li><code>assertSetEqual(a, b, [msg])</code>: </li>
<li><code>assertSequenceEqual(a, b, [msg])</code>: </li>
<li><code>assertItemsEqual(a, b, [msg])</code>: </li>
<li><code>assertDictContainsSubset(a, b, [msg])</code>: </li>
<li><code>assertRaises(except, func, *args, **kwargs)</code>: <code>func(*args, **kwargs)</code> raises <code>except</code></li>

<li>Many more, see the <code>unittest</code> API documentation.</li>
</ul>
</li>

<li>Test cases and test methods run in alphanumeric order.</li> 

</ol>

<h5>Example 2: Setting up Test Fixture</h5>

<p>You can setup your test fixtures, which are available to all the text methods, via <code>setUp()</code>, <code>tearDown()</code>, <code>setUpClass()</code> and <code>tearDownClass()</code> methods.  The <code>setUp()</code> and <code>tearDown()</code> will be executed before and after EACH test method; while <code>setUpClass()</code> and <code>tearDownClass()</code> will be executed before and after ALL test methods in this test class.</p>

<p>For example,</p>

<pre class="example">
<span class="comment">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
&quot;&quot;&quot;
ut_template.py: Unit test template 
&quot;&quot;&quot;</span>
import unittest 

class <strong>MyTestClass(unittest.TestCase)</strong>:

    <span class="comment"># Run before ALL test methods in this class.</span>
    @classmethod
    def setUpClass(cls):
        print('run setUpClass()') 

    <span class="comment"># Run after ALL test methods in this class.</span>
    @classmethod
    def tearDownClass(cls):
        print('run tearDownClass()') 

    <span class="comment"># Run before EACH test method.</span>
    def setUp(self):
        print('run setUp()') 

    <span class="comment"># Run after EACH test method.</span>
    def tearDown(self):
        print('run tearDown()') 

    <span class="comment"># A test method</span>
    def test_numbers_equal(self):
        print('run test_numbers_equal()') 
        self.assertEqual(8, 8) 

    <span class="comment"># Another test method</span>
    def test_numbers_not_equal(self):
        print('run test_numbers_not_equal()') 
        self.assertNotEqual(8, -8) 

<span class="comment"># Run the test cases in this module</span>
if __name__ == '__main__':
    unittest.main()</pre>

<p>The expected outputs are:</p>

<pre class="example">
Finding files... done.
Importing test modules ... done.

run setUpClass()
run setUp()
run test_numbers_equal()
run tearDown()
run setUp()
run test_numbers_not_equal()
run tearDown()
run tearDownClass()
----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK</pre>


<p>[TODO] An Example to setup text fixtures for each test method.</p>

<h5>Example 3: Using Test Suite</h5>

<p>You can organize your test cases into test suites. For example,</p>

<pre class="example">
<span class="comment"># Define a test suite with selected test methods from test cases</span>
def my_suite1():
    suite = unittest.TestSuite()
    suite.addTest(MyTestCase('test_method1'))  <span class="comment"># add a test method</span>
    suite.addTest(MyTestCase('test_method2'))
    return suite
   
<span class="comment"># Or, generate test suite for all testXxx() methods of a test case</span>
my_suite2 = unittest.TestLoader().loadTestsFromTestCase(MyTestCase)

<span class="comment"># Run test suites</span>
if __name__ == "__main__":
    runner = unittest.TextTestRunner()  <span class="comment"># Use a text-based TestRunner</span>
    runner.run(my_suite1())
    runner.run(my_suite2)</pre>

<h5>Skipping Tests</h5>

<p>Use <code>unittest.skip([msg])</code> decorator to skip one test, e.g.,</p>

<pre class="example">
@unittest.skip('msg')  <span class="comment"># decorator to skip this test</span>
def test_x():
    ......</pre>

<p>Invoke instance method <code>skipTest([msg])</code> inside the test method to skip the test, e.g.,</p>

<pre class="example">
def test_x():
    self.skipTest()  <span class="comment"># skip this test</span>
    ......</pre>

<p>You can use decorator <code>unittest.skipIf(condition, [msg])</code>, <code>@unittest.skipUnless(condition, [msg])</code>, for conditional skip.</p>

<h5>Fail Test</h5>

<p>To fail a test, use instance method <code>fail([msg])</code>.</p>

<h4><code>doctest</code> Module</h4>

<p>Embed the test input/output pairs in the doc-string, and invoke <code>doctest.testmod()</code>. For example,</p>

<pre class="example">
<span class="comment">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-</span>
import doctest

<span class="comment"># Define a function to be unit-tested</span>
def my_sum(a, b):
    &quot;&quot;&quot;
    (number, number) -&gt; number
    Return a + b

    For use by doctest:
    <strong>&gt;&gt;&gt; my_sum(8, 80)
    88
    &gt;&gt;&gt; my_sum(-9, -90)
    -99
    &gt;&gt;&gt; my_sum(8, -9)
    -1
    &gt;&gt;&gt; my_sum(0, 0)
    0</strong>
    &quot;&quot;&quot;
    return a + b

if __name__ == '__main__':
    doctest.testmod(verbose=1)</pre>
   
<p>Study the outputs:</p>
<pre class="output">
Trying:
    my_sum(8, 80)
Expecting:
    88
ok
Trying:
    my_sum(-9, -90)
Expecting:
    -99
ok
Trying:
    my_sum(8, -9)
Expecting:
    -1
ok
Trying:
    my_sum(0, 0)
Expecting:
    0
ok
1 items had no tests:
    __main__
1 items passed all tests:
   4 tests in __main__.my_sum
4 tests in 2 items.
4 passed and 0 failed.
Test passed.</pre>

<p>The &quot;<code>(number, number) -&gt; number</code>&quot; is known as type contract, which spells out the expected types of the parameters and return value.</p>



<h3 id="performance">Performance Measurement</h3>

<p>You can use modules <code>timeit</code>, <code>profile</code> and <code>pstats</code> for profiling Python program and performance measurements.</p>

<p>[TODO] examples</p>

<p>You could measure code coverage via <code>coverage</code> module.</p>
<p>[TODO] examples</p>


<!-- @@ start change in v1 -->
<p class="references">REFERENCES &amp; RESOURCES</p>

<ol>
<li>The Python's mother site @ <a href="http://www.python.org">www.python.org</a>; &quot;The Python Documentation&quot; @ <a href="https://www.python.org/doc/">https://www.python.org/doc/</a>; &quot;The Python Tutorial&quot; @ <a href="https://docs.python.org/tutorial/">https://docs.python.org/tutorial/</a>; &quot;The Python Language Reference&quot; @ <a href="https://docs.python.org/reference/">https://docs.python.org/reference/</a>.</li>
</ol>
</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: Python (Ubuntu, Windows, Cygwin) 3.7.1 and 2.7.14<br>
Last modified: November, 2018</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- @@ v3 footer changes starts here, before "footer", to end of document -->
<!-- footer filled by JavaScript -->
<div id="footer" class="footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->

<!-- jQuery -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<!-- My custom JavaScript v3 -->
<script src="../scripts/programming_notes_v3.js"></script>
<!-- Prism Syntax Highlighter -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
